schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """measured in seconds"""
  ttl: Int! = 60

  """refresh the cache entry"""
  refresh: Boolean! = false
) on QUERY

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input BooleanComparisonExp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _isNull: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""Table to store different categories for chatbots."""
type Category {
  categoryId: Int!

  """An array relationship"""
  chatbots(
    """distinct select on columns"""
    distinctOn: [ChatbotCategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotCategoryOrderBy!]

    """filter the rows returned"""
    where: ChatbotCategoryBoolExp
  ): [ChatbotCategory!]!

  """An aggregate relationship"""
  chatbotsAggregate(
    """distinct select on columns"""
    distinctOn: [ChatbotCategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotCategoryOrderBy!]

    """filter the rows returned"""
    where: ChatbotCategoryBoolExp
  ): ChatbotCategoryAggregate!
  name: String!
}

"""
aggregated selection of "category"
"""
type CategoryAggregate {
  aggregate: CategoryAggregateFields
  nodes: [Category!]!
}

"""
aggregate fields of "category"
"""
type CategoryAggregateFields {
  avg: CategoryAvgFields
  count(columns: [CategorySelectColumn!], distinct: Boolean): Int!
  max: CategoryMaxFields
  min: CategoryMinFields
  stddev: CategoryStddevFields
  stddevPop: CategoryStddevPopFields
  stddevSamp: CategoryStddevSampFields
  sum: CategorySumFields
  varPop: CategoryVarPopFields
  varSamp: CategoryVarSampFields
  variance: CategoryVarianceFields
}

"""aggregate avg on columns"""
type CategoryAvgFields {
  categoryId: Float
}

"""
Boolean expression to filter rows from the table "category". All fields are combined with a logical 'AND'.
"""
input CategoryBoolExp {
  _and: [CategoryBoolExp!]
  _not: CategoryBoolExp
  _or: [CategoryBoolExp!]
  categoryId: IntComparisonExp
  chatbots: ChatbotCategoryBoolExp
  chatbotsAggregate: ChatbotCategoryAggregateBoolExp
  name: StringComparisonExp
}

"""
unique or primary key constraints on table "category"
"""
enum CategoryConstraint {
  """
  unique or primary key constraint on columns "name"
  """
  category_name_key

  """
  unique or primary key constraint on columns "category_id"
  """
  category_pkey
}

"""
input type for incrementing numeric columns in table "category"
"""
input CategoryIncInput {
  categoryId: Int
}

"""
input type for inserting data into table "category"
"""
input CategoryInsertInput {
  categoryId: Int
  chatbots: ChatbotCategoryArrRelInsertInput
  name: String
}

"""aggregate max on columns"""
type CategoryMaxFields {
  categoryId: Int
  name: String
}

"""aggregate min on columns"""
type CategoryMinFields {
  categoryId: Int
  name: String
}

"""
response of any mutation on the table "category"
"""
type CategoryMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Category!]!
}

"""
input type for inserting object relation for remote table "category"
"""
input CategoryObjRelInsertInput {
  data: CategoryInsertInput!

  """upsert condition"""
  onConflict: CategoryOnConflict
}

"""
on_conflict condition type for table "category"
"""
input CategoryOnConflict {
  constraint: CategoryConstraint!
  updateColumns: [CategoryUpdateColumn!]! = []
  where: CategoryBoolExp
}

"""Ordering options when selecting data from "category"."""
input CategoryOrderBy {
  categoryId: OrderBy
  chatbotsAggregate: ChatbotCategoryAggregateOrderBy
  name: OrderBy
}

"""primary key columns input for table: category"""
input CategoryPkColumnsInput {
  categoryId: Int!
}

"""
select columns of table "category"
"""
enum CategorySelectColumn {
  """column name"""
  categoryId

  """column name"""
  name
}

"""
input type for updating data in table "category"
"""
input CategorySetInput {
  categoryId: Int
  name: String
}

"""aggregate stddev on columns"""
type CategoryStddevFields {
  categoryId: Float
}

"""aggregate stddevPop on columns"""
type CategoryStddevPopFields {
  categoryId: Float
}

"""aggregate stddevSamp on columns"""
type CategoryStddevSampFields {
  categoryId: Float
}

"""
Streaming cursor of the table "category"
"""
input CategoryStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: CategoryStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input CategoryStreamCursorValueInput {
  categoryId: Int
  name: String
}

"""aggregate sum on columns"""
type CategorySumFields {
  categoryId: Int
}

"""
update columns of table "category"
"""
enum CategoryUpdateColumn {
  """column name"""
  categoryId

  """column name"""
  name
}

input CategoryUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: CategoryIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: CategorySetInput

  """filter the rows which have to be updated"""
  where: CategoryBoolExp!
}

"""aggregate varPop on columns"""
type CategoryVarPopFields {
  categoryId: Float
}

"""aggregate varSamp on columns"""
type CategoryVarSampFields {
  categoryId: Float
}

"""aggregate variance on columns"""
type CategoryVarianceFields {
  categoryId: Float
}

"""
Table to store links to GPT chat conversations and associate them with a specific GPT chatbot and the user who added the link.
"""
type Chat {
  addedBy: uuid
  chatId: Int!

  """An object relationship"""
  chatbot: Chatbot!
  chatbotId: Int!
  conversationLink: String!

  """An object relationship"""
  user: User
}

"""
aggregated selection of "chat"
"""
type ChatAggregate {
  aggregate: ChatAggregateFields
  nodes: [Chat!]!
}

input ChatAggregateBoolExp {
  count: chatAggregateBoolExpCount
}

"""
aggregate fields of "chat"
"""
type ChatAggregateFields {
  avg: ChatAvgFields
  count(columns: [ChatSelectColumn!], distinct: Boolean): Int!
  max: ChatMaxFields
  min: ChatMinFields
  stddev: ChatStddevFields
  stddevPop: ChatStddevPopFields
  stddevSamp: ChatStddevSampFields
  sum: ChatSumFields
  varPop: ChatVarPopFields
  varSamp: ChatVarSampFields
  variance: ChatVarianceFields
}

"""
order by aggregate values of table "chat"
"""
input ChatAggregateOrderBy {
  avg: ChatAvgOrderBy
  count: OrderBy
  max: ChatMaxOrderBy
  min: ChatMinOrderBy
  stddev: ChatStddevOrderBy
  stddevPop: ChatStddevPopOrderBy
  stddevSamp: ChatStddevSampOrderBy
  sum: ChatSumOrderBy
  varPop: ChatVarPopOrderBy
  varSamp: ChatVarSampOrderBy
  variance: ChatVarianceOrderBy
}

"""
input type for inserting array relation for remote table "chat"
"""
input ChatArrRelInsertInput {
  data: [ChatInsertInput!]!

  """upsert condition"""
  onConflict: ChatOnConflict
}

"""aggregate avg on columns"""
type ChatAvgFields {
  chatId: Float
  chatbotId: Float
}

"""
order by avg() on columns of table "chat"
"""
input ChatAvgOrderBy {
  chatId: OrderBy
  chatbotId: OrderBy
}

"""
Boolean expression to filter rows from the table "chat". All fields are combined with a logical 'AND'.
"""
input ChatBoolExp {
  _and: [ChatBoolExp!]
  _not: ChatBoolExp
  _or: [ChatBoolExp!]
  addedBy: UuidComparisonExp
  chatId: IntComparisonExp
  chatbot: ChatbotBoolExp
  chatbotId: IntComparisonExp
  conversationLink: StringComparisonExp
  user: UserBoolExp
}

"""
unique or primary key constraints on table "chat"
"""
enum ChatConstraint {
  """
  unique or primary key constraint on columns "conversation_link"
  """
  gpt_chat_conversation_link_key

  """
  unique or primary key constraint on columns "chat_id"
  """
  gpt_chat_pkey
}

"""
input type for incrementing numeric columns in table "chat"
"""
input ChatIncInput {
  chatId: Int
  chatbotId: Int
}

"""
input type for inserting data into table "chat"
"""
input ChatInsertInput {
  addedBy: uuid
  chatId: Int
  chatbot: ChatbotObjRelInsertInput
  chatbotId: Int
  conversationLink: String
  user: UserObjRelInsertInput
}

"""aggregate max on columns"""
type ChatMaxFields {
  addedBy: uuid
  chatId: Int
  chatbotId: Int
  conversationLink: String
}

"""
order by max() on columns of table "chat"
"""
input ChatMaxOrderBy {
  addedBy: OrderBy
  chatId: OrderBy
  chatbotId: OrderBy
  conversationLink: OrderBy
}

"""aggregate min on columns"""
type ChatMinFields {
  addedBy: uuid
  chatId: Int
  chatbotId: Int
  conversationLink: String
}

"""
order by min() on columns of table "chat"
"""
input ChatMinOrderBy {
  addedBy: OrderBy
  chatId: OrderBy
  chatbotId: OrderBy
  conversationLink: OrderBy
}

"""
response of any mutation on the table "chat"
"""
type ChatMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Chat!]!
}

"""
on_conflict condition type for table "chat"
"""
input ChatOnConflict {
  constraint: ChatConstraint!
  updateColumns: [ChatUpdateColumn!]! = []
  where: ChatBoolExp
}

"""Ordering options when selecting data from "chat"."""
input ChatOrderBy {
  addedBy: OrderBy
  chatId: OrderBy
  chatbot: ChatbotOrderBy
  chatbotId: OrderBy
  conversationLink: OrderBy
  user: UserOrderBy
}

"""primary key columns input for table: chat"""
input ChatPkColumnsInput {
  chatId: Int!
}

"""
select columns of table "chat"
"""
enum ChatSelectColumn {
  """column name"""
  addedBy

  """column name"""
  chatId

  """column name"""
  chatbotId

  """column name"""
  conversationLink
}

"""
input type for updating data in table "chat"
"""
input ChatSetInput {
  addedBy: uuid
  chatId: Int
  chatbotId: Int
  conversationLink: String
}

"""aggregate stddev on columns"""
type ChatStddevFields {
  chatId: Float
  chatbotId: Float
}

"""
order by stddev() on columns of table "chat"
"""
input ChatStddevOrderBy {
  chatId: OrderBy
  chatbotId: OrderBy
}

"""aggregate stddevPop on columns"""
type ChatStddevPopFields {
  chatId: Float
  chatbotId: Float
}

"""
order by stddevPop() on columns of table "chat"
"""
input ChatStddevPopOrderBy {
  chatId: OrderBy
  chatbotId: OrderBy
}

"""aggregate stddevSamp on columns"""
type ChatStddevSampFields {
  chatId: Float
  chatbotId: Float
}

"""
order by stddevSamp() on columns of table "chat"
"""
input ChatStddevSampOrderBy {
  chatId: OrderBy
  chatbotId: OrderBy
}

"""
Streaming cursor of the table "chat"
"""
input ChatStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ChatStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ChatStreamCursorValueInput {
  addedBy: uuid
  chatId: Int
  chatbotId: Int
  conversationLink: String
}

"""aggregate sum on columns"""
type ChatSumFields {
  chatId: Int
  chatbotId: Int
}

"""
order by sum() on columns of table "chat"
"""
input ChatSumOrderBy {
  chatId: OrderBy
  chatbotId: OrderBy
}

"""
update columns of table "chat"
"""
enum ChatUpdateColumn {
  """column name"""
  addedBy

  """column name"""
  chatId

  """column name"""
  chatbotId

  """column name"""
  conversationLink
}

input ChatUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: ChatIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: ChatSetInput

  """filter the rows which have to be updated"""
  where: ChatBoolExp!
}

"""aggregate varPop on columns"""
type ChatVarPopFields {
  chatId: Float
  chatbotId: Float
}

"""
order by varPop() on columns of table "chat"
"""
input ChatVarPopOrderBy {
  chatId: OrderBy
  chatbotId: OrderBy
}

"""aggregate varSamp on columns"""
type ChatVarSampFields {
  chatId: Float
  chatbotId: Float
}

"""
order by varSamp() on columns of table "chat"
"""
input ChatVarSampOrderBy {
  chatId: OrderBy
  chatbotId: OrderBy
}

"""aggregate variance on columns"""
type ChatVarianceFields {
  chatId: Float
  chatbotId: Float
}

"""
order by variance() on columns of table "chat"
"""
input ChatVarianceOrderBy {
  chatId: OrderBy
  chatbotId: OrderBy
}

"""
Table storing information about chatbots, their characteristics, and default settings.
"""
type Chatbot {
  avatar: String

  """An array relationship"""
  categories(
    """distinct select on columns"""
    distinctOn: [ChatbotCategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotCategoryOrderBy!]

    """filter the rows returned"""
    where: ChatbotCategoryBoolExp
  ): [ChatbotCategory!]!

  """An aggregate relationship"""
  categoriesAggregate(
    """distinct select on columns"""
    distinctOn: [ChatbotCategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotCategoryOrderBy!]

    """filter the rows returned"""
    where: ChatbotCategoryBoolExp
  ): ChatbotCategoryAggregate!
  chatbotId: Int!

  """An array relationship"""
  chats(
    """distinct select on columns"""
    distinctOn: [ChatSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatOrderBy!]

    """filter the rows returned"""
    where: ChatBoolExp
  ): [Chat!]!

  """An aggregate relationship"""
  chatsAggregate(
    """distinct select on columns"""
    distinctOn: [ChatSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatOrderBy!]

    """filter the rows returned"""
    where: ChatBoolExp
  ): ChatAggregate!
  createdBy: String!
  defaultComplexity: String!
  defaultLength: String!
  defaultTone: String!
  defaultType: String!
  description: String
  name: String!

  """An array relationship"""
  preferences(
    """distinct select on columns"""
    distinctOn: [PreferenceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PreferenceOrderBy!]

    """filter the rows returned"""
    where: PreferenceBoolExp
  ): [Preference!]!

  """An aggregate relationship"""
  preferencesAggregate(
    """distinct select on columns"""
    distinctOn: [PreferenceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PreferenceOrderBy!]

    """filter the rows returned"""
    where: PreferenceBoolExp
  ): PreferenceAggregate!

  """An array relationship"""
  prompts(
    """distinct select on columns"""
    distinctOn: [PromptChatbotSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptChatbotOrderBy!]

    """filter the rows returned"""
    where: PromptChatbotBoolExp
  ): [PromptChatbot!]!

  """An aggregate relationship"""
  promptsAggregate(
    """distinct select on columns"""
    distinctOn: [PromptChatbotSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptChatbotOrderBy!]

    """filter the rows returned"""
    where: PromptChatbotBoolExp
  ): PromptChatbotAggregate!

  """An array relationship"""
  threads(
    """distinct select on columns"""
    distinctOn: [ThreadSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ThreadOrderBy!]

    """filter the rows returned"""
    where: ThreadBoolExp
  ): [Thread!]!

  """An aggregate relationship"""
  threadsAggregate(
    """distinct select on columns"""
    distinctOn: [ThreadSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ThreadOrderBy!]

    """filter the rows returned"""
    where: ThreadBoolExp
  ): ThreadAggregate!
}

"""
aggregated selection of "chatbot"
"""
type ChatbotAggregate {
  aggregate: ChatbotAggregateFields
  nodes: [Chatbot!]!
}

"""
aggregate fields of "chatbot"
"""
type ChatbotAggregateFields {
  avg: ChatbotAvgFields
  count(columns: [ChatbotSelectColumn!], distinct: Boolean): Int!
  max: ChatbotMaxFields
  min: ChatbotMinFields
  stddev: ChatbotStddevFields
  stddevPop: ChatbotStddevPopFields
  stddevSamp: ChatbotStddevSampFields
  sum: ChatbotSumFields
  varPop: ChatbotVarPopFields
  varSamp: ChatbotVarSampFields
  variance: ChatbotVarianceFields
}

"""aggregate avg on columns"""
type ChatbotAvgFields {
  chatbotId: Float
}

"""
Boolean expression to filter rows from the table "chatbot". All fields are combined with a logical 'AND'.
"""
input ChatbotBoolExp {
  _and: [ChatbotBoolExp!]
  _not: ChatbotBoolExp
  _or: [ChatbotBoolExp!]
  avatar: StringComparisonExp
  categories: ChatbotCategoryBoolExp
  categoriesAggregate: ChatbotCategoryAggregateBoolExp
  chatbotId: IntComparisonExp
  chats: ChatBoolExp
  chatsAggregate: ChatAggregateBoolExp
  createdBy: StringComparisonExp
  defaultComplexity: StringComparisonExp
  defaultLength: StringComparisonExp
  defaultTone: StringComparisonExp
  defaultType: StringComparisonExp
  description: StringComparisonExp
  name: StringComparisonExp
  preferences: PreferenceBoolExp
  preferencesAggregate: PreferenceAggregateBoolExp
  prompts: PromptChatbotBoolExp
  promptsAggregate: PromptChatbotAggregateBoolExp
  threads: ThreadBoolExp
  threadsAggregate: ThreadAggregateBoolExp
}

"""
Junction table to manage the many-to-many relationships between chatbots and their categories.
"""
type ChatbotCategory {
  """An object relationship"""
  category: Category!
  categoryId: Int!

  """An object relationship"""
  chatbot: Chatbot!
  chatbotId: Int!
}

"""
aggregated selection of "chatbot_category"
"""
type ChatbotCategoryAggregate {
  aggregate: ChatbotCategoryAggregateFields
  nodes: [ChatbotCategory!]!
}

input ChatbotCategoryAggregateBoolExp {
  count: chatbotCategoryAggregateBoolExpCount
}

"""
aggregate fields of "chatbot_category"
"""
type ChatbotCategoryAggregateFields {
  avg: ChatbotCategoryAvgFields
  count(columns: [ChatbotCategorySelectColumn!], distinct: Boolean): Int!
  max: ChatbotCategoryMaxFields
  min: ChatbotCategoryMinFields
  stddev: ChatbotCategoryStddevFields
  stddevPop: ChatbotCategoryStddevPopFields
  stddevSamp: ChatbotCategoryStddevSampFields
  sum: ChatbotCategorySumFields
  varPop: ChatbotCategoryVarPopFields
  varSamp: ChatbotCategoryVarSampFields
  variance: ChatbotCategoryVarianceFields
}

"""
order by aggregate values of table "chatbot_category"
"""
input ChatbotCategoryAggregateOrderBy {
  avg: ChatbotCategoryAvgOrderBy
  count: OrderBy
  max: ChatbotCategoryMaxOrderBy
  min: ChatbotCategoryMinOrderBy
  stddev: ChatbotCategoryStddevOrderBy
  stddevPop: ChatbotCategoryStddevPopOrderBy
  stddevSamp: ChatbotCategoryStddevSampOrderBy
  sum: ChatbotCategorySumOrderBy
  varPop: ChatbotCategoryVarPopOrderBy
  varSamp: ChatbotCategoryVarSampOrderBy
  variance: ChatbotCategoryVarianceOrderBy
}

"""
input type for inserting array relation for remote table "chatbot_category"
"""
input ChatbotCategoryArrRelInsertInput {
  data: [ChatbotCategoryInsertInput!]!

  """upsert condition"""
  onConflict: ChatbotCategoryOnConflict
}

"""aggregate avg on columns"""
type ChatbotCategoryAvgFields {
  categoryId: Float
  chatbotId: Float
}

"""
order by avg() on columns of table "chatbot_category"
"""
input ChatbotCategoryAvgOrderBy {
  categoryId: OrderBy
  chatbotId: OrderBy
}

"""
Boolean expression to filter rows from the table "chatbot_category". All fields are combined with a logical 'AND'.
"""
input ChatbotCategoryBoolExp {
  _and: [ChatbotCategoryBoolExp!]
  _not: ChatbotCategoryBoolExp
  _or: [ChatbotCategoryBoolExp!]
  category: CategoryBoolExp
  categoryId: IntComparisonExp
  chatbot: ChatbotBoolExp
  chatbotId: IntComparisonExp
}

"""
unique or primary key constraints on table "chatbot_category"
"""
enum ChatbotCategoryConstraint {
  """
  unique or primary key constraint on columns "category_id", "chatbot_id"
  """
  chatbot_category_pkey
}

"""
input type for incrementing numeric columns in table "chatbot_category"
"""
input ChatbotCategoryIncInput {
  categoryId: Int
  chatbotId: Int
}

"""
input type for inserting data into table "chatbot_category"
"""
input ChatbotCategoryInsertInput {
  category: CategoryObjRelInsertInput
  categoryId: Int
  chatbot: ChatbotObjRelInsertInput
  chatbotId: Int
}

"""aggregate max on columns"""
type ChatbotCategoryMaxFields {
  categoryId: Int
  chatbotId: Int
}

"""
order by max() on columns of table "chatbot_category"
"""
input ChatbotCategoryMaxOrderBy {
  categoryId: OrderBy
  chatbotId: OrderBy
}

"""aggregate min on columns"""
type ChatbotCategoryMinFields {
  categoryId: Int
  chatbotId: Int
}

"""
order by min() on columns of table "chatbot_category"
"""
input ChatbotCategoryMinOrderBy {
  categoryId: OrderBy
  chatbotId: OrderBy
}

"""
response of any mutation on the table "chatbot_category"
"""
type ChatbotCategoryMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [ChatbotCategory!]!
}

"""
on_conflict condition type for table "chatbot_category"
"""
input ChatbotCategoryOnConflict {
  constraint: ChatbotCategoryConstraint!
  updateColumns: [ChatbotCategoryUpdateColumn!]! = []
  where: ChatbotCategoryBoolExp
}

"""Ordering options when selecting data from "chatbot_category"."""
input ChatbotCategoryOrderBy {
  category: CategoryOrderBy
  categoryId: OrderBy
  chatbot: ChatbotOrderBy
  chatbotId: OrderBy
}

"""primary key columns input for table: chatbot_category"""
input ChatbotCategoryPkColumnsInput {
  categoryId: Int!
  chatbotId: Int!
}

"""
select columns of table "chatbot_category"
"""
enum ChatbotCategorySelectColumn {
  """column name"""
  categoryId

  """column name"""
  chatbotId
}

"""
input type for updating data in table "chatbot_category"
"""
input ChatbotCategorySetInput {
  categoryId: Int
  chatbotId: Int
}

"""aggregate stddev on columns"""
type ChatbotCategoryStddevFields {
  categoryId: Float
  chatbotId: Float
}

"""
order by stddev() on columns of table "chatbot_category"
"""
input ChatbotCategoryStddevOrderBy {
  categoryId: OrderBy
  chatbotId: OrderBy
}

"""aggregate stddevPop on columns"""
type ChatbotCategoryStddevPopFields {
  categoryId: Float
  chatbotId: Float
}

"""
order by stddevPop() on columns of table "chatbot_category"
"""
input ChatbotCategoryStddevPopOrderBy {
  categoryId: OrderBy
  chatbotId: OrderBy
}

"""aggregate stddevSamp on columns"""
type ChatbotCategoryStddevSampFields {
  categoryId: Float
  chatbotId: Float
}

"""
order by stddevSamp() on columns of table "chatbot_category"
"""
input ChatbotCategoryStddevSampOrderBy {
  categoryId: OrderBy
  chatbotId: OrderBy
}

"""
Streaming cursor of the table "chatbot_category"
"""
input ChatbotCategoryStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ChatbotCategoryStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ChatbotCategoryStreamCursorValueInput {
  categoryId: Int
  chatbotId: Int
}

"""aggregate sum on columns"""
type ChatbotCategorySumFields {
  categoryId: Int
  chatbotId: Int
}

"""
order by sum() on columns of table "chatbot_category"
"""
input ChatbotCategorySumOrderBy {
  categoryId: OrderBy
  chatbotId: OrderBy
}

"""
update columns of table "chatbot_category"
"""
enum ChatbotCategoryUpdateColumn {
  """column name"""
  categoryId

  """column name"""
  chatbotId
}

input ChatbotCategoryUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: ChatbotCategoryIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: ChatbotCategorySetInput

  """filter the rows which have to be updated"""
  where: ChatbotCategoryBoolExp!
}

"""aggregate varPop on columns"""
type ChatbotCategoryVarPopFields {
  categoryId: Float
  chatbotId: Float
}

"""
order by varPop() on columns of table "chatbot_category"
"""
input ChatbotCategoryVarPopOrderBy {
  categoryId: OrderBy
  chatbotId: OrderBy
}

"""aggregate varSamp on columns"""
type ChatbotCategoryVarSampFields {
  categoryId: Float
  chatbotId: Float
}

"""
order by varSamp() on columns of table "chatbot_category"
"""
input ChatbotCategoryVarSampOrderBy {
  categoryId: OrderBy
  chatbotId: OrderBy
}

"""aggregate variance on columns"""
type ChatbotCategoryVarianceFields {
  categoryId: Float
  chatbotId: Float
}

"""
order by variance() on columns of table "chatbot_category"
"""
input ChatbotCategoryVarianceOrderBy {
  categoryId: OrderBy
  chatbotId: OrderBy
}

"""
unique or primary key constraints on table "chatbot"
"""
enum ChatbotConstraint {
  """
  unique or primary key constraint on columns "name"
  """
  chatbot_name_key

  """
  unique or primary key constraint on columns "chatbot_id"
  """
  chatbot_pkey
}

"""
input type for incrementing numeric columns in table "chatbot"
"""
input ChatbotIncInput {
  chatbotId: Int
}

"""
input type for inserting data into table "chatbot"
"""
input ChatbotInsertInput {
  avatar: String
  categories: ChatbotCategoryArrRelInsertInput
  chatbotId: Int
  chats: ChatArrRelInsertInput
  createdBy: String
  defaultComplexity: String
  defaultLength: String
  defaultTone: String
  defaultType: String
  description: String
  name: String
  preferences: PreferenceArrRelInsertInput
  prompts: PromptChatbotArrRelInsertInput
  threads: ThreadArrRelInsertInput
}

"""aggregate max on columns"""
type ChatbotMaxFields {
  avatar: String
  chatbotId: Int
  createdBy: String
  defaultComplexity: String
  defaultLength: String
  defaultTone: String
  defaultType: String
  description: String
  name: String
}

"""aggregate min on columns"""
type ChatbotMinFields {
  avatar: String
  chatbotId: Int
  createdBy: String
  defaultComplexity: String
  defaultLength: String
  defaultTone: String
  defaultType: String
  description: String
  name: String
}

"""
response of any mutation on the table "chatbot"
"""
type ChatbotMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Chatbot!]!
}

"""
input type for inserting object relation for remote table "chatbot"
"""
input ChatbotObjRelInsertInput {
  data: ChatbotInsertInput!

  """upsert condition"""
  onConflict: ChatbotOnConflict
}

"""
on_conflict condition type for table "chatbot"
"""
input ChatbotOnConflict {
  constraint: ChatbotConstraint!
  updateColumns: [ChatbotUpdateColumn!]! = []
  where: ChatbotBoolExp
}

"""Ordering options when selecting data from "chatbot"."""
input ChatbotOrderBy {
  avatar: OrderBy
  categoriesAggregate: ChatbotCategoryAggregateOrderBy
  chatbotId: OrderBy
  chatsAggregate: ChatAggregateOrderBy
  createdBy: OrderBy
  defaultComplexity: OrderBy
  defaultLength: OrderBy
  defaultTone: OrderBy
  defaultType: OrderBy
  description: OrderBy
  name: OrderBy
  preferencesAggregate: PreferenceAggregateOrderBy
  promptsAggregate: PromptChatbotAggregateOrderBy
  threadsAggregate: ThreadAggregateOrderBy
}

"""primary key columns input for table: chatbot"""
input ChatbotPkColumnsInput {
  chatbotId: Int!
}

"""
select columns of table "chatbot"
"""
enum ChatbotSelectColumn {
  """column name"""
  avatar

  """column name"""
  chatbotId

  """column name"""
  createdBy

  """column name"""
  defaultComplexity

  """column name"""
  defaultLength

  """column name"""
  defaultTone

  """column name"""
  defaultType

  """column name"""
  description

  """column name"""
  name
}

"""
input type for updating data in table "chatbot"
"""
input ChatbotSetInput {
  avatar: String
  chatbotId: Int
  createdBy: String
  defaultComplexity: String
  defaultLength: String
  defaultTone: String
  defaultType: String
  description: String
  name: String
}

"""aggregate stddev on columns"""
type ChatbotStddevFields {
  chatbotId: Float
}

"""aggregate stddevPop on columns"""
type ChatbotStddevPopFields {
  chatbotId: Float
}

"""aggregate stddevSamp on columns"""
type ChatbotStddevSampFields {
  chatbotId: Float
}

"""
Streaming cursor of the table "chatbot"
"""
input ChatbotStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ChatbotStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ChatbotStreamCursorValueInput {
  avatar: String
  chatbotId: Int
  createdBy: String
  defaultComplexity: String
  defaultLength: String
  defaultTone: String
  defaultType: String
  description: String
  name: String
}

"""aggregate sum on columns"""
type ChatbotSumFields {
  chatbotId: Int
}

"""
update columns of table "chatbot"
"""
enum ChatbotUpdateColumn {
  """column name"""
  avatar

  """column name"""
  chatbotId

  """column name"""
  createdBy

  """column name"""
  defaultComplexity

  """column name"""
  defaultLength

  """column name"""
  defaultTone

  """column name"""
  defaultType

  """column name"""
  description

  """column name"""
  name
}

input ChatbotUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: ChatbotIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: ChatbotSetInput

  """filter the rows which have to be updated"""
  where: ChatbotBoolExp!
}

"""aggregate varPop on columns"""
type ChatbotVarPopFields {
  chatbotId: Float
}

"""aggregate varSamp on columns"""
type ChatbotVarSampFields {
  chatbotId: Float
}

"""aggregate variance on columns"""
type ChatbotVarianceFields {
  chatbotId: Float
}

"""
columns and relationships of "complexity_enum"
"""
type ComplexityEnum {
  value: String!
}

"""
aggregated selection of "complexity_enum"
"""
type ComplexityEnumAggregate {
  aggregate: ComplexityEnumAggregateFields
  nodes: [ComplexityEnum!]!
}

"""
aggregate fields of "complexity_enum"
"""
type ComplexityEnumAggregateFields {
  count(columns: [ComplexityEnumSelectColumn!], distinct: Boolean): Int!
  max: ComplexityEnumMaxFields
  min: ComplexityEnumMinFields
}

"""
Boolean expression to filter rows from the table "complexity_enum". All fields are combined with a logical 'AND'.
"""
input ComplexityEnumBoolExp {
  _and: [ComplexityEnumBoolExp!]
  _not: ComplexityEnumBoolExp
  _or: [ComplexityEnumBoolExp!]
  value: StringComparisonExp
}

"""
unique or primary key constraints on table "complexity_enum"
"""
enum ComplexityEnumConstraint {
  """
  unique or primary key constraint on columns "value"
  """
  default_complexity_enum_pkey
}

"""
input type for inserting data into table "complexity_enum"
"""
input ComplexityEnumInsertInput {
  value: String
}

"""aggregate max on columns"""
type ComplexityEnumMaxFields {
  value: String
}

"""aggregate min on columns"""
type ComplexityEnumMinFields {
  value: String
}

"""
response of any mutation on the table "complexity_enum"
"""
type ComplexityEnumMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [ComplexityEnum!]!
}

"""
on_conflict condition type for table "complexity_enum"
"""
input ComplexityEnumOnConflict {
  constraint: ComplexityEnumConstraint!
  updateColumns: [ComplexityEnumUpdateColumn!]! = []
  where: ComplexityEnumBoolExp
}

"""Ordering options when selecting data from "complexity_enum"."""
input ComplexityEnumOrderBy {
  value: OrderBy
}

"""primary key columns input for table: complexity_enum"""
input ComplexityEnumPkColumnsInput {
  value: String!
}

"""
select columns of table "complexity_enum"
"""
enum ComplexityEnumSelectColumn {
  """column name"""
  value
}

"""
input type for updating data in table "complexity_enum"
"""
input ComplexityEnumSetInput {
  value: String
}

"""
Streaming cursor of the table "complexity_enum"
"""
input ComplexityEnumStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ComplexityEnumStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ComplexityEnumStreamCursorValueInput {
  value: String
}

"""
update columns of table "complexity_enum"
"""
enum ComplexityEnumUpdateColumn {
  """column name"""
  value
}

input ComplexityEnumUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: ComplexityEnumSetInput

  """filter the rows which have to be updated"""
  where: ComplexityEnumBoolExp!
}

"""ordering argument of a cursor"""
enum CursorOrdering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input IntComparisonExp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _isNull: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""
columns and relationships of "length_enum"
"""
type LengthEnum {
  value: String!
}

"""
aggregated selection of "length_enum"
"""
type LengthEnumAggregate {
  aggregate: LengthEnumAggregateFields
  nodes: [LengthEnum!]!
}

"""
aggregate fields of "length_enum"
"""
type LengthEnumAggregateFields {
  count(columns: [LengthEnumSelectColumn!], distinct: Boolean): Int!
  max: LengthEnumMaxFields
  min: LengthEnumMinFields
}

"""
Boolean expression to filter rows from the table "length_enum". All fields are combined with a logical 'AND'.
"""
input LengthEnumBoolExp {
  _and: [LengthEnumBoolExp!]
  _not: LengthEnumBoolExp
  _or: [LengthEnumBoolExp!]
  value: StringComparisonExp
}

"""
unique or primary key constraints on table "length_enum"
"""
enum LengthEnumConstraint {
  """
  unique or primary key constraint on columns "value"
  """
  default_length_enum_pkey
}

"""
input type for inserting data into table "length_enum"
"""
input LengthEnumInsertInput {
  value: String
}

"""aggregate max on columns"""
type LengthEnumMaxFields {
  value: String
}

"""aggregate min on columns"""
type LengthEnumMinFields {
  value: String
}

"""
response of any mutation on the table "length_enum"
"""
type LengthEnumMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [LengthEnum!]!
}

"""
on_conflict condition type for table "length_enum"
"""
input LengthEnumOnConflict {
  constraint: LengthEnumConstraint!
  updateColumns: [LengthEnumUpdateColumn!]! = []
  where: LengthEnumBoolExp
}

"""Ordering options when selecting data from "length_enum"."""
input LengthEnumOrderBy {
  value: OrderBy
}

"""primary key columns input for table: length_enum"""
input LengthEnumPkColumnsInput {
  value: String!
}

"""
select columns of table "length_enum"
"""
enum LengthEnumSelectColumn {
  """column name"""
  value
}

"""
input type for updating data in table "length_enum"
"""
input LengthEnumSetInput {
  value: String
}

"""
Streaming cursor of the table "length_enum"
"""
input LengthEnumStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: LengthEnumStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input LengthEnumStreamCursorValueInput {
  value: String
}

"""
update columns of table "length_enum"
"""
enum LengthEnumUpdateColumn {
  """column name"""
  value
}

input LengthEnumUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: LengthEnumSetInput

  """filter the rows which have to be updated"""
  where: LengthEnumBoolExp!
}

"""This table stores the messages exchanged between users and chatbots."""
type Message {
  content: String!
  createdAt: timestamptz!
  messageId: uuid!
  role: String!

  """An object relationship"""
  thread: Thread
  threadId: uuid
}

"""
aggregated selection of "message"
"""
type MessageAggregate {
  aggregate: MessageAggregateFields
  nodes: [Message!]!
}

input MessageAggregateBoolExp {
  count: messageAggregateBoolExpCount
}

"""
aggregate fields of "message"
"""
type MessageAggregateFields {
  count(columns: [MessageSelectColumn!], distinct: Boolean): Int!
  max: MessageMaxFields
  min: MessageMinFields
}

"""
order by aggregate values of table "message"
"""
input MessageAggregateOrderBy {
  count: OrderBy
  max: MessageMaxOrderBy
  min: MessageMinOrderBy
}

"""
input type for inserting array relation for remote table "message"
"""
input MessageArrRelInsertInput {
  data: [MessageInsertInput!]!

  """upsert condition"""
  onConflict: MessageOnConflict
}

"""
Boolean expression to filter rows from the table "message". All fields are combined with a logical 'AND'.
"""
input MessageBoolExp {
  _and: [MessageBoolExp!]
  _not: MessageBoolExp
  _or: [MessageBoolExp!]
  content: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  messageId: UuidComparisonExp
  role: StringComparisonExp
  thread: ThreadBoolExp
  threadId: UuidComparisonExp
}

"""
unique or primary key constraints on table "message"
"""
enum MessageConstraint {
  """
  unique or primary key constraint on columns "message_id"
  """
  message_id_key

  """
  unique or primary key constraint on columns "message_id"
  """
  message_pkey
}

"""
input type for inserting data into table "message"
"""
input MessageInsertInput {
  content: String
  createdAt: timestamptz
  messageId: uuid
  role: String
  thread: ThreadObjRelInsertInput
  threadId: uuid
}

"""aggregate max on columns"""
type MessageMaxFields {
  content: String
  createdAt: timestamptz
  messageId: uuid
  role: String
  threadId: uuid
}

"""
order by max() on columns of table "message"
"""
input MessageMaxOrderBy {
  content: OrderBy
  createdAt: OrderBy
  messageId: OrderBy
  role: OrderBy
  threadId: OrderBy
}

"""aggregate min on columns"""
type MessageMinFields {
  content: String
  createdAt: timestamptz
  messageId: uuid
  role: String
  threadId: uuid
}

"""
order by min() on columns of table "message"
"""
input MessageMinOrderBy {
  content: OrderBy
  createdAt: OrderBy
  messageId: OrderBy
  role: OrderBy
  threadId: OrderBy
}

"""
response of any mutation on the table "message"
"""
type MessageMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Message!]!
}

"""
on_conflict condition type for table "message"
"""
input MessageOnConflict {
  constraint: MessageConstraint!
  updateColumns: [MessageUpdateColumn!]! = []
  where: MessageBoolExp
}

"""Ordering options when selecting data from "message"."""
input MessageOrderBy {
  content: OrderBy
  createdAt: OrderBy
  messageId: OrderBy
  role: OrderBy
  thread: ThreadOrderBy
  threadId: OrderBy
}

"""primary key columns input for table: message"""
input MessagePkColumnsInput {
  messageId: uuid!
}

"""
select columns of table "message"
"""
enum MessageSelectColumn {
  """column name"""
  content

  """column name"""
  createdAt

  """column name"""
  messageId

  """column name"""
  role

  """column name"""
  threadId
}

"""
input type for updating data in table "message"
"""
input MessageSetInput {
  content: String
  createdAt: timestamptz
  messageId: uuid
  role: String
  threadId: uuid
}

"""
Streaming cursor of the table "message"
"""
input MessageStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: MessageStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input MessageStreamCursorValueInput {
  content: String
  createdAt: timestamptz
  messageId: uuid
  role: String
  threadId: uuid
}

"""
columns and relationships of "message_type_enum"
"""
type MessageTypeEnum {
  value: String!
}

"""
aggregated selection of "message_type_enum"
"""
type MessageTypeEnumAggregate {
  aggregate: MessageTypeEnumAggregateFields
  nodes: [MessageTypeEnum!]!
}

"""
aggregate fields of "message_type_enum"
"""
type MessageTypeEnumAggregateFields {
  count(columns: [MessageTypeEnumSelectColumn!], distinct: Boolean): Int!
  max: MessageTypeEnumMaxFields
  min: MessageTypeEnumMinFields
}

"""
Boolean expression to filter rows from the table "message_type_enum". All fields are combined with a logical 'AND'.
"""
input MessageTypeEnumBoolExp {
  _and: [MessageTypeEnumBoolExp!]
  _not: MessageTypeEnumBoolExp
  _or: [MessageTypeEnumBoolExp!]
  value: StringComparisonExp
}

"""
unique or primary key constraints on table "message_type_enum"
"""
enum MessageTypeEnumConstraint {
  """
  unique or primary key constraint on columns "value"
  """
  message_type_enum_pkey
}

"""
input type for inserting data into table "message_type_enum"
"""
input MessageTypeEnumInsertInput {
  value: String
}

"""aggregate max on columns"""
type MessageTypeEnumMaxFields {
  value: String
}

"""aggregate min on columns"""
type MessageTypeEnumMinFields {
  value: String
}

"""
response of any mutation on the table "message_type_enum"
"""
type MessageTypeEnumMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [MessageTypeEnum!]!
}

"""
on_conflict condition type for table "message_type_enum"
"""
input MessageTypeEnumOnConflict {
  constraint: MessageTypeEnumConstraint!
  updateColumns: [MessageTypeEnumUpdateColumn!]! = []
  where: MessageTypeEnumBoolExp
}

"""Ordering options when selecting data from "message_type_enum"."""
input MessageTypeEnumOrderBy {
  value: OrderBy
}

"""primary key columns input for table: message_type_enum"""
input MessageTypeEnumPkColumnsInput {
  value: String!
}

"""
select columns of table "message_type_enum"
"""
enum MessageTypeEnumSelectColumn {
  """column name"""
  value
}

"""
input type for updating data in table "message_type_enum"
"""
input MessageTypeEnumSetInput {
  value: String
}

"""
Streaming cursor of the table "message_type_enum"
"""
input MessageTypeEnumStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: MessageTypeEnumStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input MessageTypeEnumStreamCursorValueInput {
  value: String
}

"""
update columns of table "message_type_enum"
"""
enum MessageTypeEnumUpdateColumn {
  """column name"""
  value
}

input MessageTypeEnumUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: MessageTypeEnumSetInput

  """filter the rows which have to be updated"""
  where: MessageTypeEnumBoolExp!
}

"""
update columns of table "message"
"""
enum MessageUpdateColumn {
  """column name"""
  content

  """column name"""
  createdAt

  """column name"""
  messageId

  """column name"""
  role

  """column name"""
  threadId
}

input MessageUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: MessageSetInput

  """filter the rows which have to be updated"""
  where: MessageBoolExp!
}

"""column ordering options"""
enum OrderBy {
  """in ascending order, nulls last"""
  ASC

  """in ascending order, nulls first"""
  ASC_NULLS_FIRST

  """in ascending order, nulls last"""
  ASC_NULLS_LAST

  """in descending order, nulls first"""
  DESC

  """in descending order, nulls first"""
  DESC_NULLS_FIRST

  """in descending order, nulls last"""
  DESC_NULLS_LAST
}

"""
This table stores user-specific preferences for quick access when they interact with a chatbot.
"""
type Preference {
  """An object relationship"""
  chatbot: Chatbot!
  chatbotId: Int!
  favorite: Boolean
  preferenceId: Int!
  preferredComplexity: String!
  preferredLength: String!
  preferredTone: String!
  preferredType: String!
  userId: uuid
}

"""
aggregated selection of "preference"
"""
type PreferenceAggregate {
  aggregate: PreferenceAggregateFields
  nodes: [Preference!]!
}

input PreferenceAggregateBoolExp {
  bool_and: preferenceAggregateBoolExpBool_and
  bool_or: preferenceAggregateBoolExpBool_or
  count: preferenceAggregateBoolExpCount
}

"""
aggregate fields of "preference"
"""
type PreferenceAggregateFields {
  avg: PreferenceAvgFields
  count(columns: [PreferenceSelectColumn!], distinct: Boolean): Int!
  max: PreferenceMaxFields
  min: PreferenceMinFields
  stddev: PreferenceStddevFields
  stddevPop: PreferenceStddevPopFields
  stddevSamp: PreferenceStddevSampFields
  sum: PreferenceSumFields
  varPop: PreferenceVarPopFields
  varSamp: PreferenceVarSampFields
  variance: PreferenceVarianceFields
}

"""
order by aggregate values of table "preference"
"""
input PreferenceAggregateOrderBy {
  avg: PreferenceAvgOrderBy
  count: OrderBy
  max: PreferenceMaxOrderBy
  min: PreferenceMinOrderBy
  stddev: PreferenceStddevOrderBy
  stddevPop: PreferenceStddevPopOrderBy
  stddevSamp: PreferenceStddevSampOrderBy
  sum: PreferenceSumOrderBy
  varPop: PreferenceVarPopOrderBy
  varSamp: PreferenceVarSampOrderBy
  variance: PreferenceVarianceOrderBy
}

"""
input type for inserting array relation for remote table "preference"
"""
input PreferenceArrRelInsertInput {
  data: [PreferenceInsertInput!]!

  """upsert condition"""
  onConflict: PreferenceOnConflict
}

"""aggregate avg on columns"""
type PreferenceAvgFields {
  chatbotId: Float
  preferenceId: Float
}

"""
order by avg() on columns of table "preference"
"""
input PreferenceAvgOrderBy {
  chatbotId: OrderBy
  preferenceId: OrderBy
}

"""
Boolean expression to filter rows from the table "preference". All fields are combined with a logical 'AND'.
"""
input PreferenceBoolExp {
  _and: [PreferenceBoolExp!]
  _not: PreferenceBoolExp
  _or: [PreferenceBoolExp!]
  chatbot: ChatbotBoolExp
  chatbotId: IntComparisonExp
  favorite: BooleanComparisonExp
  preferenceId: IntComparisonExp
  preferredComplexity: StringComparisonExp
  preferredLength: StringComparisonExp
  preferredTone: StringComparisonExp
  preferredType: StringComparisonExp
  userId: UuidComparisonExp
}

"""
unique or primary key constraints on table "preference"
"""
enum PreferenceConstraint {
  """
  unique or primary key constraint on columns "preference_id"
  """
  user_chatbot_preference_pkey
}

"""
input type for incrementing numeric columns in table "preference"
"""
input PreferenceIncInput {
  chatbotId: Int
  preferenceId: Int
}

"""
input type for inserting data into table "preference"
"""
input PreferenceInsertInput {
  chatbot: ChatbotObjRelInsertInput
  chatbotId: Int
  favorite: Boolean
  preferenceId: Int
  preferredComplexity: String
  preferredLength: String
  preferredTone: String
  preferredType: String
  userId: uuid
}

"""aggregate max on columns"""
type PreferenceMaxFields {
  chatbotId: Int
  preferenceId: Int
  preferredComplexity: String
  preferredLength: String
  preferredTone: String
  preferredType: String
  userId: uuid
}

"""
order by max() on columns of table "preference"
"""
input PreferenceMaxOrderBy {
  chatbotId: OrderBy
  preferenceId: OrderBy
  preferredComplexity: OrderBy
  preferredLength: OrderBy
  preferredTone: OrderBy
  preferredType: OrderBy
  userId: OrderBy
}

"""aggregate min on columns"""
type PreferenceMinFields {
  chatbotId: Int
  preferenceId: Int
  preferredComplexity: String
  preferredLength: String
  preferredTone: String
  preferredType: String
  userId: uuid
}

"""
order by min() on columns of table "preference"
"""
input PreferenceMinOrderBy {
  chatbotId: OrderBy
  preferenceId: OrderBy
  preferredComplexity: OrderBy
  preferredLength: OrderBy
  preferredTone: OrderBy
  preferredType: OrderBy
  userId: OrderBy
}

"""
response of any mutation on the table "preference"
"""
type PreferenceMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Preference!]!
}

"""
on_conflict condition type for table "preference"
"""
input PreferenceOnConflict {
  constraint: PreferenceConstraint!
  updateColumns: [PreferenceUpdateColumn!]! = []
  where: PreferenceBoolExp
}

"""Ordering options when selecting data from "preference"."""
input PreferenceOrderBy {
  chatbot: ChatbotOrderBy
  chatbotId: OrderBy
  favorite: OrderBy
  preferenceId: OrderBy
  preferredComplexity: OrderBy
  preferredLength: OrderBy
  preferredTone: OrderBy
  preferredType: OrderBy
  userId: OrderBy
}

"""primary key columns input for table: preference"""
input PreferencePkColumnsInput {
  preferenceId: Int!
}

"""
select columns of table "preference"
"""
enum PreferenceSelectColumn {
  """column name"""
  chatbotId

  """column name"""
  favorite

  """column name"""
  preferenceId

  """column name"""
  preferredComplexity

  """column name"""
  preferredLength

  """column name"""
  preferredTone

  """column name"""
  preferredType

  """column name"""
  userId
}

"""
select "preferenceAggregateBoolExpBool_andArgumentsColumns" columns of table "preference"
"""
enum PreferenceSelectColumnPreferenceAggregateBoolExpBool_andArgumentsColumns {
  """column name"""
  favorite
}

"""
select "preferenceAggregateBoolExpBool_orArgumentsColumns" columns of table "preference"
"""
enum PreferenceSelectColumnPreferenceAggregateBoolExpBool_orArgumentsColumns {
  """column name"""
  favorite
}

"""
input type for updating data in table "preference"
"""
input PreferenceSetInput {
  chatbotId: Int
  favorite: Boolean
  preferenceId: Int
  preferredComplexity: String
  preferredLength: String
  preferredTone: String
  preferredType: String
  userId: uuid
}

"""aggregate stddev on columns"""
type PreferenceStddevFields {
  chatbotId: Float
  preferenceId: Float
}

"""
order by stddev() on columns of table "preference"
"""
input PreferenceStddevOrderBy {
  chatbotId: OrderBy
  preferenceId: OrderBy
}

"""aggregate stddevPop on columns"""
type PreferenceStddevPopFields {
  chatbotId: Float
  preferenceId: Float
}

"""
order by stddevPop() on columns of table "preference"
"""
input PreferenceStddevPopOrderBy {
  chatbotId: OrderBy
  preferenceId: OrderBy
}

"""aggregate stddevSamp on columns"""
type PreferenceStddevSampFields {
  chatbotId: Float
  preferenceId: Float
}

"""
order by stddevSamp() on columns of table "preference"
"""
input PreferenceStddevSampOrderBy {
  chatbotId: OrderBy
  preferenceId: OrderBy
}

"""
Streaming cursor of the table "preference"
"""
input PreferenceStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PreferenceStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PreferenceStreamCursorValueInput {
  chatbotId: Int
  favorite: Boolean
  preferenceId: Int
  preferredComplexity: String
  preferredLength: String
  preferredTone: String
  preferredType: String
  userId: uuid
}

"""aggregate sum on columns"""
type PreferenceSumFields {
  chatbotId: Int
  preferenceId: Int
}

"""
order by sum() on columns of table "preference"
"""
input PreferenceSumOrderBy {
  chatbotId: OrderBy
  preferenceId: OrderBy
}

"""
update columns of table "preference"
"""
enum PreferenceUpdateColumn {
  """column name"""
  chatbotId

  """column name"""
  favorite

  """column name"""
  preferenceId

  """column name"""
  preferredComplexity

  """column name"""
  preferredLength

  """column name"""
  preferredTone

  """column name"""
  preferredType

  """column name"""
  userId
}

input PreferenceUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: PreferenceIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: PreferenceSetInput

  """filter the rows which have to be updated"""
  where: PreferenceBoolExp!
}

"""aggregate varPop on columns"""
type PreferenceVarPopFields {
  chatbotId: Float
  preferenceId: Float
}

"""
order by varPop() on columns of table "preference"
"""
input PreferenceVarPopOrderBy {
  chatbotId: OrderBy
  preferenceId: OrderBy
}

"""aggregate varSamp on columns"""
type PreferenceVarSampFields {
  chatbotId: Float
  preferenceId: Float
}

"""
order by varSamp() on columns of table "preference"
"""
input PreferenceVarSampOrderBy {
  chatbotId: OrderBy
  preferenceId: OrderBy
}

"""aggregate variance on columns"""
type PreferenceVarianceFields {
  chatbotId: Float
  preferenceId: Float
}

"""
order by variance() on columns of table "preference"
"""
input PreferenceVarianceOrderBy {
  chatbotId: OrderBy
  preferenceId: OrderBy
}

"""
columns and relationships of "prompt"
"""
type Prompt {
  """An array relationship"""
  chatbots(
    """distinct select on columns"""
    distinctOn: [PromptChatbotSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptChatbotOrderBy!]

    """filter the rows returned"""
    where: PromptChatbotBoolExp
  ): [PromptChatbot!]!

  """An aggregate relationship"""
  chatbotsAggregate(
    """distinct select on columns"""
    distinctOn: [PromptChatbotSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptChatbotOrderBy!]

    """filter the rows returned"""
    where: PromptChatbotBoolExp
  ): PromptChatbotAggregate!
  content: String!
  promptId: Int!
  promptName: String
  type: String!
}

"""
aggregated selection of "prompt"
"""
type PromptAggregate {
  aggregate: PromptAggregateFields
  nodes: [Prompt!]!
}

input PromptAggregateBoolExp {
  count: promptAggregateBoolExpCount
}

"""
aggregate fields of "prompt"
"""
type PromptAggregateFields {
  avg: PromptAvgFields
  count(columns: [PromptSelectColumn!], distinct: Boolean): Int!
  max: PromptMaxFields
  min: PromptMinFields
  stddev: PromptStddevFields
  stddevPop: PromptStddevPopFields
  stddevSamp: PromptStddevSampFields
  sum: PromptSumFields
  varPop: PromptVarPopFields
  varSamp: PromptVarSampFields
  variance: PromptVarianceFields
}

"""
order by aggregate values of table "prompt"
"""
input PromptAggregateOrderBy {
  avg: PromptAvgOrderBy
  count: OrderBy
  max: PromptMaxOrderBy
  min: PromptMinOrderBy
  stddev: PromptStddevOrderBy
  stddevPop: PromptStddevPopOrderBy
  stddevSamp: PromptStddevSampOrderBy
  sum: PromptSumOrderBy
  varPop: PromptVarPopOrderBy
  varSamp: PromptVarSampOrderBy
  variance: PromptVarianceOrderBy
}

"""
input type for inserting array relation for remote table "prompt"
"""
input PromptArrRelInsertInput {
  data: [PromptInsertInput!]!

  """upsert condition"""
  onConflict: PromptOnConflict
}

"""aggregate avg on columns"""
type PromptAvgFields {
  promptId: Float
}

"""
order by avg() on columns of table "prompt"
"""
input PromptAvgOrderBy {
  promptId: OrderBy
}

"""
Boolean expression to filter rows from the table "prompt". All fields are combined with a logical 'AND'.
"""
input PromptBoolExp {
  _and: [PromptBoolExp!]
  _not: PromptBoolExp
  _or: [PromptBoolExp!]
  chatbots: PromptChatbotBoolExp
  chatbotsAggregate: PromptChatbotAggregateBoolExp
  content: StringComparisonExp
  promptId: IntComparisonExp
  promptName: StringComparisonExp
  type: StringComparisonExp
}

"""Junction table for prompts/instructions and chatbots."""
type PromptChatbot {
  chabotId: Int!

  """An object relationship"""
  chatbot: Chatbot!

  """An object relationship"""
  prompt: Prompt!
  promptId: Int!
}

"""
aggregated selection of "prompt_chatbot"
"""
type PromptChatbotAggregate {
  aggregate: PromptChatbotAggregateFields
  nodes: [PromptChatbot!]!
}

input PromptChatbotAggregateBoolExp {
  count: promptChatbotAggregateBoolExpCount
}

"""
aggregate fields of "prompt_chatbot"
"""
type PromptChatbotAggregateFields {
  avg: PromptChatbotAvgFields
  count(columns: [PromptChatbotSelectColumn!], distinct: Boolean): Int!
  max: PromptChatbotMaxFields
  min: PromptChatbotMinFields
  stddev: PromptChatbotStddevFields
  stddevPop: PromptChatbotStddevPopFields
  stddevSamp: PromptChatbotStddevSampFields
  sum: PromptChatbotSumFields
  varPop: PromptChatbotVarPopFields
  varSamp: PromptChatbotVarSampFields
  variance: PromptChatbotVarianceFields
}

"""
order by aggregate values of table "prompt_chatbot"
"""
input PromptChatbotAggregateOrderBy {
  avg: PromptChatbotAvgOrderBy
  count: OrderBy
  max: PromptChatbotMaxOrderBy
  min: PromptChatbotMinOrderBy
  stddev: PromptChatbotStddevOrderBy
  stddevPop: PromptChatbotStddevPopOrderBy
  stddevSamp: PromptChatbotStddevSampOrderBy
  sum: PromptChatbotSumOrderBy
  varPop: PromptChatbotVarPopOrderBy
  varSamp: PromptChatbotVarSampOrderBy
  variance: PromptChatbotVarianceOrderBy
}

"""
input type for inserting array relation for remote table "prompt_chatbot"
"""
input PromptChatbotArrRelInsertInput {
  data: [PromptChatbotInsertInput!]!

  """upsert condition"""
  onConflict: PromptChatbotOnConflict
}

"""aggregate avg on columns"""
type PromptChatbotAvgFields {
  chabotId: Float
  promptId: Float
}

"""
order by avg() on columns of table "prompt_chatbot"
"""
input PromptChatbotAvgOrderBy {
  chabotId: OrderBy
  promptId: OrderBy
}

"""
Boolean expression to filter rows from the table "prompt_chatbot". All fields are combined with a logical 'AND'.
"""
input PromptChatbotBoolExp {
  _and: [PromptChatbotBoolExp!]
  _not: PromptChatbotBoolExp
  _or: [PromptChatbotBoolExp!]
  chabotId: IntComparisonExp
  chatbot: ChatbotBoolExp
  prompt: PromptBoolExp
  promptId: IntComparisonExp
}

"""
unique or primary key constraints on table "prompt_chatbot"
"""
enum PromptChatbotConstraint {
  """
  unique or primary key constraint on columns "chabot_id", "prompt_id"
  """
  prompt_chatbot_pkey
}

"""
input type for incrementing numeric columns in table "prompt_chatbot"
"""
input PromptChatbotIncInput {
  chabotId: Int
  promptId: Int
}

"""
input type for inserting data into table "prompt_chatbot"
"""
input PromptChatbotInsertInput {
  chabotId: Int
  chatbot: ChatbotObjRelInsertInput
  prompt: PromptObjRelInsertInput
  promptId: Int
}

"""aggregate max on columns"""
type PromptChatbotMaxFields {
  chabotId: Int
  promptId: Int
}

"""
order by max() on columns of table "prompt_chatbot"
"""
input PromptChatbotMaxOrderBy {
  chabotId: OrderBy
  promptId: OrderBy
}

"""aggregate min on columns"""
type PromptChatbotMinFields {
  chabotId: Int
  promptId: Int
}

"""
order by min() on columns of table "prompt_chatbot"
"""
input PromptChatbotMinOrderBy {
  chabotId: OrderBy
  promptId: OrderBy
}

"""
response of any mutation on the table "prompt_chatbot"
"""
type PromptChatbotMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [PromptChatbot!]!
}

"""
on_conflict condition type for table "prompt_chatbot"
"""
input PromptChatbotOnConflict {
  constraint: PromptChatbotConstraint!
  updateColumns: [PromptChatbotUpdateColumn!]! = []
  where: PromptChatbotBoolExp
}

"""Ordering options when selecting data from "prompt_chatbot"."""
input PromptChatbotOrderBy {
  chabotId: OrderBy
  chatbot: ChatbotOrderBy
  prompt: PromptOrderBy
  promptId: OrderBy
}

"""primary key columns input for table: prompt_chatbot"""
input PromptChatbotPkColumnsInput {
  chabotId: Int!
  promptId: Int!
}

"""
select columns of table "prompt_chatbot"
"""
enum PromptChatbotSelectColumn {
  """column name"""
  chabotId

  """column name"""
  promptId
}

"""
input type for updating data in table "prompt_chatbot"
"""
input PromptChatbotSetInput {
  chabotId: Int
  promptId: Int
}

"""aggregate stddev on columns"""
type PromptChatbotStddevFields {
  chabotId: Float
  promptId: Float
}

"""
order by stddev() on columns of table "prompt_chatbot"
"""
input PromptChatbotStddevOrderBy {
  chabotId: OrderBy
  promptId: OrderBy
}

"""aggregate stddevPop on columns"""
type PromptChatbotStddevPopFields {
  chabotId: Float
  promptId: Float
}

"""
order by stddevPop() on columns of table "prompt_chatbot"
"""
input PromptChatbotStddevPopOrderBy {
  chabotId: OrderBy
  promptId: OrderBy
}

"""aggregate stddevSamp on columns"""
type PromptChatbotStddevSampFields {
  chabotId: Float
  promptId: Float
}

"""
order by stddevSamp() on columns of table "prompt_chatbot"
"""
input PromptChatbotStddevSampOrderBy {
  chabotId: OrderBy
  promptId: OrderBy
}

"""
Streaming cursor of the table "prompt_chatbot"
"""
input PromptChatbotStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PromptChatbotStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PromptChatbotStreamCursorValueInput {
  chabotId: Int
  promptId: Int
}

"""aggregate sum on columns"""
type PromptChatbotSumFields {
  chabotId: Int
  promptId: Int
}

"""
order by sum() on columns of table "prompt_chatbot"
"""
input PromptChatbotSumOrderBy {
  chabotId: OrderBy
  promptId: OrderBy
}

"""
update columns of table "prompt_chatbot"
"""
enum PromptChatbotUpdateColumn {
  """column name"""
  chabotId

  """column name"""
  promptId
}

input PromptChatbotUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: PromptChatbotIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: PromptChatbotSetInput

  """filter the rows which have to be updated"""
  where: PromptChatbotBoolExp!
}

"""aggregate varPop on columns"""
type PromptChatbotVarPopFields {
  chabotId: Float
  promptId: Float
}

"""
order by varPop() on columns of table "prompt_chatbot"
"""
input PromptChatbotVarPopOrderBy {
  chabotId: OrderBy
  promptId: OrderBy
}

"""aggregate varSamp on columns"""
type PromptChatbotVarSampFields {
  chabotId: Float
  promptId: Float
}

"""
order by varSamp() on columns of table "prompt_chatbot"
"""
input PromptChatbotVarSampOrderBy {
  chabotId: OrderBy
  promptId: OrderBy
}

"""aggregate variance on columns"""
type PromptChatbotVarianceFields {
  chabotId: Float
  promptId: Float
}

"""
order by variance() on columns of table "prompt_chatbot"
"""
input PromptChatbotVarianceOrderBy {
  chabotId: OrderBy
  promptId: OrderBy
}

"""
unique or primary key constraints on table "prompt"
"""
enum PromptConstraint {
  """
  unique or primary key constraint on columns "prompt_id"
  """
  prompt_pkey

  """
  unique or primary key constraint on columns "prompt_id"
  """
  prompt_prompt_id_key
}

"""
input type for incrementing numeric columns in table "prompt"
"""
input PromptIncInput {
  promptId: Int
}

"""
input type for inserting data into table "prompt"
"""
input PromptInsertInput {
  chatbots: PromptChatbotArrRelInsertInput
  content: String
  promptId: Int
  promptName: String
  type: String
}

"""aggregate max on columns"""
type PromptMaxFields {
  content: String
  promptId: Int
  promptName: String
  type: String
}

"""
order by max() on columns of table "prompt"
"""
input PromptMaxOrderBy {
  content: OrderBy
  promptId: OrderBy
  promptName: OrderBy
  type: OrderBy
}

"""aggregate min on columns"""
type PromptMinFields {
  content: String
  promptId: Int
  promptName: String
  type: String
}

"""
order by min() on columns of table "prompt"
"""
input PromptMinOrderBy {
  content: OrderBy
  promptId: OrderBy
  promptName: OrderBy
  type: OrderBy
}

"""
response of any mutation on the table "prompt"
"""
type PromptMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Prompt!]!
}

"""
input type for inserting object relation for remote table "prompt"
"""
input PromptObjRelInsertInput {
  data: PromptInsertInput!

  """upsert condition"""
  onConflict: PromptOnConflict
}

"""
on_conflict condition type for table "prompt"
"""
input PromptOnConflict {
  constraint: PromptConstraint!
  updateColumns: [PromptUpdateColumn!]! = []
  where: PromptBoolExp
}

"""Ordering options when selecting data from "prompt"."""
input PromptOrderBy {
  chatbotsAggregate: PromptChatbotAggregateOrderBy
  content: OrderBy
  promptId: OrderBy
  promptName: OrderBy
  type: OrderBy
}

"""primary key columns input for table: prompt"""
input PromptPkColumnsInput {
  promptId: Int!
}

"""
select columns of table "prompt"
"""
enum PromptSelectColumn {
  """column name"""
  content

  """column name"""
  promptId

  """column name"""
  promptName

  """column name"""
  type
}

"""
input type for updating data in table "prompt"
"""
input PromptSetInput {
  content: String
  promptId: Int
  promptName: String
  type: String
}

"""aggregate stddev on columns"""
type PromptStddevFields {
  promptId: Float
}

"""
order by stddev() on columns of table "prompt"
"""
input PromptStddevOrderBy {
  promptId: OrderBy
}

"""aggregate stddevPop on columns"""
type PromptStddevPopFields {
  promptId: Float
}

"""
order by stddevPop() on columns of table "prompt"
"""
input PromptStddevPopOrderBy {
  promptId: OrderBy
}

"""aggregate stddevSamp on columns"""
type PromptStddevSampFields {
  promptId: Float
}

"""
order by stddevSamp() on columns of table "prompt"
"""
input PromptStddevSampOrderBy {
  promptId: OrderBy
}

"""
Streaming cursor of the table "prompt"
"""
input PromptStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PromptStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PromptStreamCursorValueInput {
  content: String
  promptId: Int
  promptName: String
  type: String
}

"""aggregate sum on columns"""
type PromptSumFields {
  promptId: Int
}

"""
order by sum() on columns of table "prompt"
"""
input PromptSumOrderBy {
  promptId: OrderBy
}

"""
columns and relationships of "prompt_type_enum"
"""
type PromptTypeEnum {
  """An array relationship"""
  prompts(
    """distinct select on columns"""
    distinctOn: [PromptSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptOrderBy!]

    """filter the rows returned"""
    where: PromptBoolExp
  ): [Prompt!]!

  """An aggregate relationship"""
  promptsAggregate(
    """distinct select on columns"""
    distinctOn: [PromptSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptOrderBy!]

    """filter the rows returned"""
    where: PromptBoolExp
  ): PromptAggregate!
  value: String!
}

"""
aggregated selection of "prompt_type_enum"
"""
type PromptTypeEnumAggregate {
  aggregate: PromptTypeEnumAggregateFields
  nodes: [PromptTypeEnum!]!
}

"""
aggregate fields of "prompt_type_enum"
"""
type PromptTypeEnumAggregateFields {
  count(columns: [PromptTypeEnumSelectColumn!], distinct: Boolean): Int!
  max: PromptTypeEnumMaxFields
  min: PromptTypeEnumMinFields
}

"""
Boolean expression to filter rows from the table "prompt_type_enum". All fields are combined with a logical 'AND'.
"""
input PromptTypeEnumBoolExp {
  _and: [PromptTypeEnumBoolExp!]
  _not: PromptTypeEnumBoolExp
  _or: [PromptTypeEnumBoolExp!]
  prompts: PromptBoolExp
  promptsAggregate: PromptAggregateBoolExp
  value: StringComparisonExp
}

"""
unique or primary key constraints on table "prompt_type_enum"
"""
enum PromptTypeEnumConstraint {
  """
  unique or primary key constraint on columns "value"
  """
  type_enum_pkey
}

"""
input type for inserting data into table "prompt_type_enum"
"""
input PromptTypeEnumInsertInput {
  prompts: PromptArrRelInsertInput
  value: String
}

"""aggregate max on columns"""
type PromptTypeEnumMaxFields {
  value: String
}

"""aggregate min on columns"""
type PromptTypeEnumMinFields {
  value: String
}

"""
response of any mutation on the table "prompt_type_enum"
"""
type PromptTypeEnumMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [PromptTypeEnum!]!
}

"""
on_conflict condition type for table "prompt_type_enum"
"""
input PromptTypeEnumOnConflict {
  constraint: PromptTypeEnumConstraint!
  updateColumns: [PromptTypeEnumUpdateColumn!]! = []
  where: PromptTypeEnumBoolExp
}

"""Ordering options when selecting data from "prompt_type_enum"."""
input PromptTypeEnumOrderBy {
  promptsAggregate: PromptAggregateOrderBy
  value: OrderBy
}

"""primary key columns input for table: prompt_type_enum"""
input PromptTypeEnumPkColumnsInput {
  value: String!
}

"""
select columns of table "prompt_type_enum"
"""
enum PromptTypeEnumSelectColumn {
  """column name"""
  value
}

"""
input type for updating data in table "prompt_type_enum"
"""
input PromptTypeEnumSetInput {
  value: String
}

"""
Streaming cursor of the table "prompt_type_enum"
"""
input PromptTypeEnumStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PromptTypeEnumStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PromptTypeEnumStreamCursorValueInput {
  value: String
}

"""
update columns of table "prompt_type_enum"
"""
enum PromptTypeEnumUpdateColumn {
  """column name"""
  value
}

input PromptTypeEnumUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: PromptTypeEnumSetInput

  """filter the rows which have to be updated"""
  where: PromptTypeEnumBoolExp!
}

"""
update columns of table "prompt"
"""
enum PromptUpdateColumn {
  """column name"""
  content

  """column name"""
  promptId

  """column name"""
  promptName

  """column name"""
  type
}

input PromptUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: PromptIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: PromptSetInput

  """filter the rows which have to be updated"""
  where: PromptBoolExp!
}

"""aggregate varPop on columns"""
type PromptVarPopFields {
  promptId: Float
}

"""
order by varPop() on columns of table "prompt"
"""
input PromptVarPopOrderBy {
  promptId: OrderBy
}

"""aggregate varSamp on columns"""
type PromptVarSampFields {
  promptId: Float
}

"""
order by varSamp() on columns of table "prompt"
"""
input PromptVarSampOrderBy {
  promptId: OrderBy
}

"""aggregate variance on columns"""
type PromptVarianceFields {
  promptId: Float
}

"""
order by variance() on columns of table "prompt"
"""
input PromptVarianceOrderBy {
  promptId: OrderBy
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input StringComparisonExp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _isNull: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

"""
columns and relationships of "thread"
"""
type Thread {
  """An object relationship"""
  chatbot: Chatbot!
  chatbotId: Int!
  createdAt: timestamptz!

  """An array relationship"""
  messages(
    """distinct select on columns"""
    distinctOn: [MessageSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MessageOrderBy!]

    """filter the rows returned"""
    where: MessageBoolExp
  ): [Message!]!

  """An aggregate relationship"""
  messagesAggregate(
    """distinct select on columns"""
    distinctOn: [MessageSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MessageOrderBy!]

    """filter the rows returned"""
    where: MessageBoolExp
  ): MessageAggregate!
  threadId: uuid!
  updatedAt: timestamptz!

  """An object relationship"""
  user: User
  userId: uuid
}

"""
aggregated selection of "thread"
"""
type ThreadAggregate {
  aggregate: ThreadAggregateFields
  nodes: [Thread!]!
}

input ThreadAggregateBoolExp {
  count: threadAggregateBoolExpCount
}

"""
aggregate fields of "thread"
"""
type ThreadAggregateFields {
  avg: ThreadAvgFields
  count(columns: [ThreadSelectColumn!], distinct: Boolean): Int!
  max: ThreadMaxFields
  min: ThreadMinFields
  stddev: ThreadStddevFields
  stddevPop: ThreadStddevPopFields
  stddevSamp: ThreadStddevSampFields
  sum: ThreadSumFields
  varPop: ThreadVarPopFields
  varSamp: ThreadVarSampFields
  variance: ThreadVarianceFields
}

"""
order by aggregate values of table "thread"
"""
input ThreadAggregateOrderBy {
  avg: ThreadAvgOrderBy
  count: OrderBy
  max: ThreadMaxOrderBy
  min: ThreadMinOrderBy
  stddev: ThreadStddevOrderBy
  stddevPop: ThreadStddevPopOrderBy
  stddevSamp: ThreadStddevSampOrderBy
  sum: ThreadSumOrderBy
  varPop: ThreadVarPopOrderBy
  varSamp: ThreadVarSampOrderBy
  variance: ThreadVarianceOrderBy
}

"""
input type for inserting array relation for remote table "thread"
"""
input ThreadArrRelInsertInput {
  data: [ThreadInsertInput!]!

  """upsert condition"""
  onConflict: ThreadOnConflict
}

"""aggregate avg on columns"""
type ThreadAvgFields {
  chatbotId: Float
}

"""
order by avg() on columns of table "thread"
"""
input ThreadAvgOrderBy {
  chatbotId: OrderBy
}

"""
Boolean expression to filter rows from the table "thread". All fields are combined with a logical 'AND'.
"""
input ThreadBoolExp {
  _and: [ThreadBoolExp!]
  _not: ThreadBoolExp
  _or: [ThreadBoolExp!]
  chatbot: ChatbotBoolExp
  chatbotId: IntComparisonExp
  createdAt: TimestamptzComparisonExp
  messages: MessageBoolExp
  messagesAggregate: MessageAggregateBoolExp
  threadId: UuidComparisonExp
  updatedAt: TimestamptzComparisonExp
  user: UserBoolExp
  userId: UuidComparisonExp
}

"""
unique or primary key constraints on table "thread"
"""
enum ThreadConstraint {
  """
  unique or primary key constraint on columns "thread_id"
  """
  thread_id_key

  """
  unique or primary key constraint on columns "thread_id"
  """
  thread_pkey
}

"""
input type for incrementing numeric columns in table "thread"
"""
input ThreadIncInput {
  chatbotId: Int
}

"""
input type for inserting data into table "thread"
"""
input ThreadInsertInput {
  chatbot: ChatbotObjRelInsertInput
  chatbotId: Int
  createdAt: timestamptz
  messages: MessageArrRelInsertInput
  threadId: uuid
  updatedAt: timestamptz
  user: UserObjRelInsertInput
  userId: uuid
}

"""aggregate max on columns"""
type ThreadMaxFields {
  chatbotId: Int
  createdAt: timestamptz
  threadId: uuid
  updatedAt: timestamptz
  userId: uuid
}

"""
order by max() on columns of table "thread"
"""
input ThreadMaxOrderBy {
  chatbotId: OrderBy
  createdAt: OrderBy
  threadId: OrderBy
  updatedAt: OrderBy
  userId: OrderBy
}

"""aggregate min on columns"""
type ThreadMinFields {
  chatbotId: Int
  createdAt: timestamptz
  threadId: uuid
  updatedAt: timestamptz
  userId: uuid
}

"""
order by min() on columns of table "thread"
"""
input ThreadMinOrderBy {
  chatbotId: OrderBy
  createdAt: OrderBy
  threadId: OrderBy
  updatedAt: OrderBy
  userId: OrderBy
}

"""
response of any mutation on the table "thread"
"""
type ThreadMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Thread!]!
}

"""
input type for inserting object relation for remote table "thread"
"""
input ThreadObjRelInsertInput {
  data: ThreadInsertInput!

  """upsert condition"""
  onConflict: ThreadOnConflict
}

"""
on_conflict condition type for table "thread"
"""
input ThreadOnConflict {
  constraint: ThreadConstraint!
  updateColumns: [ThreadUpdateColumn!]! = []
  where: ThreadBoolExp
}

"""Ordering options when selecting data from "thread"."""
input ThreadOrderBy {
  chatbot: ChatbotOrderBy
  chatbotId: OrderBy
  createdAt: OrderBy
  messagesAggregate: MessageAggregateOrderBy
  threadId: OrderBy
  updatedAt: OrderBy
  user: UserOrderBy
  userId: OrderBy
}

"""primary key columns input for table: thread"""
input ThreadPkColumnsInput {
  threadId: uuid!
}

"""
select columns of table "thread"
"""
enum ThreadSelectColumn {
  """column name"""
  chatbotId

  """column name"""
  createdAt

  """column name"""
  threadId

  """column name"""
  updatedAt

  """column name"""
  userId
}

"""
input type for updating data in table "thread"
"""
input ThreadSetInput {
  chatbotId: Int
  createdAt: timestamptz
  threadId: uuid
  updatedAt: timestamptz
  userId: uuid
}

"""aggregate stddev on columns"""
type ThreadStddevFields {
  chatbotId: Float
}

"""
order by stddev() on columns of table "thread"
"""
input ThreadStddevOrderBy {
  chatbotId: OrderBy
}

"""aggregate stddevPop on columns"""
type ThreadStddevPopFields {
  chatbotId: Float
}

"""
order by stddevPop() on columns of table "thread"
"""
input ThreadStddevPopOrderBy {
  chatbotId: OrderBy
}

"""aggregate stddevSamp on columns"""
type ThreadStddevSampFields {
  chatbotId: Float
}

"""
order by stddevSamp() on columns of table "thread"
"""
input ThreadStddevSampOrderBy {
  chatbotId: OrderBy
}

"""
Streaming cursor of the table "thread"
"""
input ThreadStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ThreadStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ThreadStreamCursorValueInput {
  chatbotId: Int
  createdAt: timestamptz
  threadId: uuid
  updatedAt: timestamptz
  userId: uuid
}

"""aggregate sum on columns"""
type ThreadSumFields {
  chatbotId: Int
}

"""
order by sum() on columns of table "thread"
"""
input ThreadSumOrderBy {
  chatbotId: OrderBy
}

"""
update columns of table "thread"
"""
enum ThreadUpdateColumn {
  """column name"""
  chatbotId

  """column name"""
  createdAt

  """column name"""
  threadId

  """column name"""
  updatedAt

  """column name"""
  userId
}

input ThreadUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: ThreadIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: ThreadSetInput

  """filter the rows which have to be updated"""
  where: ThreadBoolExp!
}

"""aggregate varPop on columns"""
type ThreadVarPopFields {
  chatbotId: Float
}

"""
order by varPop() on columns of table "thread"
"""
input ThreadVarPopOrderBy {
  chatbotId: OrderBy
}

"""aggregate varSamp on columns"""
type ThreadVarSampFields {
  chatbotId: Float
}

"""
order by varSamp() on columns of table "thread"
"""
input ThreadVarSampOrderBy {
  chatbotId: OrderBy
}

"""aggregate variance on columns"""
type ThreadVarianceFields {
  chatbotId: Float
}

"""
order by variance() on columns of table "thread"
"""
input ThreadVarianceOrderBy {
  chatbotId: OrderBy
}

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input TimestamptzComparisonExp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _isNull: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""
columns and relationships of "tone_enum"
"""
type ToneEnum {
  value: String!
}

"""
aggregated selection of "tone_enum"
"""
type ToneEnumAggregate {
  aggregate: ToneEnumAggregateFields
  nodes: [ToneEnum!]!
}

"""
aggregate fields of "tone_enum"
"""
type ToneEnumAggregateFields {
  count(columns: [ToneEnumSelectColumn!], distinct: Boolean): Int!
  max: ToneEnumMaxFields
  min: ToneEnumMinFields
}

"""
Boolean expression to filter rows from the table "tone_enum". All fields are combined with a logical 'AND'.
"""
input ToneEnumBoolExp {
  _and: [ToneEnumBoolExp!]
  _not: ToneEnumBoolExp
  _or: [ToneEnumBoolExp!]
  value: StringComparisonExp
}

"""
unique or primary key constraints on table "tone_enum"
"""
enum ToneEnumConstraint {
  """
  unique or primary key constraint on columns "value"
  """
  default_tone_enum_pkey
}

"""
input type for inserting data into table "tone_enum"
"""
input ToneEnumInsertInput {
  value: String
}

"""aggregate max on columns"""
type ToneEnumMaxFields {
  value: String
}

"""aggregate min on columns"""
type ToneEnumMinFields {
  value: String
}

"""
response of any mutation on the table "tone_enum"
"""
type ToneEnumMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [ToneEnum!]!
}

"""
on_conflict condition type for table "tone_enum"
"""
input ToneEnumOnConflict {
  constraint: ToneEnumConstraint!
  updateColumns: [ToneEnumUpdateColumn!]! = []
  where: ToneEnumBoolExp
}

"""Ordering options when selecting data from "tone_enum"."""
input ToneEnumOrderBy {
  value: OrderBy
}

"""primary key columns input for table: tone_enum"""
input ToneEnumPkColumnsInput {
  value: String!
}

"""
select columns of table "tone_enum"
"""
enum ToneEnumSelectColumn {
  """column name"""
  value
}

"""
input type for updating data in table "tone_enum"
"""
input ToneEnumSetInput {
  value: String
}

"""
Streaming cursor of the table "tone_enum"
"""
input ToneEnumStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ToneEnumStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ToneEnumStreamCursorValueInput {
  value: String
}

"""
update columns of table "tone_enum"
"""
enum ToneEnumUpdateColumn {
  """column name"""
  value
}

input ToneEnumUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: ToneEnumSetInput

  """filter the rows which have to be updated"""
  where: ToneEnumBoolExp!
}

"""
columns and relationships of "type_enum"
"""
type TypeEnum {
  value: String!
}

"""
aggregated selection of "type_enum"
"""
type TypeEnumAggregate {
  aggregate: TypeEnumAggregateFields
  nodes: [TypeEnum!]!
}

"""
aggregate fields of "type_enum"
"""
type TypeEnumAggregateFields {
  count(columns: [TypeEnumSelectColumn!], distinct: Boolean): Int!
  max: TypeEnumMaxFields
  min: TypeEnumMinFields
}

"""
Boolean expression to filter rows from the table "type_enum". All fields are combined with a logical 'AND'.
"""
input TypeEnumBoolExp {
  _and: [TypeEnumBoolExp!]
  _not: TypeEnumBoolExp
  _or: [TypeEnumBoolExp!]
  value: StringComparisonExp
}

"""
unique or primary key constraints on table "type_enum"
"""
enum TypeEnumConstraint {
  """
  unique or primary key constraint on columns "value"
  """
  default_type_enum_pkey
}

"""
input type for inserting data into table "type_enum"
"""
input TypeEnumInsertInput {
  value: String
}

"""aggregate max on columns"""
type TypeEnumMaxFields {
  value: String
}

"""aggregate min on columns"""
type TypeEnumMinFields {
  value: String
}

"""
response of any mutation on the table "type_enum"
"""
type TypeEnumMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [TypeEnum!]!
}

"""
on_conflict condition type for table "type_enum"
"""
input TypeEnumOnConflict {
  constraint: TypeEnumConstraint!
  updateColumns: [TypeEnumUpdateColumn!]! = []
  where: TypeEnumBoolExp
}

"""Ordering options when selecting data from "type_enum"."""
input TypeEnumOrderBy {
  value: OrderBy
}

"""primary key columns input for table: type_enum"""
input TypeEnumPkColumnsInput {
  value: String!
}

"""
select columns of table "type_enum"
"""
enum TypeEnumSelectColumn {
  """column name"""
  value
}

"""
input type for updating data in table "type_enum"
"""
input TypeEnumSetInput {
  value: String
}

"""
Streaming cursor of the table "type_enum"
"""
input TypeEnumStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: TypeEnumStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input TypeEnumStreamCursorValueInput {
  value: String
}

"""
update columns of table "type_enum"
"""
enum TypeEnumUpdateColumn {
  """column name"""
  value
}

input TypeEnumUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: TypeEnumSetInput

  """filter the rows which have to be updated"""
  where: TypeEnumBoolExp!
}

"""Table storing information about registered users."""
type User {
  """An array relationship"""
  chats(
    """distinct select on columns"""
    distinctOn: [ChatSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatOrderBy!]

    """filter the rows returned"""
    where: ChatBoolExp
  ): [Chat!]!

  """An aggregate relationship"""
  chatsAggregate(
    """distinct select on columns"""
    distinctOn: [ChatSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatOrderBy!]

    """filter the rows returned"""
    where: ChatBoolExp
  ): ChatAggregate!
  dateJoined: timestamptz!
  email: String!
  lastLogin: timestamptz
  password: String!

  """An array relationship"""
  preferences(
    """distinct select on columns"""
    distinctOn: [PreferenceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PreferenceOrderBy!]

    """filter the rows returned"""
    where: PreferenceBoolExp
  ): [Preference!]!

  """An aggregate relationship"""
  preferencesAggregate(
    """distinct select on columns"""
    distinctOn: [PreferenceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PreferenceOrderBy!]

    """filter the rows returned"""
    where: PreferenceBoolExp
  ): PreferenceAggregate!
  profilePicture: String

  """An array relationship"""
  threads(
    """distinct select on columns"""
    distinctOn: [ThreadSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ThreadOrderBy!]

    """filter the rows returned"""
    where: ThreadBoolExp
  ): [Thread!]!

  """An aggregate relationship"""
  threadsAggregate(
    """distinct select on columns"""
    distinctOn: [ThreadSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ThreadOrderBy!]

    """filter the rows returned"""
    where: ThreadBoolExp
  ): ThreadAggregate!
  userId: uuid!
  username: String!
}

"""
aggregated selection of "user"
"""
type UserAggregate {
  aggregate: UserAggregateFields
  nodes: [User!]!
}

"""
aggregate fields of "user"
"""
type UserAggregateFields {
  count(columns: [UserSelectColumn!], distinct: Boolean): Int!
  max: UserMaxFields
  min: UserMinFields
}

"""
Boolean expression to filter rows from the table "user". All fields are combined with a logical 'AND'.
"""
input UserBoolExp {
  _and: [UserBoolExp!]
  _not: UserBoolExp
  _or: [UserBoolExp!]
  chats: ChatBoolExp
  chatsAggregate: ChatAggregateBoolExp
  dateJoined: TimestamptzComparisonExp
  email: StringComparisonExp
  lastLogin: TimestamptzComparisonExp
  password: StringComparisonExp
  preferences: PreferenceBoolExp
  preferencesAggregate: PreferenceAggregateBoolExp
  profilePicture: StringComparisonExp
  threads: ThreadBoolExp
  threadsAggregate: ThreadAggregateBoolExp
  userId: UuidComparisonExp
  username: StringComparisonExp
}

"""
unique or primary key constraints on table "user"
"""
enum UserConstraint {
  """
  unique or primary key constraint on columns "email"
  """
  user_email_key

  """
  unique or primary key constraint on columns "user_id"
  """
  user_pkey

  """
  unique or primary key constraint on columns "username"
  """
  user_username_key
}

"""
input type for inserting data into table "user"
"""
input UserInsertInput {
  chats: ChatArrRelInsertInput
  dateJoined: timestamptz
  email: String
  lastLogin: timestamptz
  password: String
  preferences: PreferenceArrRelInsertInput
  profilePicture: String
  threads: ThreadArrRelInsertInput
  userId: uuid
  username: String
}

"""aggregate max on columns"""
type UserMaxFields {
  dateJoined: timestamptz
  email: String
  lastLogin: timestamptz
  password: String
  profilePicture: String
  userId: uuid
  username: String
}

"""aggregate min on columns"""
type UserMinFields {
  dateJoined: timestamptz
  email: String
  lastLogin: timestamptz
  password: String
  profilePicture: String
  userId: uuid
  username: String
}

"""
response of any mutation on the table "user"
"""
type UserMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [User!]!
}

"""
input type for inserting object relation for remote table "user"
"""
input UserObjRelInsertInput {
  data: UserInsertInput!

  """upsert condition"""
  onConflict: UserOnConflict
}

"""
on_conflict condition type for table "user"
"""
input UserOnConflict {
  constraint: UserConstraint!
  updateColumns: [UserUpdateColumn!]! = []
  where: UserBoolExp
}

"""Ordering options when selecting data from "user"."""
input UserOrderBy {
  chatsAggregate: ChatAggregateOrderBy
  dateJoined: OrderBy
  email: OrderBy
  lastLogin: OrderBy
  password: OrderBy
  preferencesAggregate: PreferenceAggregateOrderBy
  profilePicture: OrderBy
  threadsAggregate: ThreadAggregateOrderBy
  userId: OrderBy
  username: OrderBy
}

"""primary key columns input for table: user"""
input UserPkColumnsInput {
  userId: uuid!
}

"""
select columns of table "user"
"""
enum UserSelectColumn {
  """column name"""
  dateJoined

  """column name"""
  email

  """column name"""
  lastLogin

  """column name"""
  password

  """column name"""
  profilePicture

  """column name"""
  userId

  """column name"""
  username
}

"""
input type for updating data in table "user"
"""
input UserSetInput {
  dateJoined: timestamptz
  email: String
  lastLogin: timestamptz
  password: String
  profilePicture: String
  userId: uuid
  username: String
}

"""
Streaming cursor of the table "user"
"""
input UserStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: UserStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input UserStreamCursorValueInput {
  dateJoined: timestamptz
  email: String
  lastLogin: timestamptz
  password: String
  profilePicture: String
  userId: uuid
  username: String
}

"""
update columns of table "user"
"""
enum UserUpdateColumn {
  """column name"""
  dateJoined

  """column name"""
  email

  """column name"""
  lastLogin

  """column name"""
  password

  """column name"""
  profilePicture

  """column name"""
  userId

  """column name"""
  username
}

input UserUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: UserSetInput

  """filter the rows which have to be updated"""
  where: UserBoolExp!
}

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input UuidComparisonExp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _isNull: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

input chatAggregateBoolExpCount {
  arguments: [ChatSelectColumn!]
  distinct: Boolean
  filter: ChatBoolExp
  predicate: IntComparisonExp!
}

input chatbotCategoryAggregateBoolExpCount {
  arguments: [ChatbotCategorySelectColumn!]
  distinct: Boolean
  filter: ChatbotCategoryBoolExp
  predicate: IntComparisonExp!
}

input messageAggregateBoolExpCount {
  arguments: [MessageSelectColumn!]
  distinct: Boolean
  filter: MessageBoolExp
  predicate: IntComparisonExp!
}

"""mutation root"""
type mutation_root {
  """
  delete data from the table: "category"
  """
  deleteCategory(
    """filter the rows which have to be deleted"""
    where: CategoryBoolExp!
  ): CategoryMutationResponse

  """
  delete single row from the table: "category"
  """
  deleteCategoryByPk(categoryId: Int!): Category

  """
  delete data from the table: "chat"
  """
  deleteChat(
    """filter the rows which have to be deleted"""
    where: ChatBoolExp!
  ): ChatMutationResponse

  """
  delete single row from the table: "chat"
  """
  deleteChatByPk(chatId: Int!): Chat

  """
  delete data from the table: "chatbot"
  """
  deleteChatbot(
    """filter the rows which have to be deleted"""
    where: ChatbotBoolExp!
  ): ChatbotMutationResponse

  """
  delete single row from the table: "chatbot"
  """
  deleteChatbotByPk(chatbotId: Int!): Chatbot

  """
  delete data from the table: "chatbot_category"
  """
  deleteChatbotCategory(
    """filter the rows which have to be deleted"""
    where: ChatbotCategoryBoolExp!
  ): ChatbotCategoryMutationResponse

  """
  delete single row from the table: "chatbot_category"
  """
  deleteChatbotCategoryByPk(categoryId: Int!, chatbotId: Int!): ChatbotCategory

  """
  delete data from the table: "complexity_enum"
  """
  deleteComplexityEnum(
    """filter the rows which have to be deleted"""
    where: ComplexityEnumBoolExp!
  ): ComplexityEnumMutationResponse

  """
  delete single row from the table: "complexity_enum"
  """
  deleteComplexityEnumByPk(value: String!): ComplexityEnum

  """
  delete data from the table: "length_enum"
  """
  deleteLengthEnum(
    """filter the rows which have to be deleted"""
    where: LengthEnumBoolExp!
  ): LengthEnumMutationResponse

  """
  delete single row from the table: "length_enum"
  """
  deleteLengthEnumByPk(value: String!): LengthEnum

  """
  delete data from the table: "message"
  """
  deleteMessage(
    """filter the rows which have to be deleted"""
    where: MessageBoolExp!
  ): MessageMutationResponse

  """
  delete single row from the table: "message"
  """
  deleteMessageByPk(messageId: uuid!): Message

  """
  delete data from the table: "message_type_enum"
  """
  deleteMessageTypeEnum(
    """filter the rows which have to be deleted"""
    where: MessageTypeEnumBoolExp!
  ): MessageTypeEnumMutationResponse

  """
  delete single row from the table: "message_type_enum"
  """
  deleteMessageTypeEnumByPk(value: String!): MessageTypeEnum

  """
  delete data from the table: "preference"
  """
  deletePreference(
    """filter the rows which have to be deleted"""
    where: PreferenceBoolExp!
  ): PreferenceMutationResponse

  """
  delete single row from the table: "preference"
  """
  deletePreferenceByPk(preferenceId: Int!): Preference

  """
  delete data from the table: "prompt"
  """
  deletePrompt(
    """filter the rows which have to be deleted"""
    where: PromptBoolExp!
  ): PromptMutationResponse

  """
  delete single row from the table: "prompt"
  """
  deletePromptByPk(promptId: Int!): Prompt

  """
  delete data from the table: "prompt_chatbot"
  """
  deletePromptChatbot(
    """filter the rows which have to be deleted"""
    where: PromptChatbotBoolExp!
  ): PromptChatbotMutationResponse

  """
  delete single row from the table: "prompt_chatbot"
  """
  deletePromptChatbotByPk(chabotId: Int!, promptId: Int!): PromptChatbot

  """
  delete data from the table: "prompt_type_enum"
  """
  deletePromptTypeEnum(
    """filter the rows which have to be deleted"""
    where: PromptTypeEnumBoolExp!
  ): PromptTypeEnumMutationResponse

  """
  delete single row from the table: "prompt_type_enum"
  """
  deletePromptTypeEnumByPk(value: String!): PromptTypeEnum

  """
  delete data from the table: "thread"
  """
  deleteThread(
    """filter the rows which have to be deleted"""
    where: ThreadBoolExp!
  ): ThreadMutationResponse

  """
  delete single row from the table: "thread"
  """
  deleteThreadByPk(threadId: uuid!): Thread

  """
  delete data from the table: "tone_enum"
  """
  deleteToneEnum(
    """filter the rows which have to be deleted"""
    where: ToneEnumBoolExp!
  ): ToneEnumMutationResponse

  """
  delete single row from the table: "tone_enum"
  """
  deleteToneEnumByPk(value: String!): ToneEnum

  """
  delete data from the table: "type_enum"
  """
  deleteTypeEnum(
    """filter the rows which have to be deleted"""
    where: TypeEnumBoolExp!
  ): TypeEnumMutationResponse

  """
  delete single row from the table: "type_enum"
  """
  deleteTypeEnumByPk(value: String!): TypeEnum

  """
  delete data from the table: "user"
  """
  deleteUser(
    """filter the rows which have to be deleted"""
    where: UserBoolExp!
  ): UserMutationResponse

  """
  delete single row from the table: "user"
  """
  deleteUserByPk(userId: uuid!): User

  """
  insert data into the table: "category"
  """
  insertCategory(
    """the rows to be inserted"""
    objects: [CategoryInsertInput!]!

    """upsert condition"""
    onConflict: CategoryOnConflict
  ): CategoryMutationResponse

  """
  insert a single row into the table: "category"
  """
  insertCategoryOne(
    """the row to be inserted"""
    object: CategoryInsertInput!

    """upsert condition"""
    onConflict: CategoryOnConflict
  ): Category

  """
  insert data into the table: "chat"
  """
  insertChat(
    """the rows to be inserted"""
    objects: [ChatInsertInput!]!

    """upsert condition"""
    onConflict: ChatOnConflict
  ): ChatMutationResponse

  """
  insert a single row into the table: "chat"
  """
  insertChatOne(
    """the row to be inserted"""
    object: ChatInsertInput!

    """upsert condition"""
    onConflict: ChatOnConflict
  ): Chat

  """
  insert data into the table: "chatbot"
  """
  insertChatbot(
    """the rows to be inserted"""
    objects: [ChatbotInsertInput!]!

    """upsert condition"""
    onConflict: ChatbotOnConflict
  ): ChatbotMutationResponse

  """
  insert data into the table: "chatbot_category"
  """
  insertChatbotCategory(
    """the rows to be inserted"""
    objects: [ChatbotCategoryInsertInput!]!

    """upsert condition"""
    onConflict: ChatbotCategoryOnConflict
  ): ChatbotCategoryMutationResponse

  """
  insert a single row into the table: "chatbot_category"
  """
  insertChatbotCategoryOne(
    """the row to be inserted"""
    object: ChatbotCategoryInsertInput!

    """upsert condition"""
    onConflict: ChatbotCategoryOnConflict
  ): ChatbotCategory

  """
  insert a single row into the table: "chatbot"
  """
  insertChatbotOne(
    """the row to be inserted"""
    object: ChatbotInsertInput!

    """upsert condition"""
    onConflict: ChatbotOnConflict
  ): Chatbot

  """
  insert data into the table: "complexity_enum"
  """
  insertComplexityEnum(
    """the rows to be inserted"""
    objects: [ComplexityEnumInsertInput!]!

    """upsert condition"""
    onConflict: ComplexityEnumOnConflict
  ): ComplexityEnumMutationResponse

  """
  insert a single row into the table: "complexity_enum"
  """
  insertComplexityEnumOne(
    """the row to be inserted"""
    object: ComplexityEnumInsertInput!

    """upsert condition"""
    onConflict: ComplexityEnumOnConflict
  ): ComplexityEnum

  """
  insert data into the table: "length_enum"
  """
  insertLengthEnum(
    """the rows to be inserted"""
    objects: [LengthEnumInsertInput!]!

    """upsert condition"""
    onConflict: LengthEnumOnConflict
  ): LengthEnumMutationResponse

  """
  insert a single row into the table: "length_enum"
  """
  insertLengthEnumOne(
    """the row to be inserted"""
    object: LengthEnumInsertInput!

    """upsert condition"""
    onConflict: LengthEnumOnConflict
  ): LengthEnum

  """
  insert data into the table: "message"
  """
  insertMessage(
    """the rows to be inserted"""
    objects: [MessageInsertInput!]!

    """upsert condition"""
    onConflict: MessageOnConflict
  ): MessageMutationResponse

  """
  insert a single row into the table: "message"
  """
  insertMessageOne(
    """the row to be inserted"""
    object: MessageInsertInput!

    """upsert condition"""
    onConflict: MessageOnConflict
  ): Message

  """
  insert data into the table: "message_type_enum"
  """
  insertMessageTypeEnum(
    """the rows to be inserted"""
    objects: [MessageTypeEnumInsertInput!]!

    """upsert condition"""
    onConflict: MessageTypeEnumOnConflict
  ): MessageTypeEnumMutationResponse

  """
  insert a single row into the table: "message_type_enum"
  """
  insertMessageTypeEnumOne(
    """the row to be inserted"""
    object: MessageTypeEnumInsertInput!

    """upsert condition"""
    onConflict: MessageTypeEnumOnConflict
  ): MessageTypeEnum

  """
  insert data into the table: "preference"
  """
  insertPreference(
    """the rows to be inserted"""
    objects: [PreferenceInsertInput!]!

    """upsert condition"""
    onConflict: PreferenceOnConflict
  ): PreferenceMutationResponse

  """
  insert a single row into the table: "preference"
  """
  insertPreferenceOne(
    """the row to be inserted"""
    object: PreferenceInsertInput!

    """upsert condition"""
    onConflict: PreferenceOnConflict
  ): Preference

  """
  insert data into the table: "prompt"
  """
  insertPrompt(
    """the rows to be inserted"""
    objects: [PromptInsertInput!]!

    """upsert condition"""
    onConflict: PromptOnConflict
  ): PromptMutationResponse

  """
  insert data into the table: "prompt_chatbot"
  """
  insertPromptChatbot(
    """the rows to be inserted"""
    objects: [PromptChatbotInsertInput!]!

    """upsert condition"""
    onConflict: PromptChatbotOnConflict
  ): PromptChatbotMutationResponse

  """
  insert a single row into the table: "prompt_chatbot"
  """
  insertPromptChatbotOne(
    """the row to be inserted"""
    object: PromptChatbotInsertInput!

    """upsert condition"""
    onConflict: PromptChatbotOnConflict
  ): PromptChatbot

  """
  insert a single row into the table: "prompt"
  """
  insertPromptOne(
    """the row to be inserted"""
    object: PromptInsertInput!

    """upsert condition"""
    onConflict: PromptOnConflict
  ): Prompt

  """
  insert data into the table: "prompt_type_enum"
  """
  insertPromptTypeEnum(
    """the rows to be inserted"""
    objects: [PromptTypeEnumInsertInput!]!

    """upsert condition"""
    onConflict: PromptTypeEnumOnConflict
  ): PromptTypeEnumMutationResponse

  """
  insert a single row into the table: "prompt_type_enum"
  """
  insertPromptTypeEnumOne(
    """the row to be inserted"""
    object: PromptTypeEnumInsertInput!

    """upsert condition"""
    onConflict: PromptTypeEnumOnConflict
  ): PromptTypeEnum

  """
  insert data into the table: "thread"
  """
  insertThread(
    """the rows to be inserted"""
    objects: [ThreadInsertInput!]!

    """upsert condition"""
    onConflict: ThreadOnConflict
  ): ThreadMutationResponse

  """
  insert a single row into the table: "thread"
  """
  insertThreadOne(
    """the row to be inserted"""
    object: ThreadInsertInput!

    """upsert condition"""
    onConflict: ThreadOnConflict
  ): Thread

  """
  insert data into the table: "tone_enum"
  """
  insertToneEnum(
    """the rows to be inserted"""
    objects: [ToneEnumInsertInput!]!

    """upsert condition"""
    onConflict: ToneEnumOnConflict
  ): ToneEnumMutationResponse

  """
  insert a single row into the table: "tone_enum"
  """
  insertToneEnumOne(
    """the row to be inserted"""
    object: ToneEnumInsertInput!

    """upsert condition"""
    onConflict: ToneEnumOnConflict
  ): ToneEnum

  """
  insert data into the table: "type_enum"
  """
  insertTypeEnum(
    """the rows to be inserted"""
    objects: [TypeEnumInsertInput!]!

    """upsert condition"""
    onConflict: TypeEnumOnConflict
  ): TypeEnumMutationResponse

  """
  insert a single row into the table: "type_enum"
  """
  insertTypeEnumOne(
    """the row to be inserted"""
    object: TypeEnumInsertInput!

    """upsert condition"""
    onConflict: TypeEnumOnConflict
  ): TypeEnum

  """
  insert data into the table: "user"
  """
  insertUser(
    """the rows to be inserted"""
    objects: [UserInsertInput!]!

    """upsert condition"""
    onConflict: UserOnConflict
  ): UserMutationResponse

  """
  insert a single row into the table: "user"
  """
  insertUserOne(
    """the row to be inserted"""
    object: UserInsertInput!

    """upsert condition"""
    onConflict: UserOnConflict
  ): User

  """
  update data of the table: "category"
  """
  updateCategory(
    """increments the numeric columns with given value of the filtered values"""
    _inc: CategoryIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: CategorySetInput

    """filter the rows which have to be updated"""
    where: CategoryBoolExp!
  ): CategoryMutationResponse

  """
  update single row of the table: "category"
  """
  updateCategoryByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: CategoryIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: CategorySetInput
    pkColumns: CategoryPkColumnsInput!
  ): Category

  """
  update multiples rows of table: "category"
  """
  updateCategoryMany(
    """updates to execute, in order"""
    updates: [CategoryUpdates!]!
  ): [CategoryMutationResponse]

  """
  update data of the table: "chat"
  """
  updateChat(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ChatIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: ChatSetInput

    """filter the rows which have to be updated"""
    where: ChatBoolExp!
  ): ChatMutationResponse

  """
  update single row of the table: "chat"
  """
  updateChatByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ChatIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: ChatSetInput
    pkColumns: ChatPkColumnsInput!
  ): Chat

  """
  update multiples rows of table: "chat"
  """
  updateChatMany(
    """updates to execute, in order"""
    updates: [ChatUpdates!]!
  ): [ChatMutationResponse]

  """
  update data of the table: "chatbot"
  """
  updateChatbot(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ChatbotIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: ChatbotSetInput

    """filter the rows which have to be updated"""
    where: ChatbotBoolExp!
  ): ChatbotMutationResponse

  """
  update single row of the table: "chatbot"
  """
  updateChatbotByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ChatbotIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: ChatbotSetInput
    pkColumns: ChatbotPkColumnsInput!
  ): Chatbot

  """
  update data of the table: "chatbot_category"
  """
  updateChatbotCategory(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ChatbotCategoryIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: ChatbotCategorySetInput

    """filter the rows which have to be updated"""
    where: ChatbotCategoryBoolExp!
  ): ChatbotCategoryMutationResponse

  """
  update single row of the table: "chatbot_category"
  """
  updateChatbotCategoryByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ChatbotCategoryIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: ChatbotCategorySetInput
    pkColumns: ChatbotCategoryPkColumnsInput!
  ): ChatbotCategory

  """
  update multiples rows of table: "chatbot_category"
  """
  updateChatbotCategoryMany(
    """updates to execute, in order"""
    updates: [ChatbotCategoryUpdates!]!
  ): [ChatbotCategoryMutationResponse]

  """
  update multiples rows of table: "chatbot"
  """
  updateChatbotMany(
    """updates to execute, in order"""
    updates: [ChatbotUpdates!]!
  ): [ChatbotMutationResponse]

  """
  update data of the table: "complexity_enum"
  """
  updateComplexityEnum(
    """sets the columns of the filtered rows to the given values"""
    _set: ComplexityEnumSetInput

    """filter the rows which have to be updated"""
    where: ComplexityEnumBoolExp!
  ): ComplexityEnumMutationResponse

  """
  update single row of the table: "complexity_enum"
  """
  updateComplexityEnumByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: ComplexityEnumSetInput
    pkColumns: ComplexityEnumPkColumnsInput!
  ): ComplexityEnum

  """
  update multiples rows of table: "complexity_enum"
  """
  updateComplexityEnumMany(
    """updates to execute, in order"""
    updates: [ComplexityEnumUpdates!]!
  ): [ComplexityEnumMutationResponse]

  """
  update data of the table: "length_enum"
  """
  updateLengthEnum(
    """sets the columns of the filtered rows to the given values"""
    _set: LengthEnumSetInput

    """filter the rows which have to be updated"""
    where: LengthEnumBoolExp!
  ): LengthEnumMutationResponse

  """
  update single row of the table: "length_enum"
  """
  updateLengthEnumByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: LengthEnumSetInput
    pkColumns: LengthEnumPkColumnsInput!
  ): LengthEnum

  """
  update multiples rows of table: "length_enum"
  """
  updateLengthEnumMany(
    """updates to execute, in order"""
    updates: [LengthEnumUpdates!]!
  ): [LengthEnumMutationResponse]

  """
  update data of the table: "message"
  """
  updateMessage(
    """sets the columns of the filtered rows to the given values"""
    _set: MessageSetInput

    """filter the rows which have to be updated"""
    where: MessageBoolExp!
  ): MessageMutationResponse

  """
  update single row of the table: "message"
  """
  updateMessageByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: MessageSetInput
    pkColumns: MessagePkColumnsInput!
  ): Message

  """
  update multiples rows of table: "message"
  """
  updateMessageMany(
    """updates to execute, in order"""
    updates: [MessageUpdates!]!
  ): [MessageMutationResponse]

  """
  update data of the table: "message_type_enum"
  """
  updateMessageTypeEnum(
    """sets the columns of the filtered rows to the given values"""
    _set: MessageTypeEnumSetInput

    """filter the rows which have to be updated"""
    where: MessageTypeEnumBoolExp!
  ): MessageTypeEnumMutationResponse

  """
  update single row of the table: "message_type_enum"
  """
  updateMessageTypeEnumByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: MessageTypeEnumSetInput
    pkColumns: MessageTypeEnumPkColumnsInput!
  ): MessageTypeEnum

  """
  update multiples rows of table: "message_type_enum"
  """
  updateMessageTypeEnumMany(
    """updates to execute, in order"""
    updates: [MessageTypeEnumUpdates!]!
  ): [MessageTypeEnumMutationResponse]

  """
  update data of the table: "preference"
  """
  updatePreference(
    """increments the numeric columns with given value of the filtered values"""
    _inc: PreferenceIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: PreferenceSetInput

    """filter the rows which have to be updated"""
    where: PreferenceBoolExp!
  ): PreferenceMutationResponse

  """
  update single row of the table: "preference"
  """
  updatePreferenceByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: PreferenceIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: PreferenceSetInput
    pkColumns: PreferencePkColumnsInput!
  ): Preference

  """
  update multiples rows of table: "preference"
  """
  updatePreferenceMany(
    """updates to execute, in order"""
    updates: [PreferenceUpdates!]!
  ): [PreferenceMutationResponse]

  """
  update data of the table: "prompt"
  """
  updatePrompt(
    """increments the numeric columns with given value of the filtered values"""
    _inc: PromptIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: PromptSetInput

    """filter the rows which have to be updated"""
    where: PromptBoolExp!
  ): PromptMutationResponse

  """
  update single row of the table: "prompt"
  """
  updatePromptByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: PromptIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: PromptSetInput
    pkColumns: PromptPkColumnsInput!
  ): Prompt

  """
  update data of the table: "prompt_chatbot"
  """
  updatePromptChatbot(
    """increments the numeric columns with given value of the filtered values"""
    _inc: PromptChatbotIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: PromptChatbotSetInput

    """filter the rows which have to be updated"""
    where: PromptChatbotBoolExp!
  ): PromptChatbotMutationResponse

  """
  update single row of the table: "prompt_chatbot"
  """
  updatePromptChatbotByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: PromptChatbotIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: PromptChatbotSetInput
    pkColumns: PromptChatbotPkColumnsInput!
  ): PromptChatbot

  """
  update multiples rows of table: "prompt_chatbot"
  """
  updatePromptChatbotMany(
    """updates to execute, in order"""
    updates: [PromptChatbotUpdates!]!
  ): [PromptChatbotMutationResponse]

  """
  update multiples rows of table: "prompt"
  """
  updatePromptMany(
    """updates to execute, in order"""
    updates: [PromptUpdates!]!
  ): [PromptMutationResponse]

  """
  update data of the table: "prompt_type_enum"
  """
  updatePromptTypeEnum(
    """sets the columns of the filtered rows to the given values"""
    _set: PromptTypeEnumSetInput

    """filter the rows which have to be updated"""
    where: PromptTypeEnumBoolExp!
  ): PromptTypeEnumMutationResponse

  """
  update single row of the table: "prompt_type_enum"
  """
  updatePromptTypeEnumByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: PromptTypeEnumSetInput
    pkColumns: PromptTypeEnumPkColumnsInput!
  ): PromptTypeEnum

  """
  update multiples rows of table: "prompt_type_enum"
  """
  updatePromptTypeEnumMany(
    """updates to execute, in order"""
    updates: [PromptTypeEnumUpdates!]!
  ): [PromptTypeEnumMutationResponse]

  """
  update data of the table: "thread"
  """
  updateThread(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ThreadIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: ThreadSetInput

    """filter the rows which have to be updated"""
    where: ThreadBoolExp!
  ): ThreadMutationResponse

  """
  update single row of the table: "thread"
  """
  updateThreadByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ThreadIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: ThreadSetInput
    pkColumns: ThreadPkColumnsInput!
  ): Thread

  """
  update multiples rows of table: "thread"
  """
  updateThreadMany(
    """updates to execute, in order"""
    updates: [ThreadUpdates!]!
  ): [ThreadMutationResponse]

  """
  update data of the table: "tone_enum"
  """
  updateToneEnum(
    """sets the columns of the filtered rows to the given values"""
    _set: ToneEnumSetInput

    """filter the rows which have to be updated"""
    where: ToneEnumBoolExp!
  ): ToneEnumMutationResponse

  """
  update single row of the table: "tone_enum"
  """
  updateToneEnumByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: ToneEnumSetInput
    pkColumns: ToneEnumPkColumnsInput!
  ): ToneEnum

  """
  update multiples rows of table: "tone_enum"
  """
  updateToneEnumMany(
    """updates to execute, in order"""
    updates: [ToneEnumUpdates!]!
  ): [ToneEnumMutationResponse]

  """
  update data of the table: "type_enum"
  """
  updateTypeEnum(
    """sets the columns of the filtered rows to the given values"""
    _set: TypeEnumSetInput

    """filter the rows which have to be updated"""
    where: TypeEnumBoolExp!
  ): TypeEnumMutationResponse

  """
  update single row of the table: "type_enum"
  """
  updateTypeEnumByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: TypeEnumSetInput
    pkColumns: TypeEnumPkColumnsInput!
  ): TypeEnum

  """
  update multiples rows of table: "type_enum"
  """
  updateTypeEnumMany(
    """updates to execute, in order"""
    updates: [TypeEnumUpdates!]!
  ): [TypeEnumMutationResponse]

  """
  update data of the table: "user"
  """
  updateUser(
    """sets the columns of the filtered rows to the given values"""
    _set: UserSetInput

    """filter the rows which have to be updated"""
    where: UserBoolExp!
  ): UserMutationResponse

  """
  update single row of the table: "user"
  """
  updateUserByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: UserSetInput
    pkColumns: UserPkColumnsInput!
  ): User

  """
  update multiples rows of table: "user"
  """
  updateUserMany(
    """updates to execute, in order"""
    updates: [UserUpdates!]!
  ): [UserMutationResponse]
}

input preferenceAggregateBoolExpBool_and {
  arguments: PreferenceSelectColumnPreferenceAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: PreferenceBoolExp
  predicate: BooleanComparisonExp!
}

input preferenceAggregateBoolExpBool_or {
  arguments: PreferenceSelectColumnPreferenceAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: PreferenceBoolExp
  predicate: BooleanComparisonExp!
}

input preferenceAggregateBoolExpCount {
  arguments: [PreferenceSelectColumn!]
  distinct: Boolean
  filter: PreferenceBoolExp
  predicate: IntComparisonExp!
}

input promptAggregateBoolExpCount {
  arguments: [PromptSelectColumn!]
  distinct: Boolean
  filter: PromptBoolExp
  predicate: IntComparisonExp!
}

input promptChatbotAggregateBoolExpCount {
  arguments: [PromptChatbotSelectColumn!]
  distinct: Boolean
  filter: PromptChatbotBoolExp
  predicate: IntComparisonExp!
}

type query_root {
  """
  fetch data from the table: "category"
  """
  category(
    """distinct select on columns"""
    distinctOn: [CategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CategoryOrderBy!]

    """filter the rows returned"""
    where: CategoryBoolExp
  ): [Category!]!

  """
  fetch aggregated fields from the table: "category"
  """
  categoryAggregate(
    """distinct select on columns"""
    distinctOn: [CategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CategoryOrderBy!]

    """filter the rows returned"""
    where: CategoryBoolExp
  ): CategoryAggregate!

  """fetch data from the table: "category" using primary key columns"""
  categoryByPk(categoryId: Int!): Category

  """
  fetch data from the table: "chat"
  """
  chat(
    """distinct select on columns"""
    distinctOn: [ChatSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatOrderBy!]

    """filter the rows returned"""
    where: ChatBoolExp
  ): [Chat!]!

  """
  fetch aggregated fields from the table: "chat"
  """
  chatAggregate(
    """distinct select on columns"""
    distinctOn: [ChatSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatOrderBy!]

    """filter the rows returned"""
    where: ChatBoolExp
  ): ChatAggregate!

  """fetch data from the table: "chat" using primary key columns"""
  chatByPk(chatId: Int!): Chat

  """
  fetch data from the table: "chatbot"
  """
  chatbot(
    """distinct select on columns"""
    distinctOn: [ChatbotSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotOrderBy!]

    """filter the rows returned"""
    where: ChatbotBoolExp
  ): [Chatbot!]!

  """
  fetch aggregated fields from the table: "chatbot"
  """
  chatbotAggregate(
    """distinct select on columns"""
    distinctOn: [ChatbotSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotOrderBy!]

    """filter the rows returned"""
    where: ChatbotBoolExp
  ): ChatbotAggregate!

  """fetch data from the table: "chatbot" using primary key columns"""
  chatbotByPk(chatbotId: Int!): Chatbot

  """
  fetch data from the table: "chatbot_category"
  """
  chatbotCategory(
    """distinct select on columns"""
    distinctOn: [ChatbotCategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotCategoryOrderBy!]

    """filter the rows returned"""
    where: ChatbotCategoryBoolExp
  ): [ChatbotCategory!]!

  """
  fetch aggregated fields from the table: "chatbot_category"
  """
  chatbotCategoryAggregate(
    """distinct select on columns"""
    distinctOn: [ChatbotCategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotCategoryOrderBy!]

    """filter the rows returned"""
    where: ChatbotCategoryBoolExp
  ): ChatbotCategoryAggregate!

  """
  fetch data from the table: "chatbot_category" using primary key columns
  """
  chatbotCategoryByPk(categoryId: Int!, chatbotId: Int!): ChatbotCategory

  """
  fetch data from the table: "complexity_enum"
  """
  complexityEnum(
    """distinct select on columns"""
    distinctOn: [ComplexityEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ComplexityEnumOrderBy!]

    """filter the rows returned"""
    where: ComplexityEnumBoolExp
  ): [ComplexityEnum!]!

  """
  fetch aggregated fields from the table: "complexity_enum"
  """
  complexityEnumAggregate(
    """distinct select on columns"""
    distinctOn: [ComplexityEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ComplexityEnumOrderBy!]

    """filter the rows returned"""
    where: ComplexityEnumBoolExp
  ): ComplexityEnumAggregate!

  """fetch data from the table: "complexity_enum" using primary key columns"""
  complexityEnumByPk(value: String!): ComplexityEnum

  """
  fetch data from the table: "length_enum"
  """
  lengthEnum(
    """distinct select on columns"""
    distinctOn: [LengthEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [LengthEnumOrderBy!]

    """filter the rows returned"""
    where: LengthEnumBoolExp
  ): [LengthEnum!]!

  """
  fetch aggregated fields from the table: "length_enum"
  """
  lengthEnumAggregate(
    """distinct select on columns"""
    distinctOn: [LengthEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [LengthEnumOrderBy!]

    """filter the rows returned"""
    where: LengthEnumBoolExp
  ): LengthEnumAggregate!

  """fetch data from the table: "length_enum" using primary key columns"""
  lengthEnumByPk(value: String!): LengthEnum

  """
  fetch data from the table: "message"
  """
  message(
    """distinct select on columns"""
    distinctOn: [MessageSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MessageOrderBy!]

    """filter the rows returned"""
    where: MessageBoolExp
  ): [Message!]!

  """
  fetch aggregated fields from the table: "message"
  """
  messageAggregate(
    """distinct select on columns"""
    distinctOn: [MessageSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MessageOrderBy!]

    """filter the rows returned"""
    where: MessageBoolExp
  ): MessageAggregate!

  """fetch data from the table: "message" using primary key columns"""
  messageByPk(messageId: uuid!): Message

  """
  fetch data from the table: "message_type_enum"
  """
  messageTypeEnum(
    """distinct select on columns"""
    distinctOn: [MessageTypeEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MessageTypeEnumOrderBy!]

    """filter the rows returned"""
    where: MessageTypeEnumBoolExp
  ): [MessageTypeEnum!]!

  """
  fetch aggregated fields from the table: "message_type_enum"
  """
  messageTypeEnumAggregate(
    """distinct select on columns"""
    distinctOn: [MessageTypeEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MessageTypeEnumOrderBy!]

    """filter the rows returned"""
    where: MessageTypeEnumBoolExp
  ): MessageTypeEnumAggregate!

  """
  fetch data from the table: "message_type_enum" using primary key columns
  """
  messageTypeEnumByPk(value: String!): MessageTypeEnum

  """
  fetch data from the table: "preference"
  """
  preference(
    """distinct select on columns"""
    distinctOn: [PreferenceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PreferenceOrderBy!]

    """filter the rows returned"""
    where: PreferenceBoolExp
  ): [Preference!]!

  """
  fetch aggregated fields from the table: "preference"
  """
  preferenceAggregate(
    """distinct select on columns"""
    distinctOn: [PreferenceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PreferenceOrderBy!]

    """filter the rows returned"""
    where: PreferenceBoolExp
  ): PreferenceAggregate!

  """fetch data from the table: "preference" using primary key columns"""
  preferenceByPk(preferenceId: Int!): Preference

  """
  fetch data from the table: "prompt"
  """
  prompt(
    """distinct select on columns"""
    distinctOn: [PromptSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptOrderBy!]

    """filter the rows returned"""
    where: PromptBoolExp
  ): [Prompt!]!

  """
  fetch aggregated fields from the table: "prompt"
  """
  promptAggregate(
    """distinct select on columns"""
    distinctOn: [PromptSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptOrderBy!]

    """filter the rows returned"""
    where: PromptBoolExp
  ): PromptAggregate!

  """fetch data from the table: "prompt" using primary key columns"""
  promptByPk(promptId: Int!): Prompt

  """
  fetch data from the table: "prompt_chatbot"
  """
  promptChatbot(
    """distinct select on columns"""
    distinctOn: [PromptChatbotSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptChatbotOrderBy!]

    """filter the rows returned"""
    where: PromptChatbotBoolExp
  ): [PromptChatbot!]!

  """
  fetch aggregated fields from the table: "prompt_chatbot"
  """
  promptChatbotAggregate(
    """distinct select on columns"""
    distinctOn: [PromptChatbotSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptChatbotOrderBy!]

    """filter the rows returned"""
    where: PromptChatbotBoolExp
  ): PromptChatbotAggregate!

  """fetch data from the table: "prompt_chatbot" using primary key columns"""
  promptChatbotByPk(chabotId: Int!, promptId: Int!): PromptChatbot

  """
  fetch data from the table: "prompt_type_enum"
  """
  promptTypeEnum(
    """distinct select on columns"""
    distinctOn: [PromptTypeEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptTypeEnumOrderBy!]

    """filter the rows returned"""
    where: PromptTypeEnumBoolExp
  ): [PromptTypeEnum!]!

  """
  fetch aggregated fields from the table: "prompt_type_enum"
  """
  promptTypeEnumAggregate(
    """distinct select on columns"""
    distinctOn: [PromptTypeEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptTypeEnumOrderBy!]

    """filter the rows returned"""
    where: PromptTypeEnumBoolExp
  ): PromptTypeEnumAggregate!

  """
  fetch data from the table: "prompt_type_enum" using primary key columns
  """
  promptTypeEnumByPk(value: String!): PromptTypeEnum

  """
  fetch data from the table: "thread"
  """
  thread(
    """distinct select on columns"""
    distinctOn: [ThreadSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ThreadOrderBy!]

    """filter the rows returned"""
    where: ThreadBoolExp
  ): [Thread!]!

  """
  fetch aggregated fields from the table: "thread"
  """
  threadAggregate(
    """distinct select on columns"""
    distinctOn: [ThreadSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ThreadOrderBy!]

    """filter the rows returned"""
    where: ThreadBoolExp
  ): ThreadAggregate!

  """fetch data from the table: "thread" using primary key columns"""
  threadByPk(threadId: uuid!): Thread

  """
  fetch data from the table: "tone_enum"
  """
  toneEnum(
    """distinct select on columns"""
    distinctOn: [ToneEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ToneEnumOrderBy!]

    """filter the rows returned"""
    where: ToneEnumBoolExp
  ): [ToneEnum!]!

  """
  fetch aggregated fields from the table: "tone_enum"
  """
  toneEnumAggregate(
    """distinct select on columns"""
    distinctOn: [ToneEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ToneEnumOrderBy!]

    """filter the rows returned"""
    where: ToneEnumBoolExp
  ): ToneEnumAggregate!

  """fetch data from the table: "tone_enum" using primary key columns"""
  toneEnumByPk(value: String!): ToneEnum

  """
  fetch data from the table: "type_enum"
  """
  typeEnum(
    """distinct select on columns"""
    distinctOn: [TypeEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TypeEnumOrderBy!]

    """filter the rows returned"""
    where: TypeEnumBoolExp
  ): [TypeEnum!]!

  """
  fetch aggregated fields from the table: "type_enum"
  """
  typeEnumAggregate(
    """distinct select on columns"""
    distinctOn: [TypeEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TypeEnumOrderBy!]

    """filter the rows returned"""
    where: TypeEnumBoolExp
  ): TypeEnumAggregate!

  """fetch data from the table: "type_enum" using primary key columns"""
  typeEnumByPk(value: String!): TypeEnum

  """
  fetch data from the table: "user"
  """
  user(
    """distinct select on columns"""
    distinctOn: [UserSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [UserOrderBy!]

    """filter the rows returned"""
    where: UserBoolExp
  ): [User!]!

  """
  fetch aggregated fields from the table: "user"
  """
  userAggregate(
    """distinct select on columns"""
    distinctOn: [UserSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [UserOrderBy!]

    """filter the rows returned"""
    where: UserBoolExp
  ): UserAggregate!

  """fetch data from the table: "user" using primary key columns"""
  userByPk(userId: uuid!): User
}

type subscription_root {
  """
  fetch data from the table: "category"
  """
  category(
    """distinct select on columns"""
    distinctOn: [CategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CategoryOrderBy!]

    """filter the rows returned"""
    where: CategoryBoolExp
  ): [Category!]!

  """
  fetch aggregated fields from the table: "category"
  """
  categoryAggregate(
    """distinct select on columns"""
    distinctOn: [CategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CategoryOrderBy!]

    """filter the rows returned"""
    where: CategoryBoolExp
  ): CategoryAggregate!

  """fetch data from the table: "category" using primary key columns"""
  categoryByPk(categoryId: Int!): Category

  """
  fetch data from the table in a streaming manner: "category"
  """
  categoryStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [CategoryStreamCursorInput]!

    """filter the rows returned"""
    where: CategoryBoolExp
  ): [Category!]!

  """
  fetch data from the table: "chat"
  """
  chat(
    """distinct select on columns"""
    distinctOn: [ChatSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatOrderBy!]

    """filter the rows returned"""
    where: ChatBoolExp
  ): [Chat!]!

  """
  fetch aggregated fields from the table: "chat"
  """
  chatAggregate(
    """distinct select on columns"""
    distinctOn: [ChatSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatOrderBy!]

    """filter the rows returned"""
    where: ChatBoolExp
  ): ChatAggregate!

  """fetch data from the table: "chat" using primary key columns"""
  chatByPk(chatId: Int!): Chat

  """
  fetch data from the table in a streaming manner: "chat"
  """
  chatStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ChatStreamCursorInput]!

    """filter the rows returned"""
    where: ChatBoolExp
  ): [Chat!]!

  """
  fetch data from the table: "chatbot"
  """
  chatbot(
    """distinct select on columns"""
    distinctOn: [ChatbotSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotOrderBy!]

    """filter the rows returned"""
    where: ChatbotBoolExp
  ): [Chatbot!]!

  """
  fetch aggregated fields from the table: "chatbot"
  """
  chatbotAggregate(
    """distinct select on columns"""
    distinctOn: [ChatbotSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotOrderBy!]

    """filter the rows returned"""
    where: ChatbotBoolExp
  ): ChatbotAggregate!

  """fetch data from the table: "chatbot" using primary key columns"""
  chatbotByPk(chatbotId: Int!): Chatbot

  """
  fetch data from the table: "chatbot_category"
  """
  chatbotCategory(
    """distinct select on columns"""
    distinctOn: [ChatbotCategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotCategoryOrderBy!]

    """filter the rows returned"""
    where: ChatbotCategoryBoolExp
  ): [ChatbotCategory!]!

  """
  fetch aggregated fields from the table: "chatbot_category"
  """
  chatbotCategoryAggregate(
    """distinct select on columns"""
    distinctOn: [ChatbotCategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotCategoryOrderBy!]

    """filter the rows returned"""
    where: ChatbotCategoryBoolExp
  ): ChatbotCategoryAggregate!

  """
  fetch data from the table: "chatbot_category" using primary key columns
  """
  chatbotCategoryByPk(categoryId: Int!, chatbotId: Int!): ChatbotCategory

  """
  fetch data from the table in a streaming manner: "chatbot_category"
  """
  chatbotCategoryStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ChatbotCategoryStreamCursorInput]!

    """filter the rows returned"""
    where: ChatbotCategoryBoolExp
  ): [ChatbotCategory!]!

  """
  fetch data from the table in a streaming manner: "chatbot"
  """
  chatbotStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ChatbotStreamCursorInput]!

    """filter the rows returned"""
    where: ChatbotBoolExp
  ): [Chatbot!]!

  """
  fetch data from the table: "complexity_enum"
  """
  complexityEnum(
    """distinct select on columns"""
    distinctOn: [ComplexityEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ComplexityEnumOrderBy!]

    """filter the rows returned"""
    where: ComplexityEnumBoolExp
  ): [ComplexityEnum!]!

  """
  fetch aggregated fields from the table: "complexity_enum"
  """
  complexityEnumAggregate(
    """distinct select on columns"""
    distinctOn: [ComplexityEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ComplexityEnumOrderBy!]

    """filter the rows returned"""
    where: ComplexityEnumBoolExp
  ): ComplexityEnumAggregate!

  """fetch data from the table: "complexity_enum" using primary key columns"""
  complexityEnumByPk(value: String!): ComplexityEnum

  """
  fetch data from the table in a streaming manner: "complexity_enum"
  """
  complexityEnumStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ComplexityEnumStreamCursorInput]!

    """filter the rows returned"""
    where: ComplexityEnumBoolExp
  ): [ComplexityEnum!]!

  """
  fetch data from the table: "length_enum"
  """
  lengthEnum(
    """distinct select on columns"""
    distinctOn: [LengthEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [LengthEnumOrderBy!]

    """filter the rows returned"""
    where: LengthEnumBoolExp
  ): [LengthEnum!]!

  """
  fetch aggregated fields from the table: "length_enum"
  """
  lengthEnumAggregate(
    """distinct select on columns"""
    distinctOn: [LengthEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [LengthEnumOrderBy!]

    """filter the rows returned"""
    where: LengthEnumBoolExp
  ): LengthEnumAggregate!

  """fetch data from the table: "length_enum" using primary key columns"""
  lengthEnumByPk(value: String!): LengthEnum

  """
  fetch data from the table in a streaming manner: "length_enum"
  """
  lengthEnumStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [LengthEnumStreamCursorInput]!

    """filter the rows returned"""
    where: LengthEnumBoolExp
  ): [LengthEnum!]!

  """
  fetch data from the table: "message"
  """
  message(
    """distinct select on columns"""
    distinctOn: [MessageSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MessageOrderBy!]

    """filter the rows returned"""
    where: MessageBoolExp
  ): [Message!]!

  """
  fetch aggregated fields from the table: "message"
  """
  messageAggregate(
    """distinct select on columns"""
    distinctOn: [MessageSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MessageOrderBy!]

    """filter the rows returned"""
    where: MessageBoolExp
  ): MessageAggregate!

  """fetch data from the table: "message" using primary key columns"""
  messageByPk(messageId: uuid!): Message

  """
  fetch data from the table in a streaming manner: "message"
  """
  messageStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [MessageStreamCursorInput]!

    """filter the rows returned"""
    where: MessageBoolExp
  ): [Message!]!

  """
  fetch data from the table: "message_type_enum"
  """
  messageTypeEnum(
    """distinct select on columns"""
    distinctOn: [MessageTypeEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MessageTypeEnumOrderBy!]

    """filter the rows returned"""
    where: MessageTypeEnumBoolExp
  ): [MessageTypeEnum!]!

  """
  fetch aggregated fields from the table: "message_type_enum"
  """
  messageTypeEnumAggregate(
    """distinct select on columns"""
    distinctOn: [MessageTypeEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MessageTypeEnumOrderBy!]

    """filter the rows returned"""
    where: MessageTypeEnumBoolExp
  ): MessageTypeEnumAggregate!

  """
  fetch data from the table: "message_type_enum" using primary key columns
  """
  messageTypeEnumByPk(value: String!): MessageTypeEnum

  """
  fetch data from the table in a streaming manner: "message_type_enum"
  """
  messageTypeEnumStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [MessageTypeEnumStreamCursorInput]!

    """filter the rows returned"""
    where: MessageTypeEnumBoolExp
  ): [MessageTypeEnum!]!

  """
  fetch data from the table: "preference"
  """
  preference(
    """distinct select on columns"""
    distinctOn: [PreferenceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PreferenceOrderBy!]

    """filter the rows returned"""
    where: PreferenceBoolExp
  ): [Preference!]!

  """
  fetch aggregated fields from the table: "preference"
  """
  preferenceAggregate(
    """distinct select on columns"""
    distinctOn: [PreferenceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PreferenceOrderBy!]

    """filter the rows returned"""
    where: PreferenceBoolExp
  ): PreferenceAggregate!

  """fetch data from the table: "preference" using primary key columns"""
  preferenceByPk(preferenceId: Int!): Preference

  """
  fetch data from the table in a streaming manner: "preference"
  """
  preferenceStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [PreferenceStreamCursorInput]!

    """filter the rows returned"""
    where: PreferenceBoolExp
  ): [Preference!]!

  """
  fetch data from the table: "prompt"
  """
  prompt(
    """distinct select on columns"""
    distinctOn: [PromptSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptOrderBy!]

    """filter the rows returned"""
    where: PromptBoolExp
  ): [Prompt!]!

  """
  fetch aggregated fields from the table: "prompt"
  """
  promptAggregate(
    """distinct select on columns"""
    distinctOn: [PromptSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptOrderBy!]

    """filter the rows returned"""
    where: PromptBoolExp
  ): PromptAggregate!

  """fetch data from the table: "prompt" using primary key columns"""
  promptByPk(promptId: Int!): Prompt

  """
  fetch data from the table: "prompt_chatbot"
  """
  promptChatbot(
    """distinct select on columns"""
    distinctOn: [PromptChatbotSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptChatbotOrderBy!]

    """filter the rows returned"""
    where: PromptChatbotBoolExp
  ): [PromptChatbot!]!

  """
  fetch aggregated fields from the table: "prompt_chatbot"
  """
  promptChatbotAggregate(
    """distinct select on columns"""
    distinctOn: [PromptChatbotSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptChatbotOrderBy!]

    """filter the rows returned"""
    where: PromptChatbotBoolExp
  ): PromptChatbotAggregate!

  """fetch data from the table: "prompt_chatbot" using primary key columns"""
  promptChatbotByPk(chabotId: Int!, promptId: Int!): PromptChatbot

  """
  fetch data from the table in a streaming manner: "prompt_chatbot"
  """
  promptChatbotStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [PromptChatbotStreamCursorInput]!

    """filter the rows returned"""
    where: PromptChatbotBoolExp
  ): [PromptChatbot!]!

  """
  fetch data from the table in a streaming manner: "prompt"
  """
  promptStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [PromptStreamCursorInput]!

    """filter the rows returned"""
    where: PromptBoolExp
  ): [Prompt!]!

  """
  fetch data from the table: "prompt_type_enum"
  """
  promptTypeEnum(
    """distinct select on columns"""
    distinctOn: [PromptTypeEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptTypeEnumOrderBy!]

    """filter the rows returned"""
    where: PromptTypeEnumBoolExp
  ): [PromptTypeEnum!]!

  """
  fetch aggregated fields from the table: "prompt_type_enum"
  """
  promptTypeEnumAggregate(
    """distinct select on columns"""
    distinctOn: [PromptTypeEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptTypeEnumOrderBy!]

    """filter the rows returned"""
    where: PromptTypeEnumBoolExp
  ): PromptTypeEnumAggregate!

  """
  fetch data from the table: "prompt_type_enum" using primary key columns
  """
  promptTypeEnumByPk(value: String!): PromptTypeEnum

  """
  fetch data from the table in a streaming manner: "prompt_type_enum"
  """
  promptTypeEnumStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [PromptTypeEnumStreamCursorInput]!

    """filter the rows returned"""
    where: PromptTypeEnumBoolExp
  ): [PromptTypeEnum!]!

  """
  fetch data from the table: "thread"
  """
  thread(
    """distinct select on columns"""
    distinctOn: [ThreadSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ThreadOrderBy!]

    """filter the rows returned"""
    where: ThreadBoolExp
  ): [Thread!]!

  """
  fetch aggregated fields from the table: "thread"
  """
  threadAggregate(
    """distinct select on columns"""
    distinctOn: [ThreadSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ThreadOrderBy!]

    """filter the rows returned"""
    where: ThreadBoolExp
  ): ThreadAggregate!

  """fetch data from the table: "thread" using primary key columns"""
  threadByPk(threadId: uuid!): Thread

  """
  fetch data from the table in a streaming manner: "thread"
  """
  threadStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ThreadStreamCursorInput]!

    """filter the rows returned"""
    where: ThreadBoolExp
  ): [Thread!]!

  """
  fetch data from the table: "tone_enum"
  """
  toneEnum(
    """distinct select on columns"""
    distinctOn: [ToneEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ToneEnumOrderBy!]

    """filter the rows returned"""
    where: ToneEnumBoolExp
  ): [ToneEnum!]!

  """
  fetch aggregated fields from the table: "tone_enum"
  """
  toneEnumAggregate(
    """distinct select on columns"""
    distinctOn: [ToneEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ToneEnumOrderBy!]

    """filter the rows returned"""
    where: ToneEnumBoolExp
  ): ToneEnumAggregate!

  """fetch data from the table: "tone_enum" using primary key columns"""
  toneEnumByPk(value: String!): ToneEnum

  """
  fetch data from the table in a streaming manner: "tone_enum"
  """
  toneEnumStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ToneEnumStreamCursorInput]!

    """filter the rows returned"""
    where: ToneEnumBoolExp
  ): [ToneEnum!]!

  """
  fetch data from the table: "type_enum"
  """
  typeEnum(
    """distinct select on columns"""
    distinctOn: [TypeEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TypeEnumOrderBy!]

    """filter the rows returned"""
    where: TypeEnumBoolExp
  ): [TypeEnum!]!

  """
  fetch aggregated fields from the table: "type_enum"
  """
  typeEnumAggregate(
    """distinct select on columns"""
    distinctOn: [TypeEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TypeEnumOrderBy!]

    """filter the rows returned"""
    where: TypeEnumBoolExp
  ): TypeEnumAggregate!

  """fetch data from the table: "type_enum" using primary key columns"""
  typeEnumByPk(value: String!): TypeEnum

  """
  fetch data from the table in a streaming manner: "type_enum"
  """
  typeEnumStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [TypeEnumStreamCursorInput]!

    """filter the rows returned"""
    where: TypeEnumBoolExp
  ): [TypeEnum!]!

  """
  fetch data from the table: "user"
  """
  user(
    """distinct select on columns"""
    distinctOn: [UserSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [UserOrderBy!]

    """filter the rows returned"""
    where: UserBoolExp
  ): [User!]!

  """
  fetch aggregated fields from the table: "user"
  """
  userAggregate(
    """distinct select on columns"""
    distinctOn: [UserSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [UserOrderBy!]

    """filter the rows returned"""
    where: UserBoolExp
  ): UserAggregate!

  """fetch data from the table: "user" using primary key columns"""
  userByPk(userId: uuid!): User

  """
  fetch data from the table in a streaming manner: "user"
  """
  userStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [UserStreamCursorInput]!

    """filter the rows returned"""
    where: UserBoolExp
  ): [User!]!
}

input threadAggregateBoolExpCount {
  arguments: [ThreadSelectColumn!]
  distinct: Boolean
  filter: ThreadBoolExp
  predicate: IntComparisonExp!
}

scalar timestamptz

scalar uuid