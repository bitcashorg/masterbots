schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """measured in seconds"""
  ttl: Int! = 60

  """refresh the cache entry"""
  refresh: Boolean! = false
) on QUERY

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input BooleanComparisonExp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _isNull: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""Table to store different categories for chatbots."""
type Category {
  categoryId: Int!

  """An array relationship"""
  chatbots(
    """distinct select on columns"""
    distinctOn: [ChatbotCategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotCategoryOrderBy!]

    """filter the rows returned"""
    where: ChatbotCategoryBoolExp
  ): [ChatbotCategory!]!

  """An aggregate relationship"""
  chatbotsAggregate(
    """distinct select on columns"""
    distinctOn: [ChatbotCategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotCategoryOrderBy!]

    """filter the rows returned"""
    where: ChatbotCategoryBoolExp
  ): ChatbotCategoryAggregate!
  name: String!
}

"""
aggregated selection of "category"
"""
type CategoryAggregate {
  aggregate: CategoryAggregateFields
  nodes: [Category!]!
}

"""
aggregate fields of "category"
"""
type CategoryAggregateFields {
  avg: CategoryAvgFields
  count(columns: [CategorySelectColumn!], distinct: Boolean): Int!
  max: CategoryMaxFields
  min: CategoryMinFields
  stddev: CategoryStddevFields
  stddevPop: CategoryStddevPopFields
  stddevSamp: CategoryStddevSampFields
  sum: CategorySumFields
  varPop: CategoryVarPopFields
  varSamp: CategoryVarSampFields
  variance: CategoryVarianceFields
}

"""aggregate avg on columns"""
type CategoryAvgFields {
  categoryId: Float
}

"""
Boolean expression to filter rows from the table "category". All fields are combined with a logical 'AND'.
"""
input CategoryBoolExp {
  _and: [CategoryBoolExp!]
  _not: CategoryBoolExp
  _or: [CategoryBoolExp!]
  categoryId: IntComparisonExp
  chatbots: ChatbotCategoryBoolExp
  chatbotsAggregate: ChatbotCategoryAggregateBoolExp
  name: StringComparisonExp
}

"""
unique or primary key constraints on table "category"
"""
enum CategoryConstraint {
  """
  unique or primary key constraint on columns "name"
  """
  category_name_key

  """
  unique or primary key constraint on columns "category_id"
  """
  category_pkey
}

"""
columns and relationships of "category_enum"
"""
type CategoryEnum {
  added: timestamptz!
  domain: String!

  """An object relationship"""
  domain_enum: DomainEnum!
  name: String!

  """An aggregate relationship"""
  subcategoryEnumsAggregate(
    """distinct select on columns"""
    distinctOn: [SubcategoryEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [SubcategoryEnumOrderBy!]

    """filter the rows returned"""
    where: SubcategoryEnumBoolExp
  ): SubcategoryEnumAggregate!

  """An array relationship"""
  subcategoryEnumsByCategoryDomain(
    """distinct select on columns"""
    distinctOn: [SubcategoryEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [SubcategoryEnumOrderBy!]

    """filter the rows returned"""
    where: SubcategoryEnumBoolExp
  ): [SubcategoryEnum!]!

  """An aggregate relationship"""
  subcategoryEnumsByCategoryDomainAggregate(
    """distinct select on columns"""
    distinctOn: [SubcategoryEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [SubcategoryEnumOrderBy!]

    """filter the rows returned"""
    where: SubcategoryEnumBoolExp
  ): SubcategoryEnumAggregate!

  """An array relationship"""
  subcategory_enums(
    """distinct select on columns"""
    distinctOn: [SubcategoryEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [SubcategoryEnumOrderBy!]

    """filter the rows returned"""
    where: SubcategoryEnumBoolExp
  ): [SubcategoryEnum!]!
}

"""
aggregated selection of "category_enum"
"""
type CategoryEnumAggregate {
  aggregate: CategoryEnumAggregateFields
  nodes: [CategoryEnum!]!
}

input CategoryEnumAggregateBoolExp {
  count: categoryEnumAggregateBoolExpCount
}

"""
aggregate fields of "category_enum"
"""
type CategoryEnumAggregateFields {
  count(columns: [CategoryEnumSelectColumn!], distinct: Boolean): Int!
  max: CategoryEnumMaxFields
  min: CategoryEnumMinFields
}

"""
order by aggregate values of table "category_enum"
"""
input CategoryEnumAggregateOrderBy {
  count: OrderBy
  max: CategoryEnumMaxOrderBy
  min: CategoryEnumMinOrderBy
}

"""
input type for inserting array relation for remote table "category_enum"
"""
input CategoryEnumArrRelInsertInput {
  data: [CategoryEnumInsertInput!]!

  """upsert condition"""
  onConflict: CategoryEnumOnConflict
}

"""
Boolean expression to filter rows from the table "category_enum". All fields are combined with a logical 'AND'.
"""
input CategoryEnumBoolExp {
  _and: [CategoryEnumBoolExp!]
  _not: CategoryEnumBoolExp
  _or: [CategoryEnumBoolExp!]
  added: TimestamptzComparisonExp
  domain: StringComparisonExp
  domain_enum: DomainEnumBoolExp
  name: StringComparisonExp
  subcategoryEnumsByCategoryDomain: SubcategoryEnumBoolExp
  subcategoryEnumsByCategoryDomainAggregate: SubcategoryEnumAggregateBoolExp
  subcategory_enums: SubcategoryEnumBoolExp
  subcategory_enumsAggregate: SubcategoryEnumAggregateBoolExp
}

"""
unique or primary key constraints on table "category_enum"
"""
enum CategoryEnumConstraint {
  """
  unique or primary key constraint on columns "domain", "name"
  """
  category_enum_pkey
}

"""
input type for inserting data into table "category_enum"
"""
input CategoryEnumInsertInput {
  added: timestamptz
  domain: String
  domain_enum: DomainEnumObjRelInsertInput
  name: String
  subcategoryEnumsByCategoryDomain: SubcategoryEnumArrRelInsertInput
  subcategory_enums: SubcategoryEnumArrRelInsertInput
}

"""aggregate max on columns"""
type CategoryEnumMaxFields {
  added: timestamptz
  domain: String
  name: String
}

"""
order by max() on columns of table "category_enum"
"""
input CategoryEnumMaxOrderBy {
  added: OrderBy
  domain: OrderBy
  name: OrderBy
}

"""aggregate min on columns"""
type CategoryEnumMinFields {
  added: timestamptz
  domain: String
  name: String
}

"""
order by min() on columns of table "category_enum"
"""
input CategoryEnumMinOrderBy {
  added: OrderBy
  domain: OrderBy
  name: OrderBy
}

"""
response of any mutation on the table "category_enum"
"""
type CategoryEnumMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [CategoryEnum!]!
}

"""
input type for inserting object relation for remote table "category_enum"
"""
input CategoryEnumObjRelInsertInput {
  data: CategoryEnumInsertInput!

  """upsert condition"""
  onConflict: CategoryEnumOnConflict
}

"""
on_conflict condition type for table "category_enum"
"""
input CategoryEnumOnConflict {
  constraint: CategoryEnumConstraint!
  updateColumns: [CategoryEnumUpdateColumn!]! = []
  where: CategoryEnumBoolExp
}

"""Ordering options when selecting data from "category_enum"."""
input CategoryEnumOrderBy {
  added: OrderBy
  domain: OrderBy
  domain_enum: DomainEnumOrderBy
  name: OrderBy
  subcategoryEnumsByCategoryDomainAggregate: SubcategoryEnumAggregateOrderBy
  subcategory_enumsAggregate: SubcategoryEnumAggregateOrderBy
}

"""primary key columns input for table: category_enum"""
input CategoryEnumPkColumnsInput {
  domain: String!
  name: String!
}

"""
select columns of table "category_enum"
"""
enum CategoryEnumSelectColumn {
  """column name"""
  added

  """column name"""
  domain

  """column name"""
  name
}

"""
input type for updating data in table "category_enum"
"""
input CategoryEnumSetInput {
  added: timestamptz
  domain: String
  name: String
}

"""
Streaming cursor of the table "category_enum"
"""
input CategoryEnumStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: CategoryEnumStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input CategoryEnumStreamCursorValueInput {
  added: timestamptz
  domain: String
  name: String
}

"""
update columns of table "category_enum"
"""
enum CategoryEnumUpdateColumn {
  """column name"""
  added

  """column name"""
  domain

  """column name"""
  name
}

input CategoryEnumUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: CategoryEnumSetInput

  """filter the rows which have to be updated"""
  where: CategoryEnumBoolExp!
}

"""
input type for incrementing numeric columns in table "category"
"""
input CategoryIncInput {
  categoryId: Int
}

"""
input type for inserting data into table "category"
"""
input CategoryInsertInput {
  categoryId: Int
  chatbots: ChatbotCategoryArrRelInsertInput
  name: String
}

"""aggregate max on columns"""
type CategoryMaxFields {
  categoryId: Int
  name: String
}

"""aggregate min on columns"""
type CategoryMinFields {
  categoryId: Int
  name: String
}

"""
response of any mutation on the table "category"
"""
type CategoryMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Category!]!
}

"""
input type for inserting object relation for remote table "category"
"""
input CategoryObjRelInsertInput {
  data: CategoryInsertInput!

  """upsert condition"""
  onConflict: CategoryOnConflict
}

"""
on_conflict condition type for table "category"
"""
input CategoryOnConflict {
  constraint: CategoryConstraint!
  updateColumns: [CategoryUpdateColumn!]! = []
  where: CategoryBoolExp
}

"""Ordering options when selecting data from "category"."""
input CategoryOrderBy {
  categoryId: OrderBy
  chatbotsAggregate: ChatbotCategoryAggregateOrderBy
  name: OrderBy
}

"""primary key columns input for table: category"""
input CategoryPkColumnsInput {
  categoryId: Int!
}

"""
select columns of table "category"
"""
enum CategorySelectColumn {
  """column name"""
  categoryId

  """column name"""
  name
}

"""
input type for updating data in table "category"
"""
input CategorySetInput {
  categoryId: Int
  name: String
}

"""aggregate stddev on columns"""
type CategoryStddevFields {
  categoryId: Float
}

"""aggregate stddevPop on columns"""
type CategoryStddevPopFields {
  categoryId: Float
}

"""aggregate stddevSamp on columns"""
type CategoryStddevSampFields {
  categoryId: Float
}

"""
Streaming cursor of the table "category"
"""
input CategoryStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: CategoryStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input CategoryStreamCursorValueInput {
  categoryId: Int
  name: String
}

"""aggregate sum on columns"""
type CategorySumFields {
  categoryId: Int
}

"""
update columns of table "category"
"""
enum CategoryUpdateColumn {
  """column name"""
  categoryId

  """column name"""
  name
}

input CategoryUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: CategoryIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: CategorySetInput

  """filter the rows which have to be updated"""
  where: CategoryBoolExp!
}

"""aggregate varPop on columns"""
type CategoryVarPopFields {
  categoryId: Float
}

"""aggregate varSamp on columns"""
type CategoryVarSampFields {
  categoryId: Float
}

"""aggregate variance on columns"""
type CategoryVarianceFields {
  categoryId: Float
}

"""
Table storing information about chatbots, their characteristics, and default settings.
"""
type Chatbot {
  avatar: String

  """An array relationship"""
  categories(
    """distinct select on columns"""
    distinctOn: [ChatbotCategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotCategoryOrderBy!]

    """filter the rows returned"""
    where: ChatbotCategoryBoolExp
  ): [ChatbotCategory!]!

  """An aggregate relationship"""
  categoriesAggregate(
    """distinct select on columns"""
    distinctOn: [ChatbotCategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotCategoryOrderBy!]

    """filter the rows returned"""
    where: ChatbotCategoryBoolExp
  ): ChatbotCategoryAggregate!
  chatbotId: Int!

  """An object relationship"""
  complexityEnum: ComplexityEnum
  createdBy: String!
  defaultComplexity: String
  defaultLength: String
  defaultTone: String
  defaultType: String
  description: String

  """An array relationship"""
  followers(
    """distinct select on columns"""
    distinctOn: [SocialFollowingSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [SocialFollowingOrderBy!]

    """filter the rows returned"""
    where: SocialFollowingBoolExp
  ): [SocialFollowing!]!

  """An aggregate relationship"""
  followersAggregate(
    """distinct select on columns"""
    distinctOn: [SocialFollowingSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [SocialFollowingOrderBy!]

    """filter the rows returned"""
    where: SocialFollowingBoolExp
  ): SocialFollowingAggregate!

  """An object relationship"""
  lengthEnum: LengthEnum

  """An array relationship"""
  metadata(
    """distinct select on columns"""
    distinctOn: [ChatbotDomainSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotDomainOrderBy!]

    """filter the rows returned"""
    where: ChatbotDomainBoolExp
  ): [ChatbotDomain!]!

  """An aggregate relationship"""
  metadataAggregate(
    """distinct select on columns"""
    distinctOn: [ChatbotDomainSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotDomainOrderBy!]

    """filter the rows returned"""
    where: ChatbotDomainBoolExp
  ): ChatbotDomainAggregate!
  name: String!

  """An array relationship"""
  preferences(
    """distinct select on columns"""
    distinctOn: [PreferenceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PreferenceOrderBy!]

    """filter the rows returned"""
    where: PreferenceBoolExp
  ): [Preference!]!

  """An aggregate relationship"""
  preferencesAggregate(
    """distinct select on columns"""
    distinctOn: [PreferenceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PreferenceOrderBy!]

    """filter the rows returned"""
    where: PreferenceBoolExp
  ): PreferenceAggregate!

  """An array relationship"""
  prompts(
    """distinct select on columns"""
    distinctOn: [PromptChatbotSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptChatbotOrderBy!]

    """filter the rows returned"""
    where: PromptChatbotBoolExp
  ): [PromptChatbot!]!

  """An aggregate relationship"""
  promptsAggregate(
    """distinct select on columns"""
    distinctOn: [PromptChatbotSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptChatbotOrderBy!]

    """filter the rows returned"""
    where: PromptChatbotBoolExp
  ): PromptChatbotAggregate!

  """An array relationship"""
  threads(
    """distinct select on columns"""
    distinctOn: [ThreadSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ThreadOrderBy!]

    """filter the rows returned"""
    where: ThreadBoolExp
  ): [Thread!]!

  """An aggregate relationship"""
  threadsAggregate(
    """distinct select on columns"""
    distinctOn: [ThreadSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ThreadOrderBy!]

    """filter the rows returned"""
    where: ThreadBoolExp
  ): ThreadAggregate!

  """An object relationship"""
  toneEnum: ToneEnum

  """An object relationship"""
  typeEnum: TypeEnum
}

"""
aggregated selection of "chatbot"
"""
type ChatbotAggregate {
  aggregate: ChatbotAggregateFields
  nodes: [Chatbot!]!
}

input ChatbotAggregateBoolExp {
  count: chatbotAggregateBoolExpCount
}

"""
aggregate fields of "chatbot"
"""
type ChatbotAggregateFields {
  avg: ChatbotAvgFields
  count(columns: [ChatbotSelectColumn!], distinct: Boolean): Int!
  max: ChatbotMaxFields
  min: ChatbotMinFields
  stddev: ChatbotStddevFields
  stddevPop: ChatbotStddevPopFields
  stddevSamp: ChatbotStddevSampFields
  sum: ChatbotSumFields
  varPop: ChatbotVarPopFields
  varSamp: ChatbotVarSampFields
  variance: ChatbotVarianceFields
}

"""
order by aggregate values of table "chatbot"
"""
input ChatbotAggregateOrderBy {
  avg: ChatbotAvgOrderBy
  count: OrderBy
  max: ChatbotMaxOrderBy
  min: ChatbotMinOrderBy
  stddev: ChatbotStddevOrderBy
  stddevPop: ChatbotStddevPopOrderBy
  stddevSamp: ChatbotStddevSampOrderBy
  sum: ChatbotSumOrderBy
  varPop: ChatbotVarPopOrderBy
  varSamp: ChatbotVarSampOrderBy
  variance: ChatbotVarianceOrderBy
}

"""
input type for inserting array relation for remote table "chatbot"
"""
input ChatbotArrRelInsertInput {
  data: [ChatbotInsertInput!]!

  """upsert condition"""
  onConflict: ChatbotOnConflict
}

"""aggregate avg on columns"""
type ChatbotAvgFields {
  chatbotId: Float
}

"""
order by avg() on columns of table "chatbot"
"""
input ChatbotAvgOrderBy {
  chatbotId: OrderBy
}

"""
Boolean expression to filter rows from the table "chatbot". All fields are combined with a logical 'AND'.
"""
input ChatbotBoolExp {
  _and: [ChatbotBoolExp!]
  _not: ChatbotBoolExp
  _or: [ChatbotBoolExp!]
  avatar: StringComparisonExp
  categories: ChatbotCategoryBoolExp
  categoriesAggregate: ChatbotCategoryAggregateBoolExp
  chatbotId: IntComparisonExp
  complexityEnum: ComplexityEnumBoolExp
  createdBy: StringComparisonExp
  defaultComplexity: StringComparisonExp
  defaultLength: StringComparisonExp
  defaultTone: StringComparisonExp
  defaultType: StringComparisonExp
  description: StringComparisonExp
  followers: SocialFollowingBoolExp
  followersAggregate: SocialFollowingAggregateBoolExp
  lengthEnum: LengthEnumBoolExp
  metadata: ChatbotDomainBoolExp
  metadataAggregate: ChatbotDomainAggregateBoolExp
  name: StringComparisonExp
  preferences: PreferenceBoolExp
  preferencesAggregate: PreferenceAggregateBoolExp
  prompts: PromptChatbotBoolExp
  promptsAggregate: PromptChatbotAggregateBoolExp
  threads: ThreadBoolExp
  threadsAggregate: ThreadAggregateBoolExp
  toneEnum: ToneEnumBoolExp
  typeEnum: TypeEnumBoolExp
}

"""
Junction table to manage the many-to-many relationships between chatbots and their categories.
"""
type ChatbotCategory {
  """An object relationship"""
  category: Category!
  categoryId: Int!

  """An object relationship"""
  chatbot: Chatbot!
  chatbotId: Int!
}

"""
aggregated selection of "chatbot_category"
"""
type ChatbotCategoryAggregate {
  aggregate: ChatbotCategoryAggregateFields
  nodes: [ChatbotCategory!]!
}

input ChatbotCategoryAggregateBoolExp {
  count: chatbotCategoryAggregateBoolExpCount
}

"""
aggregate fields of "chatbot_category"
"""
type ChatbotCategoryAggregateFields {
  avg: ChatbotCategoryAvgFields
  count(columns: [ChatbotCategorySelectColumn!], distinct: Boolean): Int!
  max: ChatbotCategoryMaxFields
  min: ChatbotCategoryMinFields
  stddev: ChatbotCategoryStddevFields
  stddevPop: ChatbotCategoryStddevPopFields
  stddevSamp: ChatbotCategoryStddevSampFields
  sum: ChatbotCategorySumFields
  varPop: ChatbotCategoryVarPopFields
  varSamp: ChatbotCategoryVarSampFields
  variance: ChatbotCategoryVarianceFields
}

"""
order by aggregate values of table "chatbot_category"
"""
input ChatbotCategoryAggregateOrderBy {
  avg: ChatbotCategoryAvgOrderBy
  count: OrderBy
  max: ChatbotCategoryMaxOrderBy
  min: ChatbotCategoryMinOrderBy
  stddev: ChatbotCategoryStddevOrderBy
  stddevPop: ChatbotCategoryStddevPopOrderBy
  stddevSamp: ChatbotCategoryStddevSampOrderBy
  sum: ChatbotCategorySumOrderBy
  varPop: ChatbotCategoryVarPopOrderBy
  varSamp: ChatbotCategoryVarSampOrderBy
  variance: ChatbotCategoryVarianceOrderBy
}

"""
input type for inserting array relation for remote table "chatbot_category"
"""
input ChatbotCategoryArrRelInsertInput {
  data: [ChatbotCategoryInsertInput!]!

  """upsert condition"""
  onConflict: ChatbotCategoryOnConflict
}

"""aggregate avg on columns"""
type ChatbotCategoryAvgFields {
  categoryId: Float
  chatbotId: Float
}

"""
order by avg() on columns of table "chatbot_category"
"""
input ChatbotCategoryAvgOrderBy {
  categoryId: OrderBy
  chatbotId: OrderBy
}

"""
Boolean expression to filter rows from the table "chatbot_category". All fields are combined with a logical 'AND'.
"""
input ChatbotCategoryBoolExp {
  _and: [ChatbotCategoryBoolExp!]
  _not: ChatbotCategoryBoolExp
  _or: [ChatbotCategoryBoolExp!]
  category: CategoryBoolExp
  categoryId: IntComparisonExp
  chatbot: ChatbotBoolExp
  chatbotId: IntComparisonExp
}

"""
unique or primary key constraints on table "chatbot_category"
"""
enum ChatbotCategoryConstraint {
  """
  unique or primary key constraint on columns "category_id", "chatbot_id"
  """
  chatbot_category_pkey
}

"""
input type for incrementing numeric columns in table "chatbot_category"
"""
input ChatbotCategoryIncInput {
  categoryId: Int
  chatbotId: Int
}

"""
input type for inserting data into table "chatbot_category"
"""
input ChatbotCategoryInsertInput {
  category: CategoryObjRelInsertInput
  categoryId: Int
  chatbot: ChatbotObjRelInsertInput
  chatbotId: Int
}

"""aggregate max on columns"""
type ChatbotCategoryMaxFields {
  categoryId: Int
  chatbotId: Int
}

"""
order by max() on columns of table "chatbot_category"
"""
input ChatbotCategoryMaxOrderBy {
  categoryId: OrderBy
  chatbotId: OrderBy
}

"""aggregate min on columns"""
type ChatbotCategoryMinFields {
  categoryId: Int
  chatbotId: Int
}

"""
order by min() on columns of table "chatbot_category"
"""
input ChatbotCategoryMinOrderBy {
  categoryId: OrderBy
  chatbotId: OrderBy
}

"""
response of any mutation on the table "chatbot_category"
"""
type ChatbotCategoryMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [ChatbotCategory!]!
}

"""
on_conflict condition type for table "chatbot_category"
"""
input ChatbotCategoryOnConflict {
  constraint: ChatbotCategoryConstraint!
  updateColumns: [ChatbotCategoryUpdateColumn!]! = []
  where: ChatbotCategoryBoolExp
}

"""Ordering options when selecting data from "chatbot_category"."""
input ChatbotCategoryOrderBy {
  category: CategoryOrderBy
  categoryId: OrderBy
  chatbot: ChatbotOrderBy
  chatbotId: OrderBy
}

"""primary key columns input for table: chatbot_category"""
input ChatbotCategoryPkColumnsInput {
  categoryId: Int!
  chatbotId: Int!
}

"""
select columns of table "chatbot_category"
"""
enum ChatbotCategorySelectColumn {
  """column name"""
  categoryId

  """column name"""
  chatbotId
}

"""
input type for updating data in table "chatbot_category"
"""
input ChatbotCategorySetInput {
  categoryId: Int
  chatbotId: Int
}

"""aggregate stddev on columns"""
type ChatbotCategoryStddevFields {
  categoryId: Float
  chatbotId: Float
}

"""
order by stddev() on columns of table "chatbot_category"
"""
input ChatbotCategoryStddevOrderBy {
  categoryId: OrderBy
  chatbotId: OrderBy
}

"""aggregate stddevPop on columns"""
type ChatbotCategoryStddevPopFields {
  categoryId: Float
  chatbotId: Float
}

"""
order by stddevPop() on columns of table "chatbot_category"
"""
input ChatbotCategoryStddevPopOrderBy {
  categoryId: OrderBy
  chatbotId: OrderBy
}

"""aggregate stddevSamp on columns"""
type ChatbotCategoryStddevSampFields {
  categoryId: Float
  chatbotId: Float
}

"""
order by stddevSamp() on columns of table "chatbot_category"
"""
input ChatbotCategoryStddevSampOrderBy {
  categoryId: OrderBy
  chatbotId: OrderBy
}

"""
Streaming cursor of the table "chatbot_category"
"""
input ChatbotCategoryStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ChatbotCategoryStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ChatbotCategoryStreamCursorValueInput {
  categoryId: Int
  chatbotId: Int
}

"""aggregate sum on columns"""
type ChatbotCategorySumFields {
  categoryId: Int
  chatbotId: Int
}

"""
order by sum() on columns of table "chatbot_category"
"""
input ChatbotCategorySumOrderBy {
  categoryId: OrderBy
  chatbotId: OrderBy
}

"""
update columns of table "chatbot_category"
"""
enum ChatbotCategoryUpdateColumn {
  """column name"""
  categoryId

  """column name"""
  chatbotId
}

input ChatbotCategoryUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: ChatbotCategoryIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: ChatbotCategorySetInput

  """filter the rows which have to be updated"""
  where: ChatbotCategoryBoolExp!
}

"""aggregate varPop on columns"""
type ChatbotCategoryVarPopFields {
  categoryId: Float
  chatbotId: Float
}

"""
order by varPop() on columns of table "chatbot_category"
"""
input ChatbotCategoryVarPopOrderBy {
  categoryId: OrderBy
  chatbotId: OrderBy
}

"""aggregate varSamp on columns"""
type ChatbotCategoryVarSampFields {
  categoryId: Float
  chatbotId: Float
}

"""
order by varSamp() on columns of table "chatbot_category"
"""
input ChatbotCategoryVarSampOrderBy {
  categoryId: OrderBy
  chatbotId: OrderBy
}

"""aggregate variance on columns"""
type ChatbotCategoryVarianceFields {
  categoryId: Float
  chatbotId: Float
}

"""
order by variance() on columns of table "chatbot_category"
"""
input ChatbotCategoryVarianceOrderBy {
  categoryId: OrderBy
  chatbotId: OrderBy
}

"""
unique or primary key constraints on table "chatbot"
"""
enum ChatbotConstraint {
  """
  unique or primary key constraint on columns "name"
  """
  chatbot_name_key

  """
  unique or primary key constraint on columns "chatbot_id"
  """
  chatbot_pkey
}

"""Junction table to track domains and chatbots relationships."""
type ChatbotDomain {
  """An object relationship"""
  chatbot: Chatbot!
  chatbotId: Int!

  """An object relationship"""
  domain: DomainEnum!
  domainName: String!
}

"""
aggregated selection of "chatbot_domain"
"""
type ChatbotDomainAggregate {
  aggregate: ChatbotDomainAggregateFields
  nodes: [ChatbotDomain!]!
}

input ChatbotDomainAggregateBoolExp {
  count: chatbotDomainAggregateBoolExpCount
}

"""
aggregate fields of "chatbot_domain"
"""
type ChatbotDomainAggregateFields {
  avg: ChatbotDomainAvgFields
  count(columns: [ChatbotDomainSelectColumn!], distinct: Boolean): Int!
  max: ChatbotDomainMaxFields
  min: ChatbotDomainMinFields
  stddev: ChatbotDomainStddevFields
  stddevPop: ChatbotDomainStddevPopFields
  stddevSamp: ChatbotDomainStddevSampFields
  sum: ChatbotDomainSumFields
  varPop: ChatbotDomainVarPopFields
  varSamp: ChatbotDomainVarSampFields
  variance: ChatbotDomainVarianceFields
}

"""
order by aggregate values of table "chatbot_domain"
"""
input ChatbotDomainAggregateOrderBy {
  avg: ChatbotDomainAvgOrderBy
  count: OrderBy
  max: ChatbotDomainMaxOrderBy
  min: ChatbotDomainMinOrderBy
  stddev: ChatbotDomainStddevOrderBy
  stddevPop: ChatbotDomainStddevPopOrderBy
  stddevSamp: ChatbotDomainStddevSampOrderBy
  sum: ChatbotDomainSumOrderBy
  varPop: ChatbotDomainVarPopOrderBy
  varSamp: ChatbotDomainVarSampOrderBy
  variance: ChatbotDomainVarianceOrderBy
}

"""
input type for inserting array relation for remote table "chatbot_domain"
"""
input ChatbotDomainArrRelInsertInput {
  data: [ChatbotDomainInsertInput!]!

  """upsert condition"""
  onConflict: ChatbotDomainOnConflict
}

"""aggregate avg on columns"""
type ChatbotDomainAvgFields {
  chatbotId: Float
}

"""
order by avg() on columns of table "chatbot_domain"
"""
input ChatbotDomainAvgOrderBy {
  chatbotId: OrderBy
}

"""
Boolean expression to filter rows from the table "chatbot_domain". All fields are combined with a logical 'AND'.
"""
input ChatbotDomainBoolExp {
  _and: [ChatbotDomainBoolExp!]
  _not: ChatbotDomainBoolExp
  _or: [ChatbotDomainBoolExp!]
  chatbot: ChatbotBoolExp
  chatbotId: IntComparisonExp
  domain: DomainEnumBoolExp
  domainName: StringComparisonExp
}

"""
unique or primary key constraints on table "chatbot_domain"
"""
enum ChatbotDomainConstraint {
  """
  unique or primary key constraint on columns "domain_name", "chatbot_id"
  """
  chatbot_domain_pkey
}

"""
input type for incrementing numeric columns in table "chatbot_domain"
"""
input ChatbotDomainIncInput {
  chatbotId: Int
}

"""
input type for inserting data into table "chatbot_domain"
"""
input ChatbotDomainInsertInput {
  chatbot: ChatbotObjRelInsertInput
  chatbotId: Int
  domain: DomainEnumObjRelInsertInput
  domainName: String
}

"""aggregate max on columns"""
type ChatbotDomainMaxFields {
  chatbotId: Int
  domainName: String
}

"""
order by max() on columns of table "chatbot_domain"
"""
input ChatbotDomainMaxOrderBy {
  chatbotId: OrderBy
  domainName: OrderBy
}

"""aggregate min on columns"""
type ChatbotDomainMinFields {
  chatbotId: Int
  domainName: String
}

"""
order by min() on columns of table "chatbot_domain"
"""
input ChatbotDomainMinOrderBy {
  chatbotId: OrderBy
  domainName: OrderBy
}

"""
response of any mutation on the table "chatbot_domain"
"""
type ChatbotDomainMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [ChatbotDomain!]!
}

"""
on_conflict condition type for table "chatbot_domain"
"""
input ChatbotDomainOnConflict {
  constraint: ChatbotDomainConstraint!
  updateColumns: [ChatbotDomainUpdateColumn!]! = []
  where: ChatbotDomainBoolExp
}

"""Ordering options when selecting data from "chatbot_domain"."""
input ChatbotDomainOrderBy {
  chatbot: ChatbotOrderBy
  chatbotId: OrderBy
  domain: DomainEnumOrderBy
  domainName: OrderBy
}

"""primary key columns input for table: chatbot_domain"""
input ChatbotDomainPkColumnsInput {
  chatbotId: Int!
  domainName: String!
}

"""
select columns of table "chatbot_domain"
"""
enum ChatbotDomainSelectColumn {
  """column name"""
  chatbotId

  """column name"""
  domainName
}

"""
input type for updating data in table "chatbot_domain"
"""
input ChatbotDomainSetInput {
  chatbotId: Int
  domainName: String
}

"""aggregate stddev on columns"""
type ChatbotDomainStddevFields {
  chatbotId: Float
}

"""
order by stddev() on columns of table "chatbot_domain"
"""
input ChatbotDomainStddevOrderBy {
  chatbotId: OrderBy
}

"""aggregate stddevPop on columns"""
type ChatbotDomainStddevPopFields {
  chatbotId: Float
}

"""
order by stddevPop() on columns of table "chatbot_domain"
"""
input ChatbotDomainStddevPopOrderBy {
  chatbotId: OrderBy
}

"""aggregate stddevSamp on columns"""
type ChatbotDomainStddevSampFields {
  chatbotId: Float
}

"""
order by stddevSamp() on columns of table "chatbot_domain"
"""
input ChatbotDomainStddevSampOrderBy {
  chatbotId: OrderBy
}

"""
Streaming cursor of the table "chatbot_domain"
"""
input ChatbotDomainStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ChatbotDomainStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ChatbotDomainStreamCursorValueInput {
  chatbotId: Int
  domainName: String
}

"""aggregate sum on columns"""
type ChatbotDomainSumFields {
  chatbotId: Int
}

"""
order by sum() on columns of table "chatbot_domain"
"""
input ChatbotDomainSumOrderBy {
  chatbotId: OrderBy
}

"""
update columns of table "chatbot_domain"
"""
enum ChatbotDomainUpdateColumn {
  """column name"""
  chatbotId

  """column name"""
  domainName
}

input ChatbotDomainUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: ChatbotDomainIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: ChatbotDomainSetInput

  """filter the rows which have to be updated"""
  where: ChatbotDomainBoolExp!
}

"""aggregate varPop on columns"""
type ChatbotDomainVarPopFields {
  chatbotId: Float
}

"""
order by varPop() on columns of table "chatbot_domain"
"""
input ChatbotDomainVarPopOrderBy {
  chatbotId: OrderBy
}

"""aggregate varSamp on columns"""
type ChatbotDomainVarSampFields {
  chatbotId: Float
}

"""
order by varSamp() on columns of table "chatbot_domain"
"""
input ChatbotDomainVarSampOrderBy {
  chatbotId: OrderBy
}

"""aggregate variance on columns"""
type ChatbotDomainVarianceFields {
  chatbotId: Float
}

"""
order by variance() on columns of table "chatbot_domain"
"""
input ChatbotDomainVarianceOrderBy {
  chatbotId: OrderBy
}

"""
input type for incrementing numeric columns in table "chatbot"
"""
input ChatbotIncInput {
  chatbotId: Int
}

"""
input type for inserting data into table "chatbot"
"""
input ChatbotInsertInput {
  avatar: String
  categories: ChatbotCategoryArrRelInsertInput
  chatbotId: Int
  complexityEnum: ComplexityEnumObjRelInsertInput
  createdBy: String
  defaultComplexity: String
  defaultLength: String
  defaultTone: String
  defaultType: String
  description: String
  followers: SocialFollowingArrRelInsertInput
  lengthEnum: LengthEnumObjRelInsertInput
  metadata: ChatbotDomainArrRelInsertInput
  name: String
  preferences: PreferenceArrRelInsertInput
  prompts: PromptChatbotArrRelInsertInput
  threads: ThreadArrRelInsertInput
  toneEnum: ToneEnumObjRelInsertInput
  typeEnum: TypeEnumObjRelInsertInput
}

"""aggregate max on columns"""
type ChatbotMaxFields {
  avatar: String
  chatbotId: Int
  createdBy: String
  defaultComplexity: String
  defaultLength: String
  defaultTone: String
  defaultType: String
  description: String
  name: String
}

"""
order by max() on columns of table "chatbot"
"""
input ChatbotMaxOrderBy {
  avatar: OrderBy
  chatbotId: OrderBy
  createdBy: OrderBy
  defaultComplexity: OrderBy
  defaultLength: OrderBy
  defaultTone: OrderBy
  defaultType: OrderBy
  description: OrderBy
  name: OrderBy
}

"""aggregate min on columns"""
type ChatbotMinFields {
  avatar: String
  chatbotId: Int
  createdBy: String
  defaultComplexity: String
  defaultLength: String
  defaultTone: String
  defaultType: String
  description: String
  name: String
}

"""
order by min() on columns of table "chatbot"
"""
input ChatbotMinOrderBy {
  avatar: OrderBy
  chatbotId: OrderBy
  createdBy: OrderBy
  defaultComplexity: OrderBy
  defaultLength: OrderBy
  defaultTone: OrderBy
  defaultType: OrderBy
  description: OrderBy
  name: OrderBy
}

"""
response of any mutation on the table "chatbot"
"""
type ChatbotMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Chatbot!]!
}

"""
input type for inserting object relation for remote table "chatbot"
"""
input ChatbotObjRelInsertInput {
  data: ChatbotInsertInput!

  """upsert condition"""
  onConflict: ChatbotOnConflict
}

"""
on_conflict condition type for table "chatbot"
"""
input ChatbotOnConflict {
  constraint: ChatbotConstraint!
  updateColumns: [ChatbotUpdateColumn!]! = []
  where: ChatbotBoolExp
}

"""Ordering options when selecting data from "chatbot"."""
input ChatbotOrderBy {
  avatar: OrderBy
  categoriesAggregate: ChatbotCategoryAggregateOrderBy
  chatbotId: OrderBy
  complexityEnum: ComplexityEnumOrderBy
  createdBy: OrderBy
  defaultComplexity: OrderBy
  defaultLength: OrderBy
  defaultTone: OrderBy
  defaultType: OrderBy
  description: OrderBy
  followersAggregate: SocialFollowingAggregateOrderBy
  lengthEnum: LengthEnumOrderBy
  metadataAggregate: ChatbotDomainAggregateOrderBy
  name: OrderBy
  preferencesAggregate: PreferenceAggregateOrderBy
  promptsAggregate: PromptChatbotAggregateOrderBy
  threadsAggregate: ThreadAggregateOrderBy
  toneEnum: ToneEnumOrderBy
  typeEnum: TypeEnumOrderBy
}

"""primary key columns input for table: chatbot"""
input ChatbotPkColumnsInput {
  chatbotId: Int!
}

"""
select columns of table "chatbot"
"""
enum ChatbotSelectColumn {
  """column name"""
  avatar

  """column name"""
  chatbotId

  """column name"""
  createdBy

  """column name"""
  defaultComplexity

  """column name"""
  defaultLength

  """column name"""
  defaultTone

  """column name"""
  defaultType

  """column name"""
  description

  """column name"""
  name
}

"""
input type for updating data in table "chatbot"
"""
input ChatbotSetInput {
  avatar: String
  chatbotId: Int
  createdBy: String
  defaultComplexity: String
  defaultLength: String
  defaultTone: String
  defaultType: String
  description: String
  name: String
}

"""aggregate stddev on columns"""
type ChatbotStddevFields {
  chatbotId: Float
}

"""
order by stddev() on columns of table "chatbot"
"""
input ChatbotStddevOrderBy {
  chatbotId: OrderBy
}

"""aggregate stddevPop on columns"""
type ChatbotStddevPopFields {
  chatbotId: Float
}

"""
order by stddevPop() on columns of table "chatbot"
"""
input ChatbotStddevPopOrderBy {
  chatbotId: OrderBy
}

"""aggregate stddevSamp on columns"""
type ChatbotStddevSampFields {
  chatbotId: Float
}

"""
order by stddevSamp() on columns of table "chatbot"
"""
input ChatbotStddevSampOrderBy {
  chatbotId: OrderBy
}

"""
Streaming cursor of the table "chatbot"
"""
input ChatbotStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ChatbotStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ChatbotStreamCursorValueInput {
  avatar: String
  chatbotId: Int
  createdBy: String
  defaultComplexity: String
  defaultLength: String
  defaultTone: String
  defaultType: String
  description: String
  name: String
}

"""aggregate sum on columns"""
type ChatbotSumFields {
  chatbotId: Int
}

"""
order by sum() on columns of table "chatbot"
"""
input ChatbotSumOrderBy {
  chatbotId: OrderBy
}

"""
update columns of table "chatbot"
"""
enum ChatbotUpdateColumn {
  """column name"""
  avatar

  """column name"""
  chatbotId

  """column name"""
  createdBy

  """column name"""
  defaultComplexity

  """column name"""
  defaultLength

  """column name"""
  defaultTone

  """column name"""
  defaultType

  """column name"""
  description

  """column name"""
  name
}

input ChatbotUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: ChatbotIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: ChatbotSetInput

  """filter the rows which have to be updated"""
  where: ChatbotBoolExp!
}

"""aggregate varPop on columns"""
type ChatbotVarPopFields {
  chatbotId: Float
}

"""
order by varPop() on columns of table "chatbot"
"""
input ChatbotVarPopOrderBy {
  chatbotId: OrderBy
}

"""aggregate varSamp on columns"""
type ChatbotVarSampFields {
  chatbotId: Float
}

"""
order by varSamp() on columns of table "chatbot"
"""
input ChatbotVarSampOrderBy {
  chatbotId: OrderBy
}

"""aggregate variance on columns"""
type ChatbotVarianceFields {
  chatbotId: Float
}

"""
order by variance() on columns of table "chatbot"
"""
input ChatbotVarianceOrderBy {
  chatbotId: OrderBy
}

"""
columns and relationships of "complexity_enum"
"""
type ComplexityEnum {
  """An array relationship"""
  chatbots(
    """distinct select on columns"""
    distinctOn: [ChatbotSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotOrderBy!]

    """filter the rows returned"""
    where: ChatbotBoolExp
  ): [Chatbot!]!

  """An aggregate relationship"""
  chatbotsAggregate(
    """distinct select on columns"""
    distinctOn: [ChatbotSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotOrderBy!]

    """filter the rows returned"""
    where: ChatbotBoolExp
  ): ChatbotAggregate!

  """An array relationship"""
  preferences(
    """distinct select on columns"""
    distinctOn: [PreferenceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PreferenceOrderBy!]

    """filter the rows returned"""
    where: PreferenceBoolExp
  ): [Preference!]!

  """An aggregate relationship"""
  preferencesAggregate(
    """distinct select on columns"""
    distinctOn: [PreferenceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PreferenceOrderBy!]

    """filter the rows returned"""
    where: PreferenceBoolExp
  ): PreferenceAggregate!
  prompt: String!
  value: String!
}

"""
aggregated selection of "complexity_enum"
"""
type ComplexityEnumAggregate {
  aggregate: ComplexityEnumAggregateFields
  nodes: [ComplexityEnum!]!
}

"""
aggregate fields of "complexity_enum"
"""
type ComplexityEnumAggregateFields {
  count(columns: [ComplexityEnumSelectColumn!], distinct: Boolean): Int!
  max: ComplexityEnumMaxFields
  min: ComplexityEnumMinFields
}

"""
Boolean expression to filter rows from the table "complexity_enum". All fields are combined with a logical 'AND'.
"""
input ComplexityEnumBoolExp {
  _and: [ComplexityEnumBoolExp!]
  _not: ComplexityEnumBoolExp
  _or: [ComplexityEnumBoolExp!]
  chatbots: ChatbotBoolExp
  chatbotsAggregate: ChatbotAggregateBoolExp
  preferences: PreferenceBoolExp
  preferencesAggregate: PreferenceAggregateBoolExp
  prompt: StringComparisonExp
  value: StringComparisonExp
}

"""
unique or primary key constraints on table "complexity_enum"
"""
enum ComplexityEnumConstraint {
  """
  unique or primary key constraint on columns "value"
  """
  default_complexity_enum_pkey
}

"""
input type for inserting data into table "complexity_enum"
"""
input ComplexityEnumInsertInput {
  chatbots: ChatbotArrRelInsertInput
  preferences: PreferenceArrRelInsertInput
  prompt: String
  value: String
}

"""aggregate max on columns"""
type ComplexityEnumMaxFields {
  prompt: String
  value: String
}

"""aggregate min on columns"""
type ComplexityEnumMinFields {
  prompt: String
  value: String
}

"""
response of any mutation on the table "complexity_enum"
"""
type ComplexityEnumMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [ComplexityEnum!]!
}

"""
input type for inserting object relation for remote table "complexity_enum"
"""
input ComplexityEnumObjRelInsertInput {
  data: ComplexityEnumInsertInput!

  """upsert condition"""
  onConflict: ComplexityEnumOnConflict
}

"""
on_conflict condition type for table "complexity_enum"
"""
input ComplexityEnumOnConflict {
  constraint: ComplexityEnumConstraint!
  updateColumns: [ComplexityEnumUpdateColumn!]! = []
  where: ComplexityEnumBoolExp
}

"""Ordering options when selecting data from "complexity_enum"."""
input ComplexityEnumOrderBy {
  chatbotsAggregate: ChatbotAggregateOrderBy
  preferencesAggregate: PreferenceAggregateOrderBy
  prompt: OrderBy
  value: OrderBy
}

"""primary key columns input for table: complexity_enum"""
input ComplexityEnumPkColumnsInput {
  value: String!
}

"""
select columns of table "complexity_enum"
"""
enum ComplexityEnumSelectColumn {
  """column name"""
  prompt

  """column name"""
  value
}

"""
input type for updating data in table "complexity_enum"
"""
input ComplexityEnumSetInput {
  prompt: String
  value: String
}

"""
Streaming cursor of the table "complexity_enum"
"""
input ComplexityEnumStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ComplexityEnumStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ComplexityEnumStreamCursorValueInput {
  prompt: String
  value: String
}

"""
update columns of table "complexity_enum"
"""
enum ComplexityEnumUpdateColumn {
  """column name"""
  prompt

  """column name"""
  value
}

input ComplexityEnumUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: ComplexityEnumSetInput

  """filter the rows which have to be updated"""
  where: ComplexityEnumBoolExp!
}

"""ordering argument of a cursor"""
enum CursorOrdering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

"""
columns and relationships of "domain_enum"
"""
type DomainEnum {
  added: timestamptz

  """An aggregate relationship"""
  categoryEnumsAggregate(
    """distinct select on columns"""
    distinctOn: [CategoryEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CategoryEnumOrderBy!]

    """filter the rows returned"""
    where: CategoryEnumBoolExp
  ): CategoryEnumAggregate!

  """An array relationship"""
  category_enums(
    """distinct select on columns"""
    distinctOn: [CategoryEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CategoryEnumOrderBy!]

    """filter the rows returned"""
    where: CategoryEnumBoolExp
  ): [CategoryEnum!]!

  """An array relationship"""
  chatbot(
    """distinct select on columns"""
    distinctOn: [ChatbotDomainSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotDomainOrderBy!]

    """filter the rows returned"""
    where: ChatbotDomainBoolExp
  ): [ChatbotDomain!]!

  """An aggregate relationship"""
  chatbotAggregate(
    """distinct select on columns"""
    distinctOn: [ChatbotDomainSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotDomainOrderBy!]

    """filter the rows returned"""
    where: ChatbotDomainBoolExp
  ): ChatbotDomainAggregate!
  name: String!

  """An aggregate relationship"""
  tagEnumsAggregate(
    """distinct select on columns"""
    distinctOn: [TagEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TagEnumOrderBy!]

    """filter the rows returned"""
    where: TagEnumBoolExp
  ): TagEnumAggregate!

  """An array relationship"""
  tag_enums(
    """distinct select on columns"""
    distinctOn: [TagEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TagEnumOrderBy!]

    """filter the rows returned"""
    where: TagEnumBoolExp
  ): [TagEnum!]!
}

"""
aggregated selection of "domain_enum"
"""
type DomainEnumAggregate {
  aggregate: DomainEnumAggregateFields
  nodes: [DomainEnum!]!
}

"""
aggregate fields of "domain_enum"
"""
type DomainEnumAggregateFields {
  count(columns: [DomainEnumSelectColumn!], distinct: Boolean): Int!
  max: DomainEnumMaxFields
  min: DomainEnumMinFields
}

"""
Boolean expression to filter rows from the table "domain_enum". All fields are combined with a logical 'AND'.
"""
input DomainEnumBoolExp {
  _and: [DomainEnumBoolExp!]
  _not: DomainEnumBoolExp
  _or: [DomainEnumBoolExp!]
  added: TimestamptzComparisonExp
  category_enums: CategoryEnumBoolExp
  category_enumsAggregate: CategoryEnumAggregateBoolExp
  chatbot: ChatbotDomainBoolExp
  chatbotAggregate: ChatbotDomainAggregateBoolExp
  name: StringComparisonExp
  tag_enums: TagEnumBoolExp
  tag_enumsAggregate: TagEnumAggregateBoolExp
}

"""
unique or primary key constraints on table "domain_enum"
"""
enum DomainEnumConstraint {
  """
  unique or primary key constraint on columns "name"
  """
  domain_enum_pkey
}

"""
input type for inserting data into table "domain_enum"
"""
input DomainEnumInsertInput {
  added: timestamptz
  category_enums: CategoryEnumArrRelInsertInput
  chatbot: ChatbotDomainArrRelInsertInput
  name: String
  tag_enums: TagEnumArrRelInsertInput
}

"""aggregate max on columns"""
type DomainEnumMaxFields {
  added: timestamptz
  name: String
}

"""aggregate min on columns"""
type DomainEnumMinFields {
  added: timestamptz
  name: String
}

"""
response of any mutation on the table "domain_enum"
"""
type DomainEnumMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [DomainEnum!]!
}

"""
input type for inserting object relation for remote table "domain_enum"
"""
input DomainEnumObjRelInsertInput {
  data: DomainEnumInsertInput!

  """upsert condition"""
  onConflict: DomainEnumOnConflict
}

"""
on_conflict condition type for table "domain_enum"
"""
input DomainEnumOnConflict {
  constraint: DomainEnumConstraint!
  updateColumns: [DomainEnumUpdateColumn!]! = []
  where: DomainEnumBoolExp
}

"""Ordering options when selecting data from "domain_enum"."""
input DomainEnumOrderBy {
  added: OrderBy
  category_enumsAggregate: CategoryEnumAggregateOrderBy
  chatbotAggregate: ChatbotDomainAggregateOrderBy
  name: OrderBy
  tag_enumsAggregate: TagEnumAggregateOrderBy
}

"""primary key columns input for table: domain_enum"""
input DomainEnumPkColumnsInput {
  name: String!
}

"""
select columns of table "domain_enum"
"""
enum DomainEnumSelectColumn {
  """column name"""
  added

  """column name"""
  name
}

"""
input type for updating data in table "domain_enum"
"""
input DomainEnumSetInput {
  added: timestamptz
  name: String
}

"""
Streaming cursor of the table "domain_enum"
"""
input DomainEnumStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: DomainEnumStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input DomainEnumStreamCursorValueInput {
  added: timestamptz
  name: String
}

"""
update columns of table "domain_enum"
"""
enum DomainEnumUpdateColumn {
  """column name"""
  added

  """column name"""
  name
}

input DomainEnumUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: DomainEnumSetInput

  """filter the rows which have to be updated"""
  where: DomainEnumBoolExp!
}

"""
columns and relationships of "example"
"""
type Example {
  added: timestamptz!
  category: String!
  domain: String!
  exampleId: uuid!
  metadata(
    """JSON select path"""
    path: String
  ): jsonb!
  prompt: String!
  response: String!
  subcategory: String!

  """An object relationship"""
  subcategoryEnumBySubcategoryCategoryDomain: SubcategoryEnum

  """An object relationship"""
  subcategory_enum: SubcategoryEnum!
  tags: [uuid!]!
}

"""
aggregated selection of "example"
"""
type ExampleAggregate {
  aggregate: ExampleAggregateFields
  nodes: [Example!]!
}

input ExampleAggregateBoolExp {
  count: exampleAggregateBoolExpCount
}

"""
aggregate fields of "example"
"""
type ExampleAggregateFields {
  count(columns: [ExampleSelectColumn!], distinct: Boolean): Int!
  max: ExampleMaxFields
  min: ExampleMinFields
}

"""
order by aggregate values of table "example"
"""
input ExampleAggregateOrderBy {
  count: OrderBy
  max: ExampleMaxOrderBy
  min: ExampleMinOrderBy
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input ExampleAppendInput {
  metadata: jsonb
}

"""
input type for inserting array relation for remote table "example"
"""
input ExampleArrRelInsertInput {
  data: [ExampleInsertInput!]!

  """upsert condition"""
  onConflict: ExampleOnConflict
}

"""
Boolean expression to filter rows from the table "example". All fields are combined with a logical 'AND'.
"""
input ExampleBoolExp {
  _and: [ExampleBoolExp!]
  _not: ExampleBoolExp
  _or: [ExampleBoolExp!]
  added: TimestamptzComparisonExp
  category: StringComparisonExp
  domain: StringComparisonExp
  exampleId: UuidComparisonExp
  metadata: JsonbComparisonExp
  prompt: StringComparisonExp
  response: StringComparisonExp
  subcategory: StringComparisonExp
  subcategoryEnumBySubcategoryCategoryDomain: SubcategoryEnumBoolExp
  subcategory_enum: SubcategoryEnumBoolExp
  tags: UuidArrayComparisonExp
}

"""
unique or primary key constraints on table "example"
"""
enum ExampleConstraint {
  """
  unique or primary key constraint on columns "example_id"
  """
  example_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input ExampleDeleteAtPathInput {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input ExampleDeleteElemInput {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input ExampleDeleteKeyInput {
  metadata: String
}

"""
input type for inserting data into table "example"
"""
input ExampleInsertInput {
  added: timestamptz
  category: String
  domain: String
  exampleId: uuid
  metadata: jsonb
  prompt: String
  response: String
  subcategory: String
  subcategoryEnumBySubcategoryCategoryDomain: SubcategoryEnumObjRelInsertInput
  subcategory_enum: SubcategoryEnumObjRelInsertInput
  tags: [uuid!]
}

"""aggregate max on columns"""
type ExampleMaxFields {
  added: timestamptz
  category: String
  domain: String
  exampleId: uuid
  prompt: String
  response: String
  subcategory: String
  tags: [uuid!]
}

"""
order by max() on columns of table "example"
"""
input ExampleMaxOrderBy {
  added: OrderBy
  category: OrderBy
  domain: OrderBy
  exampleId: OrderBy
  prompt: OrderBy
  response: OrderBy
  subcategory: OrderBy
  tags: OrderBy
}

"""aggregate min on columns"""
type ExampleMinFields {
  added: timestamptz
  category: String
  domain: String
  exampleId: uuid
  prompt: String
  response: String
  subcategory: String
  tags: [uuid!]
}

"""
order by min() on columns of table "example"
"""
input ExampleMinOrderBy {
  added: OrderBy
  category: OrderBy
  domain: OrderBy
  exampleId: OrderBy
  prompt: OrderBy
  response: OrderBy
  subcategory: OrderBy
  tags: OrderBy
}

"""
response of any mutation on the table "example"
"""
type ExampleMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Example!]!
}

"""
on_conflict condition type for table "example"
"""
input ExampleOnConflict {
  constraint: ExampleConstraint!
  updateColumns: [ExampleUpdateColumn!]! = []
  where: ExampleBoolExp
}

"""Ordering options when selecting data from "example"."""
input ExampleOrderBy {
  added: OrderBy
  category: OrderBy
  domain: OrderBy
  exampleId: OrderBy
  metadata: OrderBy
  prompt: OrderBy
  response: OrderBy
  subcategory: OrderBy
  subcategoryEnumBySubcategoryCategoryDomain: SubcategoryEnumOrderBy
  subcategory_enum: SubcategoryEnumOrderBy
  tags: OrderBy
}

"""primary key columns input for table: example"""
input ExamplePkColumnsInput {
  exampleId: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input ExamplePrependInput {
  metadata: jsonb
}

"""
select columns of table "example"
"""
enum ExampleSelectColumn {
  """column name"""
  added

  """column name"""
  category

  """column name"""
  domain

  """column name"""
  exampleId

  """column name"""
  metadata

  """column name"""
  prompt

  """column name"""
  response

  """column name"""
  subcategory

  """column name"""
  tags
}

"""
input type for updating data in table "example"
"""
input ExampleSetInput {
  added: timestamptz
  category: String
  domain: String
  exampleId: uuid
  metadata: jsonb
  prompt: String
  response: String
  subcategory: String
  tags: [uuid!]
}

"""
Streaming cursor of the table "example"
"""
input ExampleStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ExampleStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ExampleStreamCursorValueInput {
  added: timestamptz
  category: String
  domain: String
  exampleId: uuid
  metadata: jsonb
  prompt: String
  response: String
  subcategory: String
  tags: [uuid!]
}

"""
update columns of table "example"
"""
enum ExampleUpdateColumn {
  """column name"""
  added

  """column name"""
  category

  """column name"""
  domain

  """column name"""
  exampleId

  """column name"""
  metadata

  """column name"""
  prompt

  """column name"""
  response

  """column name"""
  subcategory

  """column name"""
  tags
}

input ExampleUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: ExampleAppendInput

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: ExampleDeleteAtPathInput

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: ExampleDeleteElemInput

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: ExampleDeleteKeyInput

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: ExamplePrependInput

  """sets the columns of the filtered rows to the given values"""
  _set: ExampleSetInput

  """filter the rows which have to be updated"""
  where: ExampleBoolExp!
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input IntComparisonExp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _isNull: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

input JsonbCastExp {
  String: StringComparisonExp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input JsonbComparisonExp {
  _cast: JsonbCastExp

  """is the column contained in the given json value"""
  _containedIn: jsonb

  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """does the string exist as a top-level key in the column"""
  _hasKey: String

  """do all of these strings exist as top-level keys in the column"""
  _hasKeysAll: [String!]

  """do any of these strings exist as top-level keys in the column"""
  _hasKeysAny: [String!]
  _in: [jsonb!]
  _isNull: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""
columns and relationships of "length_enum"
"""
type LengthEnum {
  """An array relationship"""
  chatbots(
    """distinct select on columns"""
    distinctOn: [ChatbotSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotOrderBy!]

    """filter the rows returned"""
    where: ChatbotBoolExp
  ): [Chatbot!]!

  """An aggregate relationship"""
  chatbotsAggregate(
    """distinct select on columns"""
    distinctOn: [ChatbotSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotOrderBy!]

    """filter the rows returned"""
    where: ChatbotBoolExp
  ): ChatbotAggregate!

  """An array relationship"""
  preferences(
    """distinct select on columns"""
    distinctOn: [PreferenceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PreferenceOrderBy!]

    """filter the rows returned"""
    where: PreferenceBoolExp
  ): [Preference!]!

  """An aggregate relationship"""
  preferencesAggregate(
    """distinct select on columns"""
    distinctOn: [PreferenceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PreferenceOrderBy!]

    """filter the rows returned"""
    where: PreferenceBoolExp
  ): PreferenceAggregate!
  prompt: String!
  value: String!
}

"""
aggregated selection of "length_enum"
"""
type LengthEnumAggregate {
  aggregate: LengthEnumAggregateFields
  nodes: [LengthEnum!]!
}

"""
aggregate fields of "length_enum"
"""
type LengthEnumAggregateFields {
  count(columns: [LengthEnumSelectColumn!], distinct: Boolean): Int!
  max: LengthEnumMaxFields
  min: LengthEnumMinFields
}

"""
Boolean expression to filter rows from the table "length_enum". All fields are combined with a logical 'AND'.
"""
input LengthEnumBoolExp {
  _and: [LengthEnumBoolExp!]
  _not: LengthEnumBoolExp
  _or: [LengthEnumBoolExp!]
  chatbots: ChatbotBoolExp
  chatbotsAggregate: ChatbotAggregateBoolExp
  preferences: PreferenceBoolExp
  preferencesAggregate: PreferenceAggregateBoolExp
  prompt: StringComparisonExp
  value: StringComparisonExp
}

"""
unique or primary key constraints on table "length_enum"
"""
enum LengthEnumConstraint {
  """
  unique or primary key constraint on columns "value"
  """
  default_length_enum_pkey
}

"""
input type for inserting data into table "length_enum"
"""
input LengthEnumInsertInput {
  chatbots: ChatbotArrRelInsertInput
  preferences: PreferenceArrRelInsertInput
  prompt: String
  value: String
}

"""aggregate max on columns"""
type LengthEnumMaxFields {
  prompt: String
  value: String
}

"""aggregate min on columns"""
type LengthEnumMinFields {
  prompt: String
  value: String
}

"""
response of any mutation on the table "length_enum"
"""
type LengthEnumMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [LengthEnum!]!
}

"""
input type for inserting object relation for remote table "length_enum"
"""
input LengthEnumObjRelInsertInput {
  data: LengthEnumInsertInput!

  """upsert condition"""
  onConflict: LengthEnumOnConflict
}

"""
on_conflict condition type for table "length_enum"
"""
input LengthEnumOnConflict {
  constraint: LengthEnumConstraint!
  updateColumns: [LengthEnumUpdateColumn!]! = []
  where: LengthEnumBoolExp
}

"""Ordering options when selecting data from "length_enum"."""
input LengthEnumOrderBy {
  chatbotsAggregate: ChatbotAggregateOrderBy
  preferencesAggregate: PreferenceAggregateOrderBy
  prompt: OrderBy
  value: OrderBy
}

"""primary key columns input for table: length_enum"""
input LengthEnumPkColumnsInput {
  value: String!
}

"""
select columns of table "length_enum"
"""
enum LengthEnumSelectColumn {
  """column name"""
  prompt

  """column name"""
  value
}

"""
input type for updating data in table "length_enum"
"""
input LengthEnumSetInput {
  prompt: String
  value: String
}

"""
Streaming cursor of the table "length_enum"
"""
input LengthEnumStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: LengthEnumStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input LengthEnumStreamCursorValueInput {
  prompt: String
  value: String
}

"""
update columns of table "length_enum"
"""
enum LengthEnumUpdateColumn {
  """column name"""
  prompt

  """column name"""
  value
}

input LengthEnumUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: LengthEnumSetInput

  """filter the rows which have to be updated"""
  where: LengthEnumBoolExp!
}

"""This table stores the messages exchanged between users and chatbots."""
type Message {
  augmentedFrom: uuid
  content: String!
  createdAt: timestamptz!
  examples(
    """JSON select path"""
    path: String
  ): jsonb

  """An object relationship"""
  message: Message
  messageId: uuid!

  """An object relationship"""
  messageTypeEnum: MessageTypeEnum!

  """An array relationship"""
  messages(
    """distinct select on columns"""
    distinctOn: [MessageSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MessageOrderBy!]

    """filter the rows returned"""
    where: MessageBoolExp
  ): [Message!]!

  """An aggregate relationship"""
  messagesAggregate(
    """distinct select on columns"""
    distinctOn: [MessageSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MessageOrderBy!]

    """filter the rows returned"""
    where: MessageBoolExp
  ): MessageAggregate!
  prompt: String
  role: String!

  """An object relationship"""
  thread: Thread
  threadId: uuid
}

"""
aggregated selection of "message"
"""
type MessageAggregate {
  aggregate: MessageAggregateFields
  nodes: [Message!]!
}

input MessageAggregateBoolExp {
  count: messageAggregateBoolExpCount
}

"""
aggregate fields of "message"
"""
type MessageAggregateFields {
  count(columns: [MessageSelectColumn!], distinct: Boolean): Int!
  max: MessageMaxFields
  min: MessageMinFields
}

"""
order by aggregate values of table "message"
"""
input MessageAggregateOrderBy {
  count: OrderBy
  max: MessageMaxOrderBy
  min: MessageMinOrderBy
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input MessageAppendInput {
  examples: jsonb
}

"""
input type for inserting array relation for remote table "message"
"""
input MessageArrRelInsertInput {
  data: [MessageInsertInput!]!

  """upsert condition"""
  onConflict: MessageOnConflict
}

"""
Boolean expression to filter rows from the table "message". All fields are combined with a logical 'AND'.
"""
input MessageBoolExp {
  _and: [MessageBoolExp!]
  _not: MessageBoolExp
  _or: [MessageBoolExp!]
  augmentedFrom: UuidComparisonExp
  content: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  examples: JsonbComparisonExp
  message: MessageBoolExp
  messageId: UuidComparisonExp
  messageTypeEnum: MessageTypeEnumBoolExp
  messages: MessageBoolExp
  messagesAggregate: MessageAggregateBoolExp
  prompt: StringComparisonExp
  role: StringComparisonExp
  thread: ThreadBoolExp
  threadId: UuidComparisonExp
}

"""
unique or primary key constraints on table "message"
"""
enum MessageConstraint {
  """
  unique or primary key constraint on columns "message_id"
  """
  message_id_key

  """
  unique or primary key constraint on columns "message_id"
  """
  message_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input MessageDeleteAtPathInput {
  examples: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input MessageDeleteElemInput {
  examples: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input MessageDeleteKeyInput {
  examples: String
}

"""
input type for inserting data into table "message"
"""
input MessageInsertInput {
  augmentedFrom: uuid
  content: String
  createdAt: timestamptz
  examples: jsonb
  message: MessageObjRelInsertInput
  messageId: uuid
  messageTypeEnum: MessageTypeEnumObjRelInsertInput
  messages: MessageArrRelInsertInput
  prompt: String
  role: String
  thread: ThreadObjRelInsertInput
  threadId: uuid
}

"""aggregate max on columns"""
type MessageMaxFields {
  augmentedFrom: uuid
  content: String
  createdAt: timestamptz
  messageId: uuid
  prompt: String
  role: String
  threadId: uuid
}

"""
order by max() on columns of table "message"
"""
input MessageMaxOrderBy {
  augmentedFrom: OrderBy
  content: OrderBy
  createdAt: OrderBy
  messageId: OrderBy
  prompt: OrderBy
  role: OrderBy
  threadId: OrderBy
}

"""aggregate min on columns"""
type MessageMinFields {
  augmentedFrom: uuid
  content: String
  createdAt: timestamptz
  messageId: uuid
  prompt: String
  role: String
  threadId: uuid
}

"""
order by min() on columns of table "message"
"""
input MessageMinOrderBy {
  augmentedFrom: OrderBy
  content: OrderBy
  createdAt: OrderBy
  messageId: OrderBy
  prompt: OrderBy
  role: OrderBy
  threadId: OrderBy
}

"""
response of any mutation on the table "message"
"""
type MessageMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Message!]!
}

"""
input type for inserting object relation for remote table "message"
"""
input MessageObjRelInsertInput {
  data: MessageInsertInput!

  """upsert condition"""
  onConflict: MessageOnConflict
}

"""
on_conflict condition type for table "message"
"""
input MessageOnConflict {
  constraint: MessageConstraint!
  updateColumns: [MessageUpdateColumn!]! = []
  where: MessageBoolExp
}

"""Ordering options when selecting data from "message"."""
input MessageOrderBy {
  augmentedFrom: OrderBy
  content: OrderBy
  createdAt: OrderBy
  examples: OrderBy
  message: MessageOrderBy
  messageId: OrderBy
  messageTypeEnum: MessageTypeEnumOrderBy
  messagesAggregate: MessageAggregateOrderBy
  prompt: OrderBy
  role: OrderBy
  thread: ThreadOrderBy
  threadId: OrderBy
}

"""primary key columns input for table: message"""
input MessagePkColumnsInput {
  messageId: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input MessagePrependInput {
  examples: jsonb
}

"""
select columns of table "message"
"""
enum MessageSelectColumn {
  """column name"""
  augmentedFrom

  """column name"""
  content

  """column name"""
  createdAt

  """column name"""
  examples

  """column name"""
  messageId

  """column name"""
  prompt

  """column name"""
  role

  """column name"""
  threadId
}

"""
input type for updating data in table "message"
"""
input MessageSetInput {
  augmentedFrom: uuid
  content: String
  createdAt: timestamptz
  examples: jsonb
  messageId: uuid
  prompt: String
  role: String
  threadId: uuid
}

"""
Streaming cursor of the table "message"
"""
input MessageStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: MessageStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input MessageStreamCursorValueInput {
  augmentedFrom: uuid
  content: String
  createdAt: timestamptz
  examples: jsonb
  messageId: uuid
  prompt: String
  role: String
  threadId: uuid
}

"""
columns and relationships of "message_type_enum"
"""
type MessageTypeEnum {
  """An array relationship"""
  messages(
    """distinct select on columns"""
    distinctOn: [MessageSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MessageOrderBy!]

    """filter the rows returned"""
    where: MessageBoolExp
  ): [Message!]!

  """An aggregate relationship"""
  messagesAggregate(
    """distinct select on columns"""
    distinctOn: [MessageSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MessageOrderBy!]

    """filter the rows returned"""
    where: MessageBoolExp
  ): MessageAggregate!
  value: String!
}

"""
aggregated selection of "message_type_enum"
"""
type MessageTypeEnumAggregate {
  aggregate: MessageTypeEnumAggregateFields
  nodes: [MessageTypeEnum!]!
}

"""
aggregate fields of "message_type_enum"
"""
type MessageTypeEnumAggregateFields {
  count(columns: [MessageTypeEnumSelectColumn!], distinct: Boolean): Int!
  max: MessageTypeEnumMaxFields
  min: MessageTypeEnumMinFields
}

"""
Boolean expression to filter rows from the table "message_type_enum". All fields are combined with a logical 'AND'.
"""
input MessageTypeEnumBoolExp {
  _and: [MessageTypeEnumBoolExp!]
  _not: MessageTypeEnumBoolExp
  _or: [MessageTypeEnumBoolExp!]
  messages: MessageBoolExp
  messagesAggregate: MessageAggregateBoolExp
  value: StringComparisonExp
}

"""
unique or primary key constraints on table "message_type_enum"
"""
enum MessageTypeEnumConstraint {
  """
  unique or primary key constraint on columns "value"
  """
  message_type_enum_pkey
}

"""
input type for inserting data into table "message_type_enum"
"""
input MessageTypeEnumInsertInput {
  messages: MessageArrRelInsertInput
  value: String
}

"""aggregate max on columns"""
type MessageTypeEnumMaxFields {
  value: String
}

"""aggregate min on columns"""
type MessageTypeEnumMinFields {
  value: String
}

"""
response of any mutation on the table "message_type_enum"
"""
type MessageTypeEnumMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [MessageTypeEnum!]!
}

"""
input type for inserting object relation for remote table "message_type_enum"
"""
input MessageTypeEnumObjRelInsertInput {
  data: MessageTypeEnumInsertInput!

  """upsert condition"""
  onConflict: MessageTypeEnumOnConflict
}

"""
on_conflict condition type for table "message_type_enum"
"""
input MessageTypeEnumOnConflict {
  constraint: MessageTypeEnumConstraint!
  updateColumns: [MessageTypeEnumUpdateColumn!]! = []
  where: MessageTypeEnumBoolExp
}

"""Ordering options when selecting data from "message_type_enum"."""
input MessageTypeEnumOrderBy {
  messagesAggregate: MessageAggregateOrderBy
  value: OrderBy
}

"""primary key columns input for table: message_type_enum"""
input MessageTypeEnumPkColumnsInput {
  value: String!
}

"""
select columns of table "message_type_enum"
"""
enum MessageTypeEnumSelectColumn {
  """column name"""
  value
}

"""
input type for updating data in table "message_type_enum"
"""
input MessageTypeEnumSetInput {
  value: String
}

"""
Streaming cursor of the table "message_type_enum"
"""
input MessageTypeEnumStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: MessageTypeEnumStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input MessageTypeEnumStreamCursorValueInput {
  value: String
}

"""
update columns of table "message_type_enum"
"""
enum MessageTypeEnumUpdateColumn {
  """column name"""
  value
}

input MessageTypeEnumUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: MessageTypeEnumSetInput

  """filter the rows which have to be updated"""
  where: MessageTypeEnumBoolExp!
}

"""
update columns of table "message"
"""
enum MessageUpdateColumn {
  """column name"""
  augmentedFrom

  """column name"""
  content

  """column name"""
  createdAt

  """column name"""
  examples

  """column name"""
  messageId

  """column name"""
  prompt

  """column name"""
  role

  """column name"""
  threadId
}

input MessageUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: MessageAppendInput

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: MessageDeleteAtPathInput

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: MessageDeleteElemInput

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: MessageDeleteKeyInput

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: MessagePrependInput

  """sets the columns of the filtered rows to the given values"""
  _set: MessageSetInput

  """filter the rows which have to be updated"""
  where: MessageBoolExp!
}

"""
columns and relationships of "models_enum"
"""
type ModelsEnum {
  name: String!

  """An array relationship"""
  threads(
    """distinct select on columns"""
    distinctOn: [ThreadSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ThreadOrderBy!]

    """filter the rows returned"""
    where: ThreadBoolExp
  ): [Thread!]!

  """An aggregate relationship"""
  threadsAggregate(
    """distinct select on columns"""
    distinctOn: [ThreadSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ThreadOrderBy!]

    """filter the rows returned"""
    where: ThreadBoolExp
  ): ThreadAggregate!
  value: String!
}

"""
aggregated selection of "models_enum"
"""
type ModelsEnumAggregate {
  aggregate: ModelsEnumAggregateFields
  nodes: [ModelsEnum!]!
}

"""
aggregate fields of "models_enum"
"""
type ModelsEnumAggregateFields {
  count(columns: [ModelsEnumSelectColumn!], distinct: Boolean): Int!
  max: ModelsEnumMaxFields
  min: ModelsEnumMinFields
}

"""
Boolean expression to filter rows from the table "models_enum". All fields are combined with a logical 'AND'.
"""
input ModelsEnumBoolExp {
  _and: [ModelsEnumBoolExp!]
  _not: ModelsEnumBoolExp
  _or: [ModelsEnumBoolExp!]
  name: StringComparisonExp
  threads: ThreadBoolExp
  threadsAggregate: ThreadAggregateBoolExp
  value: StringComparisonExp
}

"""
unique or primary key constraints on table "models_enum"
"""
enum ModelsEnumConstraint {
  """
  unique or primary key constraint on columns "name"
  """
  models_enum_pkey

  """
  unique or primary key constraint on columns "value"
  """
  models_enum_value_key
}

enum ModelsEnumEnum {
  """claude3_haiku"""
  ANTHROPIC

  """gpt-4o-mini"""
  OPENAI

  """llama3_7B"""
  PERPLEXITY

  """wordware"""
  WORDWARE
}

"""
Boolean expression to compare columns of type "ModelsEnumEnum". All fields are combined with logical 'AND'.
"""
input ModelsEnumEnumComparisonExp {
  _eq: ModelsEnumEnum
  _in: [ModelsEnumEnum!]
  _isNull: Boolean
  _neq: ModelsEnumEnum
  _nin: [ModelsEnumEnum!]
}

"""
input type for inserting data into table "models_enum"
"""
input ModelsEnumInsertInput {
  name: String
  threads: ThreadArrRelInsertInput
  value: String
}

"""aggregate max on columns"""
type ModelsEnumMaxFields {
  name: String
  value: String
}

"""aggregate min on columns"""
type ModelsEnumMinFields {
  name: String
  value: String
}

"""
response of any mutation on the table "models_enum"
"""
type ModelsEnumMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [ModelsEnum!]!
}

"""
input type for inserting object relation for remote table "models_enum"
"""
input ModelsEnumObjRelInsertInput {
  data: ModelsEnumInsertInput!

  """upsert condition"""
  onConflict: ModelsEnumOnConflict
}

"""
on_conflict condition type for table "models_enum"
"""
input ModelsEnumOnConflict {
  constraint: ModelsEnumConstraint!
  updateColumns: [ModelsEnumUpdateColumn!]! = []
  where: ModelsEnumBoolExp
}

"""Ordering options when selecting data from "models_enum"."""
input ModelsEnumOrderBy {
  name: OrderBy
  threadsAggregate: ThreadAggregateOrderBy
  value: OrderBy
}

"""primary key columns input for table: models_enum"""
input ModelsEnumPkColumnsInput {
  name: String!
}

"""
select columns of table "models_enum"
"""
enum ModelsEnumSelectColumn {
  """column name"""
  name

  """column name"""
  value
}

"""
input type for updating data in table "models_enum"
"""
input ModelsEnumSetInput {
  name: String
  value: String
}

"""
Streaming cursor of the table "models_enum"
"""
input ModelsEnumStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ModelsEnumStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ModelsEnumStreamCursorValueInput {
  name: String
  value: String
}

"""
update columns of table "models_enum"
"""
enum ModelsEnumUpdateColumn {
  """column name"""
  name

  """column name"""
  value
}

input ModelsEnumUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: ModelsEnumSetInput

  """filter the rows which have to be updated"""
  where: ModelsEnumBoolExp!
}

"""
Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'.
"""
input NumericComparisonExp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _isNull: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

"""column ordering options"""
enum OrderBy {
  """in ascending order, nulls last"""
  ASC

  """in ascending order, nulls first"""
  ASC_NULLS_FIRST

  """in ascending order, nulls last"""
  ASC_NULLS_LAST

  """in descending order, nulls first"""
  DESC

  """in descending order, nulls first"""
  DESC_NULLS_FIRST

  """in descending order, nulls last"""
  DESC_NULLS_LAST
}

"""
This table stores user-specific preferences for quick access when they interact with a chatbot.
"""
type Preference {
  """An object relationship"""
  chatbot: Chatbot!
  chatbotId: Int!

  """An object relationship"""
  complexityEnum: ComplexityEnum!
  favorite: Boolean

  """An object relationship"""
  lengthEnum: LengthEnum!
  preferenceId: Int!
  preferredComplexity: String!
  preferredLength: String!
  preferredTone: String!
  preferredType: String!

  """An object relationship"""
  toneEnum: ToneEnum!

  """An object relationship"""
  typeEnum: TypeEnum!

  """An object relationship"""
  user: User
  userId: uuid
}

"""
aggregated selection of "preference"
"""
type PreferenceAggregate {
  aggregate: PreferenceAggregateFields
  nodes: [Preference!]!
}

input PreferenceAggregateBoolExp {
  bool_and: preferenceAggregateBoolExpBool_and
  bool_or: preferenceAggregateBoolExpBool_or
  count: preferenceAggregateBoolExpCount
}

"""
aggregate fields of "preference"
"""
type PreferenceAggregateFields {
  avg: PreferenceAvgFields
  count(columns: [PreferenceSelectColumn!], distinct: Boolean): Int!
  max: PreferenceMaxFields
  min: PreferenceMinFields
  stddev: PreferenceStddevFields
  stddevPop: PreferenceStddevPopFields
  stddevSamp: PreferenceStddevSampFields
  sum: PreferenceSumFields
  varPop: PreferenceVarPopFields
  varSamp: PreferenceVarSampFields
  variance: PreferenceVarianceFields
}

"""
order by aggregate values of table "preference"
"""
input PreferenceAggregateOrderBy {
  avg: PreferenceAvgOrderBy
  count: OrderBy
  max: PreferenceMaxOrderBy
  min: PreferenceMinOrderBy
  stddev: PreferenceStddevOrderBy
  stddevPop: PreferenceStddevPopOrderBy
  stddevSamp: PreferenceStddevSampOrderBy
  sum: PreferenceSumOrderBy
  varPop: PreferenceVarPopOrderBy
  varSamp: PreferenceVarSampOrderBy
  variance: PreferenceVarianceOrderBy
}

"""
input type for inserting array relation for remote table "preference"
"""
input PreferenceArrRelInsertInput {
  data: [PreferenceInsertInput!]!

  """upsert condition"""
  onConflict: PreferenceOnConflict
}

"""aggregate avg on columns"""
type PreferenceAvgFields {
  chatbotId: Float
  preferenceId: Float
}

"""
order by avg() on columns of table "preference"
"""
input PreferenceAvgOrderBy {
  chatbotId: OrderBy
  preferenceId: OrderBy
}

"""
Boolean expression to filter rows from the table "preference". All fields are combined with a logical 'AND'.
"""
input PreferenceBoolExp {
  _and: [PreferenceBoolExp!]
  _not: PreferenceBoolExp
  _or: [PreferenceBoolExp!]
  chatbot: ChatbotBoolExp
  chatbotId: IntComparisonExp
  complexityEnum: ComplexityEnumBoolExp
  favorite: BooleanComparisonExp
  lengthEnum: LengthEnumBoolExp
  preferenceId: IntComparisonExp
  preferredComplexity: StringComparisonExp
  preferredLength: StringComparisonExp
  preferredTone: StringComparisonExp
  preferredType: StringComparisonExp
  toneEnum: ToneEnumBoolExp
  typeEnum: TypeEnumBoolExp
  user: UserBoolExp
  userId: UuidComparisonExp
}

"""
unique or primary key constraints on table "preference"
"""
enum PreferenceConstraint {
  """
  unique or primary key constraint on columns "preference_id"
  """
  user_chatbot_preference_pkey
}

"""
input type for incrementing numeric columns in table "preference"
"""
input PreferenceIncInput {
  chatbotId: Int
  preferenceId: Int
}

"""
input type for inserting data into table "preference"
"""
input PreferenceInsertInput {
  chatbot: ChatbotObjRelInsertInput
  chatbotId: Int
  complexityEnum: ComplexityEnumObjRelInsertInput
  favorite: Boolean
  lengthEnum: LengthEnumObjRelInsertInput
  preferenceId: Int
  preferredComplexity: String
  preferredLength: String
  preferredTone: String
  preferredType: String
  toneEnum: ToneEnumObjRelInsertInput
  typeEnum: TypeEnumObjRelInsertInput
  user: UserObjRelInsertInput
  userId: uuid
}

"""aggregate max on columns"""
type PreferenceMaxFields {
  chatbotId: Int
  preferenceId: Int
  preferredComplexity: String
  preferredLength: String
  preferredTone: String
  preferredType: String
  userId: uuid
}

"""
order by max() on columns of table "preference"
"""
input PreferenceMaxOrderBy {
  chatbotId: OrderBy
  preferenceId: OrderBy
  preferredComplexity: OrderBy
  preferredLength: OrderBy
  preferredTone: OrderBy
  preferredType: OrderBy
  userId: OrderBy
}

"""aggregate min on columns"""
type PreferenceMinFields {
  chatbotId: Int
  preferenceId: Int
  preferredComplexity: String
  preferredLength: String
  preferredTone: String
  preferredType: String
  userId: uuid
}

"""
order by min() on columns of table "preference"
"""
input PreferenceMinOrderBy {
  chatbotId: OrderBy
  preferenceId: OrderBy
  preferredComplexity: OrderBy
  preferredLength: OrderBy
  preferredTone: OrderBy
  preferredType: OrderBy
  userId: OrderBy
}

"""
response of any mutation on the table "preference"
"""
type PreferenceMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Preference!]!
}

"""
on_conflict condition type for table "preference"
"""
input PreferenceOnConflict {
  constraint: PreferenceConstraint!
  updateColumns: [PreferenceUpdateColumn!]! = []
  where: PreferenceBoolExp
}

"""Ordering options when selecting data from "preference"."""
input PreferenceOrderBy {
  chatbot: ChatbotOrderBy
  chatbotId: OrderBy
  complexityEnum: ComplexityEnumOrderBy
  favorite: OrderBy
  lengthEnum: LengthEnumOrderBy
  preferenceId: OrderBy
  preferredComplexity: OrderBy
  preferredLength: OrderBy
  preferredTone: OrderBy
  preferredType: OrderBy
  toneEnum: ToneEnumOrderBy
  typeEnum: TypeEnumOrderBy
  user: UserOrderBy
  userId: OrderBy
}

"""primary key columns input for table: preference"""
input PreferencePkColumnsInput {
  preferenceId: Int!
}

"""
select columns of table "preference"
"""
enum PreferenceSelectColumn {
  """column name"""
  chatbotId

  """column name"""
  favorite

  """column name"""
  preferenceId

  """column name"""
  preferredComplexity

  """column name"""
  preferredLength

  """column name"""
  preferredTone

  """column name"""
  preferredType

  """column name"""
  userId
}

"""
select "preferenceAggregateBoolExpBool_andArgumentsColumns" columns of table "preference"
"""
enum PreferenceSelectColumnPreferenceAggregateBoolExpBool_andArgumentsColumns {
  """column name"""
  favorite
}

"""
select "preferenceAggregateBoolExpBool_orArgumentsColumns" columns of table "preference"
"""
enum PreferenceSelectColumnPreferenceAggregateBoolExpBool_orArgumentsColumns {
  """column name"""
  favorite
}

"""
input type for updating data in table "preference"
"""
input PreferenceSetInput {
  chatbotId: Int
  favorite: Boolean
  preferenceId: Int
  preferredComplexity: String
  preferredLength: String
  preferredTone: String
  preferredType: String
  userId: uuid
}

"""aggregate stddev on columns"""
type PreferenceStddevFields {
  chatbotId: Float
  preferenceId: Float
}

"""
order by stddev() on columns of table "preference"
"""
input PreferenceStddevOrderBy {
  chatbotId: OrderBy
  preferenceId: OrderBy
}

"""aggregate stddevPop on columns"""
type PreferenceStddevPopFields {
  chatbotId: Float
  preferenceId: Float
}

"""
order by stddevPop() on columns of table "preference"
"""
input PreferenceStddevPopOrderBy {
  chatbotId: OrderBy
  preferenceId: OrderBy
}

"""aggregate stddevSamp on columns"""
type PreferenceStddevSampFields {
  chatbotId: Float
  preferenceId: Float
}

"""
order by stddevSamp() on columns of table "preference"
"""
input PreferenceStddevSampOrderBy {
  chatbotId: OrderBy
  preferenceId: OrderBy
}

"""
Streaming cursor of the table "preference"
"""
input PreferenceStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PreferenceStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PreferenceStreamCursorValueInput {
  chatbotId: Int
  favorite: Boolean
  preferenceId: Int
  preferredComplexity: String
  preferredLength: String
  preferredTone: String
  preferredType: String
  userId: uuid
}

"""aggregate sum on columns"""
type PreferenceSumFields {
  chatbotId: Int
  preferenceId: Int
}

"""
order by sum() on columns of table "preference"
"""
input PreferenceSumOrderBy {
  chatbotId: OrderBy
  preferenceId: OrderBy
}

"""
update columns of table "preference"
"""
enum PreferenceUpdateColumn {
  """column name"""
  chatbotId

  """column name"""
  favorite

  """column name"""
  preferenceId

  """column name"""
  preferredComplexity

  """column name"""
  preferredLength

  """column name"""
  preferredTone

  """column name"""
  preferredType

  """column name"""
  userId
}

input PreferenceUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: PreferenceIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: PreferenceSetInput

  """filter the rows which have to be updated"""
  where: PreferenceBoolExp!
}

"""aggregate varPop on columns"""
type PreferenceVarPopFields {
  chatbotId: Float
  preferenceId: Float
}

"""
order by varPop() on columns of table "preference"
"""
input PreferenceVarPopOrderBy {
  chatbotId: OrderBy
  preferenceId: OrderBy
}

"""aggregate varSamp on columns"""
type PreferenceVarSampFields {
  chatbotId: Float
  preferenceId: Float
}

"""
order by varSamp() on columns of table "preference"
"""
input PreferenceVarSampOrderBy {
  chatbotId: OrderBy
  preferenceId: OrderBy
}

"""aggregate variance on columns"""
type PreferenceVarianceFields {
  chatbotId: Float
  preferenceId: Float
}

"""
order by variance() on columns of table "preference"
"""
input PreferenceVarianceOrderBy {
  chatbotId: OrderBy
  preferenceId: OrderBy
}

"""
columns and relationships of "prompt"
"""
type Prompt {
  """An array relationship"""
  chatbots(
    """distinct select on columns"""
    distinctOn: [PromptChatbotSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptChatbotOrderBy!]

    """filter the rows returned"""
    where: PromptChatbotBoolExp
  ): [PromptChatbot!]!

  """An aggregate relationship"""
  chatbotsAggregate(
    """distinct select on columns"""
    distinctOn: [PromptChatbotSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptChatbotOrderBy!]

    """filter the rows returned"""
    where: PromptChatbotBoolExp
  ): PromptChatbotAggregate!
  content: String!
  promptId: Int!
  promptName: String

  """An object relationship"""
  promptTypeEnum: PromptTypeEnum!
  type: String!

  """An array relationship"""
  users(
    """distinct select on columns"""
    distinctOn: [PromptUserSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptUserOrderBy!]

    """filter the rows returned"""
    where: PromptUserBoolExp
  ): [PromptUser!]!

  """An aggregate relationship"""
  usersAggregate(
    """distinct select on columns"""
    distinctOn: [PromptUserSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptUserOrderBy!]

    """filter the rows returned"""
    where: PromptUserBoolExp
  ): PromptUserAggregate!
}

"""
aggregated selection of "prompt"
"""
type PromptAggregate {
  aggregate: PromptAggregateFields
  nodes: [Prompt!]!
}

input PromptAggregateBoolExp {
  count: promptAggregateBoolExpCount
}

"""
aggregate fields of "prompt"
"""
type PromptAggregateFields {
  avg: PromptAvgFields
  count(columns: [PromptSelectColumn!], distinct: Boolean): Int!
  max: PromptMaxFields
  min: PromptMinFields
  stddev: PromptStddevFields
  stddevPop: PromptStddevPopFields
  stddevSamp: PromptStddevSampFields
  sum: PromptSumFields
  varPop: PromptVarPopFields
  varSamp: PromptVarSampFields
  variance: PromptVarianceFields
}

"""
order by aggregate values of table "prompt"
"""
input PromptAggregateOrderBy {
  avg: PromptAvgOrderBy
  count: OrderBy
  max: PromptMaxOrderBy
  min: PromptMinOrderBy
  stddev: PromptStddevOrderBy
  stddevPop: PromptStddevPopOrderBy
  stddevSamp: PromptStddevSampOrderBy
  sum: PromptSumOrderBy
  varPop: PromptVarPopOrderBy
  varSamp: PromptVarSampOrderBy
  variance: PromptVarianceOrderBy
}

"""
input type for inserting array relation for remote table "prompt"
"""
input PromptArrRelInsertInput {
  data: [PromptInsertInput!]!

  """upsert condition"""
  onConflict: PromptOnConflict
}

"""aggregate avg on columns"""
type PromptAvgFields {
  promptId: Float
}

"""
order by avg() on columns of table "prompt"
"""
input PromptAvgOrderBy {
  promptId: OrderBy
}

"""
Boolean expression to filter rows from the table "prompt". All fields are combined with a logical 'AND'.
"""
input PromptBoolExp {
  _and: [PromptBoolExp!]
  _not: PromptBoolExp
  _or: [PromptBoolExp!]
  chatbots: PromptChatbotBoolExp
  chatbotsAggregate: PromptChatbotAggregateBoolExp
  content: StringComparisonExp
  promptId: IntComparisonExp
  promptName: StringComparisonExp
  promptTypeEnum: PromptTypeEnumBoolExp
  type: StringComparisonExp
  users: PromptUserBoolExp
  usersAggregate: PromptUserAggregateBoolExp
}

"""Junction table for prompts/instructions and chatbots."""
type PromptChatbot {
  chabotId: Int!

  """An object relationship"""
  chatbot: Chatbot!

  """An object relationship"""
  prompt: Prompt!
  promptId: Int!
}

"""
aggregated selection of "prompt_chatbot"
"""
type PromptChatbotAggregate {
  aggregate: PromptChatbotAggregateFields
  nodes: [PromptChatbot!]!
}

input PromptChatbotAggregateBoolExp {
  count: promptChatbotAggregateBoolExpCount
}

"""
aggregate fields of "prompt_chatbot"
"""
type PromptChatbotAggregateFields {
  avg: PromptChatbotAvgFields
  count(columns: [PromptChatbotSelectColumn!], distinct: Boolean): Int!
  max: PromptChatbotMaxFields
  min: PromptChatbotMinFields
  stddev: PromptChatbotStddevFields
  stddevPop: PromptChatbotStddevPopFields
  stddevSamp: PromptChatbotStddevSampFields
  sum: PromptChatbotSumFields
  varPop: PromptChatbotVarPopFields
  varSamp: PromptChatbotVarSampFields
  variance: PromptChatbotVarianceFields
}

"""
order by aggregate values of table "prompt_chatbot"
"""
input PromptChatbotAggregateOrderBy {
  avg: PromptChatbotAvgOrderBy
  count: OrderBy
  max: PromptChatbotMaxOrderBy
  min: PromptChatbotMinOrderBy
  stddev: PromptChatbotStddevOrderBy
  stddevPop: PromptChatbotStddevPopOrderBy
  stddevSamp: PromptChatbotStddevSampOrderBy
  sum: PromptChatbotSumOrderBy
  varPop: PromptChatbotVarPopOrderBy
  varSamp: PromptChatbotVarSampOrderBy
  variance: PromptChatbotVarianceOrderBy
}

"""
input type for inserting array relation for remote table "prompt_chatbot"
"""
input PromptChatbotArrRelInsertInput {
  data: [PromptChatbotInsertInput!]!

  """upsert condition"""
  onConflict: PromptChatbotOnConflict
}

"""aggregate avg on columns"""
type PromptChatbotAvgFields {
  chabotId: Float
  promptId: Float
}

"""
order by avg() on columns of table "prompt_chatbot"
"""
input PromptChatbotAvgOrderBy {
  chabotId: OrderBy
  promptId: OrderBy
}

"""
Boolean expression to filter rows from the table "prompt_chatbot". All fields are combined with a logical 'AND'.
"""
input PromptChatbotBoolExp {
  _and: [PromptChatbotBoolExp!]
  _not: PromptChatbotBoolExp
  _or: [PromptChatbotBoolExp!]
  chabotId: IntComparisonExp
  chatbot: ChatbotBoolExp
  prompt: PromptBoolExp
  promptId: IntComparisonExp
}

"""
unique or primary key constraints on table "prompt_chatbot"
"""
enum PromptChatbotConstraint {
  """
  unique or primary key constraint on columns "prompt_id", "chabot_id"
  """
  prompt_chatbot_pkey
}

"""
input type for incrementing numeric columns in table "prompt_chatbot"
"""
input PromptChatbotIncInput {
  chabotId: Int
  promptId: Int
}

"""
input type for inserting data into table "prompt_chatbot"
"""
input PromptChatbotInsertInput {
  chabotId: Int
  chatbot: ChatbotObjRelInsertInput
  prompt: PromptObjRelInsertInput
  promptId: Int
}

"""aggregate max on columns"""
type PromptChatbotMaxFields {
  chabotId: Int
  promptId: Int
}

"""
order by max() on columns of table "prompt_chatbot"
"""
input PromptChatbotMaxOrderBy {
  chabotId: OrderBy
  promptId: OrderBy
}

"""aggregate min on columns"""
type PromptChatbotMinFields {
  chabotId: Int
  promptId: Int
}

"""
order by min() on columns of table "prompt_chatbot"
"""
input PromptChatbotMinOrderBy {
  chabotId: OrderBy
  promptId: OrderBy
}

"""
response of any mutation on the table "prompt_chatbot"
"""
type PromptChatbotMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [PromptChatbot!]!
}

"""
on_conflict condition type for table "prompt_chatbot"
"""
input PromptChatbotOnConflict {
  constraint: PromptChatbotConstraint!
  updateColumns: [PromptChatbotUpdateColumn!]! = []
  where: PromptChatbotBoolExp
}

"""Ordering options when selecting data from "prompt_chatbot"."""
input PromptChatbotOrderBy {
  chabotId: OrderBy
  chatbot: ChatbotOrderBy
  prompt: PromptOrderBy
  promptId: OrderBy
}

"""primary key columns input for table: prompt_chatbot"""
input PromptChatbotPkColumnsInput {
  chabotId: Int!
  promptId: Int!
}

"""
select columns of table "prompt_chatbot"
"""
enum PromptChatbotSelectColumn {
  """column name"""
  chabotId

  """column name"""
  promptId
}

"""
input type for updating data in table "prompt_chatbot"
"""
input PromptChatbotSetInput {
  chabotId: Int
  promptId: Int
}

"""aggregate stddev on columns"""
type PromptChatbotStddevFields {
  chabotId: Float
  promptId: Float
}

"""
order by stddev() on columns of table "prompt_chatbot"
"""
input PromptChatbotStddevOrderBy {
  chabotId: OrderBy
  promptId: OrderBy
}

"""aggregate stddevPop on columns"""
type PromptChatbotStddevPopFields {
  chabotId: Float
  promptId: Float
}

"""
order by stddevPop() on columns of table "prompt_chatbot"
"""
input PromptChatbotStddevPopOrderBy {
  chabotId: OrderBy
  promptId: OrderBy
}

"""aggregate stddevSamp on columns"""
type PromptChatbotStddevSampFields {
  chabotId: Float
  promptId: Float
}

"""
order by stddevSamp() on columns of table "prompt_chatbot"
"""
input PromptChatbotStddevSampOrderBy {
  chabotId: OrderBy
  promptId: OrderBy
}

"""
Streaming cursor of the table "prompt_chatbot"
"""
input PromptChatbotStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PromptChatbotStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PromptChatbotStreamCursorValueInput {
  chabotId: Int
  promptId: Int
}

"""aggregate sum on columns"""
type PromptChatbotSumFields {
  chabotId: Int
  promptId: Int
}

"""
order by sum() on columns of table "prompt_chatbot"
"""
input PromptChatbotSumOrderBy {
  chabotId: OrderBy
  promptId: OrderBy
}

"""
update columns of table "prompt_chatbot"
"""
enum PromptChatbotUpdateColumn {
  """column name"""
  chabotId

  """column name"""
  promptId
}

input PromptChatbotUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: PromptChatbotIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: PromptChatbotSetInput

  """filter the rows which have to be updated"""
  where: PromptChatbotBoolExp!
}

"""aggregate varPop on columns"""
type PromptChatbotVarPopFields {
  chabotId: Float
  promptId: Float
}

"""
order by varPop() on columns of table "prompt_chatbot"
"""
input PromptChatbotVarPopOrderBy {
  chabotId: OrderBy
  promptId: OrderBy
}

"""aggregate varSamp on columns"""
type PromptChatbotVarSampFields {
  chabotId: Float
  promptId: Float
}

"""
order by varSamp() on columns of table "prompt_chatbot"
"""
input PromptChatbotVarSampOrderBy {
  chabotId: OrderBy
  promptId: OrderBy
}

"""aggregate variance on columns"""
type PromptChatbotVarianceFields {
  chabotId: Float
  promptId: Float
}

"""
order by variance() on columns of table "prompt_chatbot"
"""
input PromptChatbotVarianceOrderBy {
  chabotId: OrderBy
  promptId: OrderBy
}

"""
unique or primary key constraints on table "prompt"
"""
enum PromptConstraint {
  """
  unique or primary key constraint on columns "prompt_id"
  """
  prompt_pkey

  """
  unique or primary key constraint on columns "prompt_id"
  """
  prompt_prompt_id_key
}

"""
input type for incrementing numeric columns in table "prompt"
"""
input PromptIncInput {
  promptId: Int
}

"""
input type for inserting data into table "prompt"
"""
input PromptInsertInput {
  chatbots: PromptChatbotArrRelInsertInput
  content: String
  promptId: Int
  promptName: String
  promptTypeEnum: PromptTypeEnumObjRelInsertInput
  type: String
  users: PromptUserArrRelInsertInput
}

"""aggregate max on columns"""
type PromptMaxFields {
  content: String
  promptId: Int
  promptName: String
  type: String
}

"""
order by max() on columns of table "prompt"
"""
input PromptMaxOrderBy {
  content: OrderBy
  promptId: OrderBy
  promptName: OrderBy
  type: OrderBy
}

"""aggregate min on columns"""
type PromptMinFields {
  content: String
  promptId: Int
  promptName: String
  type: String
}

"""
order by min() on columns of table "prompt"
"""
input PromptMinOrderBy {
  content: OrderBy
  promptId: OrderBy
  promptName: OrderBy
  type: OrderBy
}

"""
response of any mutation on the table "prompt"
"""
type PromptMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Prompt!]!
}

"""
input type for inserting object relation for remote table "prompt"
"""
input PromptObjRelInsertInput {
  data: PromptInsertInput!

  """upsert condition"""
  onConflict: PromptOnConflict
}

"""
on_conflict condition type for table "prompt"
"""
input PromptOnConflict {
  constraint: PromptConstraint!
  updateColumns: [PromptUpdateColumn!]! = []
  where: PromptBoolExp
}

"""Ordering options when selecting data from "prompt"."""
input PromptOrderBy {
  chatbotsAggregate: PromptChatbotAggregateOrderBy
  content: OrderBy
  promptId: OrderBy
  promptName: OrderBy
  promptTypeEnum: PromptTypeEnumOrderBy
  type: OrderBy
  usersAggregate: PromptUserAggregateOrderBy
}

"""primary key columns input for table: prompt"""
input PromptPkColumnsInput {
  promptId: Int!
}

"""
select columns of table "prompt"
"""
enum PromptSelectColumn {
  """column name"""
  content

  """column name"""
  promptId

  """column name"""
  promptName

  """column name"""
  type
}

"""
input type for updating data in table "prompt"
"""
input PromptSetInput {
  content: String
  promptId: Int
  promptName: String
  type: String
}

"""aggregate stddev on columns"""
type PromptStddevFields {
  promptId: Float
}

"""
order by stddev() on columns of table "prompt"
"""
input PromptStddevOrderBy {
  promptId: OrderBy
}

"""aggregate stddevPop on columns"""
type PromptStddevPopFields {
  promptId: Float
}

"""
order by stddevPop() on columns of table "prompt"
"""
input PromptStddevPopOrderBy {
  promptId: OrderBy
}

"""aggregate stddevSamp on columns"""
type PromptStddevSampFields {
  promptId: Float
}

"""
order by stddevSamp() on columns of table "prompt"
"""
input PromptStddevSampOrderBy {
  promptId: OrderBy
}

"""
Streaming cursor of the table "prompt"
"""
input PromptStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PromptStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PromptStreamCursorValueInput {
  content: String
  promptId: Int
  promptName: String
  type: String
}

"""aggregate sum on columns"""
type PromptSumFields {
  promptId: Int
}

"""
order by sum() on columns of table "prompt"
"""
input PromptSumOrderBy {
  promptId: OrderBy
}

"""
columns and relationships of "prompt_type_enum"
"""
type PromptTypeEnum {
  """An array relationship"""
  prompts(
    """distinct select on columns"""
    distinctOn: [PromptSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptOrderBy!]

    """filter the rows returned"""
    where: PromptBoolExp
  ): [Prompt!]!

  """An aggregate relationship"""
  promptsAggregate(
    """distinct select on columns"""
    distinctOn: [PromptSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptOrderBy!]

    """filter the rows returned"""
    where: PromptBoolExp
  ): PromptAggregate!
  value: String!
}

"""
aggregated selection of "prompt_type_enum"
"""
type PromptTypeEnumAggregate {
  aggregate: PromptTypeEnumAggregateFields
  nodes: [PromptTypeEnum!]!
}

"""
aggregate fields of "prompt_type_enum"
"""
type PromptTypeEnumAggregateFields {
  count(columns: [PromptTypeEnumSelectColumn!], distinct: Boolean): Int!
  max: PromptTypeEnumMaxFields
  min: PromptTypeEnumMinFields
}

"""
Boolean expression to filter rows from the table "prompt_type_enum". All fields are combined with a logical 'AND'.
"""
input PromptTypeEnumBoolExp {
  _and: [PromptTypeEnumBoolExp!]
  _not: PromptTypeEnumBoolExp
  _or: [PromptTypeEnumBoolExp!]
  prompts: PromptBoolExp
  promptsAggregate: PromptAggregateBoolExp
  value: StringComparisonExp
}

"""
unique or primary key constraints on table "prompt_type_enum"
"""
enum PromptTypeEnumConstraint {
  """
  unique or primary key constraint on columns "value"
  """
  type_enum_pkey
}

"""
input type for inserting data into table "prompt_type_enum"
"""
input PromptTypeEnumInsertInput {
  prompts: PromptArrRelInsertInput
  value: String
}

"""aggregate max on columns"""
type PromptTypeEnumMaxFields {
  value: String
}

"""aggregate min on columns"""
type PromptTypeEnumMinFields {
  value: String
}

"""
response of any mutation on the table "prompt_type_enum"
"""
type PromptTypeEnumMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [PromptTypeEnum!]!
}

"""
input type for inserting object relation for remote table "prompt_type_enum"
"""
input PromptTypeEnumObjRelInsertInput {
  data: PromptTypeEnumInsertInput!

  """upsert condition"""
  onConflict: PromptTypeEnumOnConflict
}

"""
on_conflict condition type for table "prompt_type_enum"
"""
input PromptTypeEnumOnConflict {
  constraint: PromptTypeEnumConstraint!
  updateColumns: [PromptTypeEnumUpdateColumn!]! = []
  where: PromptTypeEnumBoolExp
}

"""Ordering options when selecting data from "prompt_type_enum"."""
input PromptTypeEnumOrderBy {
  promptsAggregate: PromptAggregateOrderBy
  value: OrderBy
}

"""primary key columns input for table: prompt_type_enum"""
input PromptTypeEnumPkColumnsInput {
  value: String!
}

"""
select columns of table "prompt_type_enum"
"""
enum PromptTypeEnumSelectColumn {
  """column name"""
  value
}

"""
input type for updating data in table "prompt_type_enum"
"""
input PromptTypeEnumSetInput {
  value: String
}

"""
Streaming cursor of the table "prompt_type_enum"
"""
input PromptTypeEnumStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PromptTypeEnumStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PromptTypeEnumStreamCursorValueInput {
  value: String
}

"""
update columns of table "prompt_type_enum"
"""
enum PromptTypeEnumUpdateColumn {
  """column name"""
  value
}

input PromptTypeEnumUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: PromptTypeEnumSetInput

  """filter the rows which have to be updated"""
  where: PromptTypeEnumBoolExp!
}

"""
update columns of table "prompt"
"""
enum PromptUpdateColumn {
  """column name"""
  content

  """column name"""
  promptId

  """column name"""
  promptName

  """column name"""
  type
}

input PromptUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: PromptIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: PromptSetInput

  """filter the rows which have to be updated"""
  where: PromptBoolExp!
}

"""
columns and relationships of "prompt_user"
"""
type PromptUser {
  """An object relationship"""
  prompt: Prompt!
  promptId: Int!

  """An object relationship"""
  user: User!
  userId: uuid!
}

"""
aggregated selection of "prompt_user"
"""
type PromptUserAggregate {
  aggregate: PromptUserAggregateFields
  nodes: [PromptUser!]!
}

input PromptUserAggregateBoolExp {
  count: promptUserAggregateBoolExpCount
}

"""
aggregate fields of "prompt_user"
"""
type PromptUserAggregateFields {
  avg: PromptUserAvgFields
  count(columns: [PromptUserSelectColumn!], distinct: Boolean): Int!
  max: PromptUserMaxFields
  min: PromptUserMinFields
  stddev: PromptUserStddevFields
  stddevPop: PromptUserStddevPopFields
  stddevSamp: PromptUserStddevSampFields
  sum: PromptUserSumFields
  varPop: PromptUserVarPopFields
  varSamp: PromptUserVarSampFields
  variance: PromptUserVarianceFields
}

"""
order by aggregate values of table "prompt_user"
"""
input PromptUserAggregateOrderBy {
  avg: PromptUserAvgOrderBy
  count: OrderBy
  max: PromptUserMaxOrderBy
  min: PromptUserMinOrderBy
  stddev: PromptUserStddevOrderBy
  stddevPop: PromptUserStddevPopOrderBy
  stddevSamp: PromptUserStddevSampOrderBy
  sum: PromptUserSumOrderBy
  varPop: PromptUserVarPopOrderBy
  varSamp: PromptUserVarSampOrderBy
  variance: PromptUserVarianceOrderBy
}

"""
input type for inserting array relation for remote table "prompt_user"
"""
input PromptUserArrRelInsertInput {
  data: [PromptUserInsertInput!]!

  """upsert condition"""
  onConflict: PromptUserOnConflict
}

"""aggregate avg on columns"""
type PromptUserAvgFields {
  promptId: Float
}

"""
order by avg() on columns of table "prompt_user"
"""
input PromptUserAvgOrderBy {
  promptId: OrderBy
}

"""
Boolean expression to filter rows from the table "prompt_user". All fields are combined with a logical 'AND'.
"""
input PromptUserBoolExp {
  _and: [PromptUserBoolExp!]
  _not: PromptUserBoolExp
  _or: [PromptUserBoolExp!]
  prompt: PromptBoolExp
  promptId: IntComparisonExp
  user: UserBoolExp
  userId: UuidComparisonExp
}

"""
unique or primary key constraints on table "prompt_user"
"""
enum PromptUserConstraint {
  """
  unique or primary key constraint on columns "user_id", "prompt_id"
  """
  prompt_user_pkey
}

"""
input type for incrementing numeric columns in table "prompt_user"
"""
input PromptUserIncInput {
  promptId: Int
}

"""
input type for inserting data into table "prompt_user"
"""
input PromptUserInsertInput {
  prompt: PromptObjRelInsertInput
  promptId: Int
  user: UserObjRelInsertInput
  userId: uuid
}

"""aggregate max on columns"""
type PromptUserMaxFields {
  promptId: Int
  userId: uuid
}

"""
order by max() on columns of table "prompt_user"
"""
input PromptUserMaxOrderBy {
  promptId: OrderBy
  userId: OrderBy
}

"""aggregate min on columns"""
type PromptUserMinFields {
  promptId: Int
  userId: uuid
}

"""
order by min() on columns of table "prompt_user"
"""
input PromptUserMinOrderBy {
  promptId: OrderBy
  userId: OrderBy
}

"""
response of any mutation on the table "prompt_user"
"""
type PromptUserMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [PromptUser!]!
}

"""
on_conflict condition type for table "prompt_user"
"""
input PromptUserOnConflict {
  constraint: PromptUserConstraint!
  updateColumns: [PromptUserUpdateColumn!]! = []
  where: PromptUserBoolExp
}

"""Ordering options when selecting data from "prompt_user"."""
input PromptUserOrderBy {
  prompt: PromptOrderBy
  promptId: OrderBy
  user: UserOrderBy
  userId: OrderBy
}

"""primary key columns input for table: prompt_user"""
input PromptUserPkColumnsInput {
  promptId: Int!
  userId: uuid!
}

"""
select columns of table "prompt_user"
"""
enum PromptUserSelectColumn {
  """column name"""
  promptId

  """column name"""
  userId
}

"""
input type for updating data in table "prompt_user"
"""
input PromptUserSetInput {
  promptId: Int
  userId: uuid
}

"""aggregate stddev on columns"""
type PromptUserStddevFields {
  promptId: Float
}

"""
order by stddev() on columns of table "prompt_user"
"""
input PromptUserStddevOrderBy {
  promptId: OrderBy
}

"""aggregate stddevPop on columns"""
type PromptUserStddevPopFields {
  promptId: Float
}

"""
order by stddevPop() on columns of table "prompt_user"
"""
input PromptUserStddevPopOrderBy {
  promptId: OrderBy
}

"""aggregate stddevSamp on columns"""
type PromptUserStddevSampFields {
  promptId: Float
}

"""
order by stddevSamp() on columns of table "prompt_user"
"""
input PromptUserStddevSampOrderBy {
  promptId: OrderBy
}

"""
Streaming cursor of the table "prompt_user"
"""
input PromptUserStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PromptUserStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PromptUserStreamCursorValueInput {
  promptId: Int
  userId: uuid
}

"""aggregate sum on columns"""
type PromptUserSumFields {
  promptId: Int
}

"""
order by sum() on columns of table "prompt_user"
"""
input PromptUserSumOrderBy {
  promptId: OrderBy
}

"""
update columns of table "prompt_user"
"""
enum PromptUserUpdateColumn {
  """column name"""
  promptId

  """column name"""
  userId
}

input PromptUserUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: PromptUserIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: PromptUserSetInput

  """filter the rows which have to be updated"""
  where: PromptUserBoolExp!
}

"""aggregate varPop on columns"""
type PromptUserVarPopFields {
  promptId: Float
}

"""
order by varPop() on columns of table "prompt_user"
"""
input PromptUserVarPopOrderBy {
  promptId: OrderBy
}

"""aggregate varSamp on columns"""
type PromptUserVarSampFields {
  promptId: Float
}

"""
order by varSamp() on columns of table "prompt_user"
"""
input PromptUserVarSampOrderBy {
  promptId: OrderBy
}

"""aggregate variance on columns"""
type PromptUserVarianceFields {
  promptId: Float
}

"""
order by variance() on columns of table "prompt_user"
"""
input PromptUserVarianceOrderBy {
  promptId: OrderBy
}

"""aggregate varPop on columns"""
type PromptVarPopFields {
  promptId: Float
}

"""
order by varPop() on columns of table "prompt"
"""
input PromptVarPopOrderBy {
  promptId: OrderBy
}

"""aggregate varSamp on columns"""
type PromptVarSampFields {
  promptId: Float
}

"""
order by varSamp() on columns of table "prompt"
"""
input PromptVarSampOrderBy {
  promptId: OrderBy
}

"""aggregate variance on columns"""
type PromptVarianceFields {
  promptId: Float
}

"""
order by variance() on columns of table "prompt"
"""
input PromptVarianceOrderBy {
  promptId: OrderBy
}

"""
columns and relationships of "referral"
"""
type Referral {
  referralCode: String!
  referrerId: uuid!

  """An object relationship"""
  user: User!

  """An object relationship"""
  userByUserId: User!
  userId: uuid!
}

"""
aggregated selection of "referral"
"""
type ReferralAggregate {
  aggregate: ReferralAggregateFields
  nodes: [Referral!]!
}

input ReferralAggregateBoolExp {
  count: referralAggregateBoolExpCount
}

"""
aggregate fields of "referral"
"""
type ReferralAggregateFields {
  count(columns: [ReferralSelectColumn!], distinct: Boolean): Int!
  max: ReferralMaxFields
  min: ReferralMinFields
}

"""
order by aggregate values of table "referral"
"""
input ReferralAggregateOrderBy {
  count: OrderBy
  max: ReferralMaxOrderBy
  min: ReferralMinOrderBy
}

"""
input type for inserting array relation for remote table "referral"
"""
input ReferralArrRelInsertInput {
  data: [ReferralInsertInput!]!

  """upsert condition"""
  onConflict: ReferralOnConflict
}

"""
Boolean expression to filter rows from the table "referral". All fields are combined with a logical 'AND'.
"""
input ReferralBoolExp {
  _and: [ReferralBoolExp!]
  _not: ReferralBoolExp
  _or: [ReferralBoolExp!]
  referralCode: StringComparisonExp
  referrerId: UuidComparisonExp
  user: UserBoolExp
  userByUserId: UserBoolExp
  userId: UuidComparisonExp
}

"""
unique or primary key constraints on table "referral"
"""
enum ReferralConstraint {
  """
  unique or primary key constraint on columns "referral_code"
  """
  referral_pkey
}

"""
input type for inserting data into table "referral"
"""
input ReferralInsertInput {
  referralCode: String
  referrerId: uuid
  user: UserObjRelInsertInput
  userByUserId: UserObjRelInsertInput
  userId: uuid
}

"""aggregate max on columns"""
type ReferralMaxFields {
  referralCode: String
  referrerId: uuid
  userId: uuid
}

"""
order by max() on columns of table "referral"
"""
input ReferralMaxOrderBy {
  referralCode: OrderBy
  referrerId: OrderBy
  userId: OrderBy
}

"""aggregate min on columns"""
type ReferralMinFields {
  referralCode: String
  referrerId: uuid
  userId: uuid
}

"""
order by min() on columns of table "referral"
"""
input ReferralMinOrderBy {
  referralCode: OrderBy
  referrerId: OrderBy
  userId: OrderBy
}

"""
response of any mutation on the table "referral"
"""
type ReferralMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Referral!]!
}

"""
on_conflict condition type for table "referral"
"""
input ReferralOnConflict {
  constraint: ReferralConstraint!
  updateColumns: [ReferralUpdateColumn!]! = []
  where: ReferralBoolExp
}

"""Ordering options when selecting data from "referral"."""
input ReferralOrderBy {
  referralCode: OrderBy
  referrerId: OrderBy
  user: UserOrderBy
  userByUserId: UserOrderBy
  userId: OrderBy
}

"""primary key columns input for table: referral"""
input ReferralPkColumnsInput {
  referralCode: String!
}

"""
select columns of table "referral"
"""
enum ReferralSelectColumn {
  """column name"""
  referralCode

  """column name"""
  referrerId

  """column name"""
  userId
}

"""
input type for updating data in table "referral"
"""
input ReferralSetInput {
  referralCode: String
  referrerId: uuid
  userId: uuid
}

"""
Streaming cursor of the table "referral"
"""
input ReferralStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ReferralStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ReferralStreamCursorValueInput {
  referralCode: String
  referrerId: uuid
  userId: uuid
}

"""
update columns of table "referral"
"""
enum ReferralUpdateColumn {
  """column name"""
  referralCode

  """column name"""
  referrerId

  """column name"""
  userId
}

input ReferralUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: ReferralSetInput

  """filter the rows which have to be updated"""
  where: ReferralBoolExp!
}

"""
This junction table records social following relationships between users. Each record represents a follower-followee relationship.
"""
type SocialFollowing {
  """An object relationship"""
  chatbot: Chatbot
  createdAt: timestamptz!
  followeeId: uuid
  followeeIdChatbot: Int
  followerId: uuid!

  """An object relationship"""
  user: User

  """An object relationship"""
  userByFollowerId: User!
}

"""
aggregated selection of "social_following"
"""
type SocialFollowingAggregate {
  aggregate: SocialFollowingAggregateFields
  nodes: [SocialFollowing!]!
}

input SocialFollowingAggregateBoolExp {
  count: socialFollowingAggregateBoolExpCount
}

"""
aggregate fields of "social_following"
"""
type SocialFollowingAggregateFields {
  avg: SocialFollowingAvgFields
  count(columns: [SocialFollowingSelectColumn!], distinct: Boolean): Int!
  max: SocialFollowingMaxFields
  min: SocialFollowingMinFields
  stddev: SocialFollowingStddevFields
  stddevPop: SocialFollowingStddevPopFields
  stddevSamp: SocialFollowingStddevSampFields
  sum: SocialFollowingSumFields
  varPop: SocialFollowingVarPopFields
  varSamp: SocialFollowingVarSampFields
  variance: SocialFollowingVarianceFields
}

"""
order by aggregate values of table "social_following"
"""
input SocialFollowingAggregateOrderBy {
  avg: SocialFollowingAvgOrderBy
  count: OrderBy
  max: SocialFollowingMaxOrderBy
  min: SocialFollowingMinOrderBy
  stddev: SocialFollowingStddevOrderBy
  stddevPop: SocialFollowingStddevPopOrderBy
  stddevSamp: SocialFollowingStddevSampOrderBy
  sum: SocialFollowingSumOrderBy
  varPop: SocialFollowingVarPopOrderBy
  varSamp: SocialFollowingVarSampOrderBy
  variance: SocialFollowingVarianceOrderBy
}

"""
input type for inserting array relation for remote table "social_following"
"""
input SocialFollowingArrRelInsertInput {
  data: [SocialFollowingInsertInput!]!
}

"""aggregate avg on columns"""
type SocialFollowingAvgFields {
  followeeIdChatbot: Float
}

"""
order by avg() on columns of table "social_following"
"""
input SocialFollowingAvgOrderBy {
  followeeIdChatbot: OrderBy
}

"""
Boolean expression to filter rows from the table "social_following". All fields are combined with a logical 'AND'.
"""
input SocialFollowingBoolExp {
  _and: [SocialFollowingBoolExp!]
  _not: SocialFollowingBoolExp
  _or: [SocialFollowingBoolExp!]
  chatbot: ChatbotBoolExp
  createdAt: TimestamptzComparisonExp
  followeeId: UuidComparisonExp
  followeeIdChatbot: IntComparisonExp
  followerId: UuidComparisonExp
  user: UserBoolExp
  userByFollowerId: UserBoolExp
}

"""
input type for incrementing numeric columns in table "social_following"
"""
input SocialFollowingIncInput {
  followeeIdChatbot: Int
}

"""
input type for inserting data into table "social_following"
"""
input SocialFollowingInsertInput {
  chatbot: ChatbotObjRelInsertInput
  createdAt: timestamptz
  followeeId: uuid
  followeeIdChatbot: Int
  followerId: uuid
  user: UserObjRelInsertInput
  userByFollowerId: UserObjRelInsertInput
}

"""aggregate max on columns"""
type SocialFollowingMaxFields {
  createdAt: timestamptz
  followeeId: uuid
  followeeIdChatbot: Int
  followerId: uuid
}

"""
order by max() on columns of table "social_following"
"""
input SocialFollowingMaxOrderBy {
  createdAt: OrderBy
  followeeId: OrderBy
  followeeIdChatbot: OrderBy
  followerId: OrderBy
}

"""aggregate min on columns"""
type SocialFollowingMinFields {
  createdAt: timestamptz
  followeeId: uuid
  followeeIdChatbot: Int
  followerId: uuid
}

"""
order by min() on columns of table "social_following"
"""
input SocialFollowingMinOrderBy {
  createdAt: OrderBy
  followeeId: OrderBy
  followeeIdChatbot: OrderBy
  followerId: OrderBy
}

"""
response of any mutation on the table "social_following"
"""
type SocialFollowingMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [SocialFollowing!]!
}

"""Ordering options when selecting data from "social_following"."""
input SocialFollowingOrderBy {
  chatbot: ChatbotOrderBy
  createdAt: OrderBy
  followeeId: OrderBy
  followeeIdChatbot: OrderBy
  followerId: OrderBy
  user: UserOrderBy
  userByFollowerId: UserOrderBy
}

"""
select columns of table "social_following"
"""
enum SocialFollowingSelectColumn {
  """column name"""
  createdAt

  """column name"""
  followeeId

  """column name"""
  followeeIdChatbot

  """column name"""
  followerId
}

"""
input type for updating data in table "social_following"
"""
input SocialFollowingSetInput {
  createdAt: timestamptz
  followeeId: uuid
  followeeIdChatbot: Int
  followerId: uuid
}

"""aggregate stddev on columns"""
type SocialFollowingStddevFields {
  followeeIdChatbot: Float
}

"""
order by stddev() on columns of table "social_following"
"""
input SocialFollowingStddevOrderBy {
  followeeIdChatbot: OrderBy
}

"""aggregate stddevPop on columns"""
type SocialFollowingStddevPopFields {
  followeeIdChatbot: Float
}

"""
order by stddevPop() on columns of table "social_following"
"""
input SocialFollowingStddevPopOrderBy {
  followeeIdChatbot: OrderBy
}

"""aggregate stddevSamp on columns"""
type SocialFollowingStddevSampFields {
  followeeIdChatbot: Float
}

"""
order by stddevSamp() on columns of table "social_following"
"""
input SocialFollowingStddevSampOrderBy {
  followeeIdChatbot: OrderBy
}

"""
Streaming cursor of the table "social_following"
"""
input SocialFollowingStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: SocialFollowingStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input SocialFollowingStreamCursorValueInput {
  createdAt: timestamptz
  followeeId: uuid
  followeeIdChatbot: Int
  followerId: uuid
}

"""aggregate sum on columns"""
type SocialFollowingSumFields {
  followeeIdChatbot: Int
}

"""
order by sum() on columns of table "social_following"
"""
input SocialFollowingSumOrderBy {
  followeeIdChatbot: OrderBy
}

input SocialFollowingUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: SocialFollowingIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: SocialFollowingSetInput

  """filter the rows which have to be updated"""
  where: SocialFollowingBoolExp!
}

"""aggregate varPop on columns"""
type SocialFollowingVarPopFields {
  followeeIdChatbot: Float
}

"""
order by varPop() on columns of table "social_following"
"""
input SocialFollowingVarPopOrderBy {
  followeeIdChatbot: OrderBy
}

"""aggregate varSamp on columns"""
type SocialFollowingVarSampFields {
  followeeIdChatbot: Float
}

"""
order by varSamp() on columns of table "social_following"
"""
input SocialFollowingVarSampOrderBy {
  followeeIdChatbot: OrderBy
}

"""aggregate variance on columns"""
type SocialFollowingVarianceFields {
  followeeIdChatbot: Float
}

"""
order by variance() on columns of table "social_following"
"""
input SocialFollowingVarianceOrderBy {
  followeeIdChatbot: OrderBy
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input StringComparisonExp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _isNull: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

"""
columns and relationships of "subcategory_enum"
"""
type SubcategoryEnum {
  added: timestamptz!
  category: String!

  """An object relationship"""
  categoryEnumByDomainCategory: CategoryEnum

  """An object relationship"""
  category_enum: CategoryEnum!
  domain: String!

  """An array relationship"""
  examples(
    """distinct select on columns"""
    distinctOn: [ExampleSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ExampleOrderBy!]

    """filter the rows returned"""
    where: ExampleBoolExp
  ): [Example!]!

  """An aggregate relationship"""
  examplesAggregate(
    """distinct select on columns"""
    distinctOn: [ExampleSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ExampleOrderBy!]

    """filter the rows returned"""
    where: ExampleBoolExp
  ): ExampleAggregate!

  """An array relationship"""
  examplesByCategoryDomainSubcategory(
    """distinct select on columns"""
    distinctOn: [ExampleSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ExampleOrderBy!]

    """filter the rows returned"""
    where: ExampleBoolExp
  ): [Example!]!

  """An aggregate relationship"""
  examplesByCategoryDomainSubcategoryAggregate(
    """distinct select on columns"""
    distinctOn: [ExampleSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ExampleOrderBy!]

    """filter the rows returned"""
    where: ExampleBoolExp
  ): ExampleAggregate!
  name: String!
}

"""
aggregated selection of "subcategory_enum"
"""
type SubcategoryEnumAggregate {
  aggregate: SubcategoryEnumAggregateFields
  nodes: [SubcategoryEnum!]!
}

input SubcategoryEnumAggregateBoolExp {
  count: subcategoryEnumAggregateBoolExpCount
}

"""
aggregate fields of "subcategory_enum"
"""
type SubcategoryEnumAggregateFields {
  count(columns: [SubcategoryEnumSelectColumn!], distinct: Boolean): Int!
  max: SubcategoryEnumMaxFields
  min: SubcategoryEnumMinFields
}

"""
order by aggregate values of table "subcategory_enum"
"""
input SubcategoryEnumAggregateOrderBy {
  count: OrderBy
  max: SubcategoryEnumMaxOrderBy
  min: SubcategoryEnumMinOrderBy
}

"""
input type for inserting array relation for remote table "subcategory_enum"
"""
input SubcategoryEnumArrRelInsertInput {
  data: [SubcategoryEnumInsertInput!]!

  """upsert condition"""
  onConflict: SubcategoryEnumOnConflict
}

"""
Boolean expression to filter rows from the table "subcategory_enum". All fields are combined with a logical 'AND'.
"""
input SubcategoryEnumBoolExp {
  _and: [SubcategoryEnumBoolExp!]
  _not: SubcategoryEnumBoolExp
  _or: [SubcategoryEnumBoolExp!]
  added: TimestamptzComparisonExp
  category: StringComparisonExp
  categoryEnumByDomainCategory: CategoryEnumBoolExp
  category_enum: CategoryEnumBoolExp
  domain: StringComparisonExp
  examples: ExampleBoolExp
  examplesAggregate: ExampleAggregateBoolExp
  examplesByCategoryDomainSubcategory: ExampleBoolExp
  examplesByCategoryDomainSubcategoryAggregate: ExampleAggregateBoolExp
  name: StringComparisonExp
}

"""
unique or primary key constraints on table "subcategory_enum"
"""
enum SubcategoryEnumConstraint {
  """
  unique or primary key constraint on columns "domain", "category", "name"
  """
  subcategory_enum_pkey
}

"""
input type for inserting data into table "subcategory_enum"
"""
input SubcategoryEnumInsertInput {
  added: timestamptz
  category: String
  categoryEnumByDomainCategory: CategoryEnumObjRelInsertInput
  category_enum: CategoryEnumObjRelInsertInput
  domain: String
  examples: ExampleArrRelInsertInput
  examplesByCategoryDomainSubcategory: ExampleArrRelInsertInput
  name: String
}

"""aggregate max on columns"""
type SubcategoryEnumMaxFields {
  added: timestamptz
  category: String
  domain: String
  name: String
}

"""
order by max() on columns of table "subcategory_enum"
"""
input SubcategoryEnumMaxOrderBy {
  added: OrderBy
  category: OrderBy
  domain: OrderBy
  name: OrderBy
}

"""aggregate min on columns"""
type SubcategoryEnumMinFields {
  added: timestamptz
  category: String
  domain: String
  name: String
}

"""
order by min() on columns of table "subcategory_enum"
"""
input SubcategoryEnumMinOrderBy {
  added: OrderBy
  category: OrderBy
  domain: OrderBy
  name: OrderBy
}

"""
response of any mutation on the table "subcategory_enum"
"""
type SubcategoryEnumMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [SubcategoryEnum!]!
}

"""
input type for inserting object relation for remote table "subcategory_enum"
"""
input SubcategoryEnumObjRelInsertInput {
  data: SubcategoryEnumInsertInput!

  """upsert condition"""
  onConflict: SubcategoryEnumOnConflict
}

"""
on_conflict condition type for table "subcategory_enum"
"""
input SubcategoryEnumOnConflict {
  constraint: SubcategoryEnumConstraint!
  updateColumns: [SubcategoryEnumUpdateColumn!]! = []
  where: SubcategoryEnumBoolExp
}

"""Ordering options when selecting data from "subcategory_enum"."""
input SubcategoryEnumOrderBy {
  added: OrderBy
  category: OrderBy
  categoryEnumByDomainCategory: CategoryEnumOrderBy
  category_enum: CategoryEnumOrderBy
  domain: OrderBy
  examplesAggregate: ExampleAggregateOrderBy
  examplesByCategoryDomainSubcategoryAggregate: ExampleAggregateOrderBy
  name: OrderBy
}

"""primary key columns input for table: subcategory_enum"""
input SubcategoryEnumPkColumnsInput {
  category: String!
  domain: String!
  name: String!
}

"""
select columns of table "subcategory_enum"
"""
enum SubcategoryEnumSelectColumn {
  """column name"""
  added

  """column name"""
  category

  """column name"""
  domain

  """column name"""
  name
}

"""
input type for updating data in table "subcategory_enum"
"""
input SubcategoryEnumSetInput {
  added: timestamptz
  category: String
  domain: String
  name: String
}

"""
Streaming cursor of the table "subcategory_enum"
"""
input SubcategoryEnumStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: SubcategoryEnumStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input SubcategoryEnumStreamCursorValueInput {
  added: timestamptz
  category: String
  domain: String
  name: String
}

"""
update columns of table "subcategory_enum"
"""
enum SubcategoryEnumUpdateColumn {
  """column name"""
  added

  """column name"""
  category

  """column name"""
  domain

  """column name"""
  name
}

input SubcategoryEnumUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: SubcategoryEnumSetInput

  """filter the rows which have to be updated"""
  where: SubcategoryEnumBoolExp!
}

"""
columns and relationships of "tag_enum"
"""
type TagEnum {
  domain: String!

  """An object relationship"""
  domain_enum: DomainEnum!
  frequency: numeric!
  name: String!
  tagId: uuid!
}

"""
aggregated selection of "tag_enum"
"""
type TagEnumAggregate {
  aggregate: TagEnumAggregateFields
  nodes: [TagEnum!]!
}

input TagEnumAggregateBoolExp {
  count: tagEnumAggregateBoolExpCount
}

"""
aggregate fields of "tag_enum"
"""
type TagEnumAggregateFields {
  avg: TagEnumAvgFields
  count(columns: [TagEnumSelectColumn!], distinct: Boolean): Int!
  max: TagEnumMaxFields
  min: TagEnumMinFields
  stddev: TagEnumStddevFields
  stddevPop: TagEnumStddevPopFields
  stddevSamp: TagEnumStddevSampFields
  sum: TagEnumSumFields
  varPop: TagEnumVarPopFields
  varSamp: TagEnumVarSampFields
  variance: TagEnumVarianceFields
}

"""
order by aggregate values of table "tag_enum"
"""
input TagEnumAggregateOrderBy {
  avg: TagEnumAvgOrderBy
  count: OrderBy
  max: TagEnumMaxOrderBy
  min: TagEnumMinOrderBy
  stddev: TagEnumStddevOrderBy
  stddevPop: TagEnumStddevPopOrderBy
  stddevSamp: TagEnumStddevSampOrderBy
  sum: TagEnumSumOrderBy
  varPop: TagEnumVarPopOrderBy
  varSamp: TagEnumVarSampOrderBy
  variance: TagEnumVarianceOrderBy
}

"""
input type for inserting array relation for remote table "tag_enum"
"""
input TagEnumArrRelInsertInput {
  data: [TagEnumInsertInput!]!

  """upsert condition"""
  onConflict: TagEnumOnConflict
}

"""aggregate avg on columns"""
type TagEnumAvgFields {
  frequency: Float
}

"""
order by avg() on columns of table "tag_enum"
"""
input TagEnumAvgOrderBy {
  frequency: OrderBy
}

"""
Boolean expression to filter rows from the table "tag_enum". All fields are combined with a logical 'AND'.
"""
input TagEnumBoolExp {
  _and: [TagEnumBoolExp!]
  _not: TagEnumBoolExp
  _or: [TagEnumBoolExp!]
  domain: StringComparisonExp
  domain_enum: DomainEnumBoolExp
  frequency: NumericComparisonExp
  name: StringComparisonExp
  tagId: UuidComparisonExp
}

"""
unique or primary key constraints on table "tag_enum"
"""
enum TagEnumConstraint {
  """
  unique or primary key constraint on columns "domain", "name"
  """
  tag_enum_name_domain_key

  """
  unique or primary key constraint on columns "tag_id"
  """
  tag_enum_pkey
}

"""
input type for incrementing numeric columns in table "tag_enum"
"""
input TagEnumIncInput {
  frequency: numeric
}

"""
input type for inserting data into table "tag_enum"
"""
input TagEnumInsertInput {
  domain: String
  domain_enum: DomainEnumObjRelInsertInput
  frequency: numeric
  name: String
  tagId: uuid
}

"""aggregate max on columns"""
type TagEnumMaxFields {
  domain: String
  frequency: numeric
  name: String
  tagId: uuid
}

"""
order by max() on columns of table "tag_enum"
"""
input TagEnumMaxOrderBy {
  domain: OrderBy
  frequency: OrderBy
  name: OrderBy
  tagId: OrderBy
}

"""aggregate min on columns"""
type TagEnumMinFields {
  domain: String
  frequency: numeric
  name: String
  tagId: uuid
}

"""
order by min() on columns of table "tag_enum"
"""
input TagEnumMinOrderBy {
  domain: OrderBy
  frequency: OrderBy
  name: OrderBy
  tagId: OrderBy
}

"""
response of any mutation on the table "tag_enum"
"""
type TagEnumMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [TagEnum!]!
}

"""
on_conflict condition type for table "tag_enum"
"""
input TagEnumOnConflict {
  constraint: TagEnumConstraint!
  updateColumns: [TagEnumUpdateColumn!]! = []
  where: TagEnumBoolExp
}

"""Ordering options when selecting data from "tag_enum"."""
input TagEnumOrderBy {
  domain: OrderBy
  domain_enum: DomainEnumOrderBy
  frequency: OrderBy
  name: OrderBy
  tagId: OrderBy
}

"""primary key columns input for table: tag_enum"""
input TagEnumPkColumnsInput {
  tagId: uuid!
}

"""
select columns of table "tag_enum"
"""
enum TagEnumSelectColumn {
  """column name"""
  domain

  """column name"""
  frequency

  """column name"""
  name

  """column name"""
  tagId
}

"""
input type for updating data in table "tag_enum"
"""
input TagEnumSetInput {
  domain: String
  frequency: numeric
  name: String
  tagId: uuid
}

"""aggregate stddev on columns"""
type TagEnumStddevFields {
  frequency: Float
}

"""
order by stddev() on columns of table "tag_enum"
"""
input TagEnumStddevOrderBy {
  frequency: OrderBy
}

"""aggregate stddevPop on columns"""
type TagEnumStddevPopFields {
  frequency: Float
}

"""
order by stddevPop() on columns of table "tag_enum"
"""
input TagEnumStddevPopOrderBy {
  frequency: OrderBy
}

"""aggregate stddevSamp on columns"""
type TagEnumStddevSampFields {
  frequency: Float
}

"""
order by stddevSamp() on columns of table "tag_enum"
"""
input TagEnumStddevSampOrderBy {
  frequency: OrderBy
}

"""
Streaming cursor of the table "tag_enum"
"""
input TagEnumStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: TagEnumStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input TagEnumStreamCursorValueInput {
  domain: String
  frequency: numeric
  name: String
  tagId: uuid
}

"""aggregate sum on columns"""
type TagEnumSumFields {
  frequency: numeric
}

"""
order by sum() on columns of table "tag_enum"
"""
input TagEnumSumOrderBy {
  frequency: OrderBy
}

"""
update columns of table "tag_enum"
"""
enum TagEnumUpdateColumn {
  """column name"""
  domain

  """column name"""
  frequency

  """column name"""
  name

  """column name"""
  tagId
}

input TagEnumUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: TagEnumIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: TagEnumSetInput

  """filter the rows which have to be updated"""
  where: TagEnumBoolExp!
}

"""aggregate varPop on columns"""
type TagEnumVarPopFields {
  frequency: Float
}

"""
order by varPop() on columns of table "tag_enum"
"""
input TagEnumVarPopOrderBy {
  frequency: OrderBy
}

"""aggregate varSamp on columns"""
type TagEnumVarSampFields {
  frequency: Float
}

"""
order by varSamp() on columns of table "tag_enum"
"""
input TagEnumVarSampOrderBy {
  frequency: OrderBy
}

"""aggregate variance on columns"""
type TagEnumVarianceFields {
  frequency: Float
}

"""
order by variance() on columns of table "tag_enum"
"""
input TagEnumVarianceOrderBy {
  frequency: OrderBy
}

"""
columns and relationships of "thread"
"""
type Thread {
  """An object relationship"""
  chatbot: Chatbot!
  chatbotId: Int!
  createdAt: timestamptz!
  isApproved: Boolean
  isBlocked: Boolean
  isPublic: Boolean

  """An array relationship"""
  messages(
    """distinct select on columns"""
    distinctOn: [MessageSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MessageOrderBy!]

    """filter the rows returned"""
    where: MessageBoolExp
  ): [Message!]!

  """An aggregate relationship"""
  messagesAggregate(
    """distinct select on columns"""
    distinctOn: [MessageSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MessageOrderBy!]

    """filter the rows returned"""
    where: MessageBoolExp
  ): MessageAggregate!
  model: ModelsEnumEnum!

  """An object relationship"""
  modelsEnum: ModelsEnum!
  parentThreadId: uuid

  """An object relationship"""
  thread: Thread
  threadId: uuid!

  """An array relationship"""
  threads(
    """distinct select on columns"""
    distinctOn: [ThreadSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ThreadOrderBy!]

    """filter the rows returned"""
    where: ThreadBoolExp
  ): [Thread!]!

  """An aggregate relationship"""
  threadsAggregate(
    """distinct select on columns"""
    distinctOn: [ThreadSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ThreadOrderBy!]

    """filter the rows returned"""
    where: ThreadBoolExp
  ): ThreadAggregate!
  updatedAt: timestamptz!

  """An object relationship"""
  user: User
  userId: uuid
}

"""
aggregated selection of "thread"
"""
type ThreadAggregate {
  aggregate: ThreadAggregateFields
  nodes: [Thread!]!
}

input ThreadAggregateBoolExp {
  bool_and: threadAggregateBoolExpBool_and
  bool_or: threadAggregateBoolExpBool_or
  count: threadAggregateBoolExpCount
}

"""
aggregate fields of "thread"
"""
type ThreadAggregateFields {
  avg: ThreadAvgFields
  count(columns: [ThreadSelectColumn!], distinct: Boolean): Int!
  max: ThreadMaxFields
  min: ThreadMinFields
  stddev: ThreadStddevFields
  stddevPop: ThreadStddevPopFields
  stddevSamp: ThreadStddevSampFields
  sum: ThreadSumFields
  varPop: ThreadVarPopFields
  varSamp: ThreadVarSampFields
  variance: ThreadVarianceFields
}

"""
order by aggregate values of table "thread"
"""
input ThreadAggregateOrderBy {
  avg: ThreadAvgOrderBy
  count: OrderBy
  max: ThreadMaxOrderBy
  min: ThreadMinOrderBy
  stddev: ThreadStddevOrderBy
  stddevPop: ThreadStddevPopOrderBy
  stddevSamp: ThreadStddevSampOrderBy
  sum: ThreadSumOrderBy
  varPop: ThreadVarPopOrderBy
  varSamp: ThreadVarSampOrderBy
  variance: ThreadVarianceOrderBy
}

"""
input type for inserting array relation for remote table "thread"
"""
input ThreadArrRelInsertInput {
  data: [ThreadInsertInput!]!

  """upsert condition"""
  onConflict: ThreadOnConflict
}

"""aggregate avg on columns"""
type ThreadAvgFields {
  chatbotId: Float
}

"""
order by avg() on columns of table "thread"
"""
input ThreadAvgOrderBy {
  chatbotId: OrderBy
}

"""
Boolean expression to filter rows from the table "thread". All fields are combined with a logical 'AND'.
"""
input ThreadBoolExp {
  _and: [ThreadBoolExp!]
  _not: ThreadBoolExp
  _or: [ThreadBoolExp!]
  chatbot: ChatbotBoolExp
  chatbotId: IntComparisonExp
  createdAt: TimestamptzComparisonExp
  isApproved: BooleanComparisonExp
  isBlocked: BooleanComparisonExp
  isPublic: BooleanComparisonExp
  messages: MessageBoolExp
  messagesAggregate: MessageAggregateBoolExp
  model: ModelsEnumEnumComparisonExp
  modelsEnum: ModelsEnumBoolExp
  parentThreadId: UuidComparisonExp
  thread: ThreadBoolExp
  threadId: UuidComparisonExp
  threads: ThreadBoolExp
  threadsAggregate: ThreadAggregateBoolExp
  updatedAt: TimestamptzComparisonExp
  user: UserBoolExp
  userId: UuidComparisonExp
}

"""
unique or primary key constraints on table "thread"
"""
enum ThreadConstraint {
  """
  unique or primary key constraint on columns "thread_id"
  """
  thread_id_key

  """
  unique or primary key constraint on columns "thread_id"
  """
  thread_pkey
}

"""
input type for incrementing numeric columns in table "thread"
"""
input ThreadIncInput {
  chatbotId: Int
}

"""
input type for inserting data into table "thread"
"""
input ThreadInsertInput {
  chatbot: ChatbotObjRelInsertInput
  chatbotId: Int
  createdAt: timestamptz
  isApproved: Boolean
  isBlocked: Boolean
  isPublic: Boolean
  messages: MessageArrRelInsertInput
  model: ModelsEnumEnum
  modelsEnum: ModelsEnumObjRelInsertInput
  parentThreadId: uuid
  thread: ThreadObjRelInsertInput
  threadId: uuid
  threads: ThreadArrRelInsertInput
  updatedAt: timestamptz
  user: UserObjRelInsertInput
  userId: uuid
}

"""aggregate max on columns"""
type ThreadMaxFields {
  chatbotId: Int
  createdAt: timestamptz
  parentThreadId: uuid
  threadId: uuid
  updatedAt: timestamptz
  userId: uuid
}

"""
order by max() on columns of table "thread"
"""
input ThreadMaxOrderBy {
  chatbotId: OrderBy
  createdAt: OrderBy
  parentThreadId: OrderBy
  threadId: OrderBy
  updatedAt: OrderBy
  userId: OrderBy
}

"""aggregate min on columns"""
type ThreadMinFields {
  chatbotId: Int
  createdAt: timestamptz
  parentThreadId: uuid
  threadId: uuid
  updatedAt: timestamptz
  userId: uuid
}

"""
order by min() on columns of table "thread"
"""
input ThreadMinOrderBy {
  chatbotId: OrderBy
  createdAt: OrderBy
  parentThreadId: OrderBy
  threadId: OrderBy
  updatedAt: OrderBy
  userId: OrderBy
}

"""
response of any mutation on the table "thread"
"""
type ThreadMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Thread!]!
}

"""
input type for inserting object relation for remote table "thread"
"""
input ThreadObjRelInsertInput {
  data: ThreadInsertInput!

  """upsert condition"""
  onConflict: ThreadOnConflict
}

"""
on_conflict condition type for table "thread"
"""
input ThreadOnConflict {
  constraint: ThreadConstraint!
  updateColumns: [ThreadUpdateColumn!]! = []
  where: ThreadBoolExp
}

"""Ordering options when selecting data from "thread"."""
input ThreadOrderBy {
  chatbot: ChatbotOrderBy
  chatbotId: OrderBy
  createdAt: OrderBy
  isApproved: OrderBy
  isBlocked: OrderBy
  isPublic: OrderBy
  messagesAggregate: MessageAggregateOrderBy
  model: OrderBy
  modelsEnum: ModelsEnumOrderBy
  parentThreadId: OrderBy
  thread: ThreadOrderBy
  threadId: OrderBy
  threadsAggregate: ThreadAggregateOrderBy
  updatedAt: OrderBy
  user: UserOrderBy
  userId: OrderBy
}

"""primary key columns input for table: thread"""
input ThreadPkColumnsInput {
  threadId: uuid!
}

"""
select columns of table "thread"
"""
enum ThreadSelectColumn {
  """column name"""
  chatbotId

  """column name"""
  createdAt

  """column name"""
  isApproved

  """column name"""
  isBlocked

  """column name"""
  isPublic

  """column name"""
  model

  """column name"""
  parentThreadId

  """column name"""
  threadId

  """column name"""
  updatedAt

  """column name"""
  userId
}

"""
select "threadAggregateBoolExpBool_andArgumentsColumns" columns of table "thread"
"""
enum ThreadSelectColumnThreadAggregateBoolExpBool_andArgumentsColumns {
  """column name"""
  isApproved

  """column name"""
  isBlocked

  """column name"""
  isPublic
}

"""
select "threadAggregateBoolExpBool_orArgumentsColumns" columns of table "thread"
"""
enum ThreadSelectColumnThreadAggregateBoolExpBool_orArgumentsColumns {
  """column name"""
  isApproved

  """column name"""
  isBlocked

  """column name"""
  isPublic
}

"""
input type for updating data in table "thread"
"""
input ThreadSetInput {
  chatbotId: Int
  createdAt: timestamptz
  isApproved: Boolean
  isBlocked: Boolean
  isPublic: Boolean
  model: ModelsEnumEnum
  parentThreadId: uuid
  threadId: uuid
  updatedAt: timestamptz
  userId: uuid
}

"""aggregate stddev on columns"""
type ThreadStddevFields {
  chatbotId: Float
}

"""
order by stddev() on columns of table "thread"
"""
input ThreadStddevOrderBy {
  chatbotId: OrderBy
}

"""aggregate stddevPop on columns"""
type ThreadStddevPopFields {
  chatbotId: Float
}

"""
order by stddevPop() on columns of table "thread"
"""
input ThreadStddevPopOrderBy {
  chatbotId: OrderBy
}

"""aggregate stddevSamp on columns"""
type ThreadStddevSampFields {
  chatbotId: Float
}

"""
order by stddevSamp() on columns of table "thread"
"""
input ThreadStddevSampOrderBy {
  chatbotId: OrderBy
}

"""
Streaming cursor of the table "thread"
"""
input ThreadStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ThreadStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ThreadStreamCursorValueInput {
  chatbotId: Int
  createdAt: timestamptz
  isApproved: Boolean
  isBlocked: Boolean
  isPublic: Boolean
  model: ModelsEnumEnum
  parentThreadId: uuid
  threadId: uuid
  updatedAt: timestamptz
  userId: uuid
}

"""aggregate sum on columns"""
type ThreadSumFields {
  chatbotId: Int
}

"""
order by sum() on columns of table "thread"
"""
input ThreadSumOrderBy {
  chatbotId: OrderBy
}

"""
update columns of table "thread"
"""
enum ThreadUpdateColumn {
  """column name"""
  chatbotId

  """column name"""
  createdAt

  """column name"""
  isApproved

  """column name"""
  isBlocked

  """column name"""
  isPublic

  """column name"""
  model

  """column name"""
  parentThreadId

  """column name"""
  threadId

  """column name"""
  updatedAt

  """column name"""
  userId
}

input ThreadUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: ThreadIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: ThreadSetInput

  """filter the rows which have to be updated"""
  where: ThreadBoolExp!
}

"""aggregate varPop on columns"""
type ThreadVarPopFields {
  chatbotId: Float
}

"""
order by varPop() on columns of table "thread"
"""
input ThreadVarPopOrderBy {
  chatbotId: OrderBy
}

"""aggregate varSamp on columns"""
type ThreadVarSampFields {
  chatbotId: Float
}

"""
order by varSamp() on columns of table "thread"
"""
input ThreadVarSampOrderBy {
  chatbotId: OrderBy
}

"""aggregate variance on columns"""
type ThreadVarianceFields {
  chatbotId: Float
}

"""
order by variance() on columns of table "thread"
"""
input ThreadVarianceOrderBy {
  chatbotId: OrderBy
}

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input TimestamptzComparisonExp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _isNull: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""Tokens OTP for reset password and activate account """
type Token {
  token: String!
  tokenExpiry: timestamptz!

  """An array relationship"""
  userTokens(
    """distinct select on columns"""
    distinctOn: [UserTokenSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [UserTokenOrderBy!]

    """filter the rows returned"""
    where: UserTokenBoolExp
  ): [UserToken!]!

  """An aggregate relationship"""
  userTokensAggregate(
    """distinct select on columns"""
    distinctOn: [UserTokenSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [UserTokenOrderBy!]

    """filter the rows returned"""
    where: UserTokenBoolExp
  ): UserTokenAggregate!
}

"""
aggregated selection of "token"
"""
type TokenAggregate {
  aggregate: TokenAggregateFields
  nodes: [Token!]!
}

"""
aggregate fields of "token"
"""
type TokenAggregateFields {
  count(columns: [TokenSelectColumn!], distinct: Boolean): Int!
  max: TokenMaxFields
  min: TokenMinFields
}

"""
Boolean expression to filter rows from the table "token". All fields are combined with a logical 'AND'.
"""
input TokenBoolExp {
  _and: [TokenBoolExp!]
  _not: TokenBoolExp
  _or: [TokenBoolExp!]
  token: StringComparisonExp
  tokenExpiry: TimestamptzComparisonExp
  userTokens: UserTokenBoolExp
  userTokensAggregate: UserTokenAggregateBoolExp
}

"""
unique or primary key constraints on table "token"
"""
enum TokenConstraint {
  """
  unique or primary key constraint on columns "token"
  """
  token_pkey
}

"""
input type for inserting data into table "token"
"""
input TokenInsertInput {
  token: String
  tokenExpiry: timestamptz
  userTokens: UserTokenArrRelInsertInput
}

"""aggregate max on columns"""
type TokenMaxFields {
  token: String
  tokenExpiry: timestamptz
}

"""aggregate min on columns"""
type TokenMinFields {
  token: String
  tokenExpiry: timestamptz
}

"""
response of any mutation on the table "token"
"""
type TokenMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Token!]!
}

"""
input type for inserting object relation for remote table "token"
"""
input TokenObjRelInsertInput {
  data: TokenInsertInput!

  """upsert condition"""
  onConflict: TokenOnConflict
}

"""
on_conflict condition type for table "token"
"""
input TokenOnConflict {
  constraint: TokenConstraint!
  updateColumns: [TokenUpdateColumn!]! = []
  where: TokenBoolExp
}

"""Ordering options when selecting data from "token"."""
input TokenOrderBy {
  token: OrderBy
  tokenExpiry: OrderBy
  userTokensAggregate: UserTokenAggregateOrderBy
}

"""primary key columns input for table: token"""
input TokenPkColumnsInput {
  token: String!
}

"""
select columns of table "token"
"""
enum TokenSelectColumn {
  """column name"""
  token

  """column name"""
  tokenExpiry
}

"""
input type for updating data in table "token"
"""
input TokenSetInput {
  token: String
  tokenExpiry: timestamptz
}

"""
Streaming cursor of the table "token"
"""
input TokenStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: TokenStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input TokenStreamCursorValueInput {
  token: String
  tokenExpiry: timestamptz
}

"""
update columns of table "token"
"""
enum TokenUpdateColumn {
  """column name"""
  token

  """column name"""
  tokenExpiry
}

input TokenUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: TokenSetInput

  """filter the rows which have to be updated"""
  where: TokenBoolExp!
}

"""
columns and relationships of "tone_enum"
"""
type ToneEnum {
  """An array relationship"""
  chatbots(
    """distinct select on columns"""
    distinctOn: [ChatbotSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotOrderBy!]

    """filter the rows returned"""
    where: ChatbotBoolExp
  ): [Chatbot!]!

  """An aggregate relationship"""
  chatbotsAggregate(
    """distinct select on columns"""
    distinctOn: [ChatbotSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotOrderBy!]

    """filter the rows returned"""
    where: ChatbotBoolExp
  ): ChatbotAggregate!

  """An array relationship"""
  preferences(
    """distinct select on columns"""
    distinctOn: [PreferenceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PreferenceOrderBy!]

    """filter the rows returned"""
    where: PreferenceBoolExp
  ): [Preference!]!

  """An aggregate relationship"""
  preferencesAggregate(
    """distinct select on columns"""
    distinctOn: [PreferenceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PreferenceOrderBy!]

    """filter the rows returned"""
    where: PreferenceBoolExp
  ): PreferenceAggregate!
  prompt: String!
  value: String!
}

"""
aggregated selection of "tone_enum"
"""
type ToneEnumAggregate {
  aggregate: ToneEnumAggregateFields
  nodes: [ToneEnum!]!
}

"""
aggregate fields of "tone_enum"
"""
type ToneEnumAggregateFields {
  count(columns: [ToneEnumSelectColumn!], distinct: Boolean): Int!
  max: ToneEnumMaxFields
  min: ToneEnumMinFields
}

"""
Boolean expression to filter rows from the table "tone_enum". All fields are combined with a logical 'AND'.
"""
input ToneEnumBoolExp {
  _and: [ToneEnumBoolExp!]
  _not: ToneEnumBoolExp
  _or: [ToneEnumBoolExp!]
  chatbots: ChatbotBoolExp
  chatbotsAggregate: ChatbotAggregateBoolExp
  preferences: PreferenceBoolExp
  preferencesAggregate: PreferenceAggregateBoolExp
  prompt: StringComparisonExp
  value: StringComparisonExp
}

"""
unique or primary key constraints on table "tone_enum"
"""
enum ToneEnumConstraint {
  """
  unique or primary key constraint on columns "value"
  """
  default_tone_enum_pkey
}

"""
input type for inserting data into table "tone_enum"
"""
input ToneEnumInsertInput {
  chatbots: ChatbotArrRelInsertInput
  preferences: PreferenceArrRelInsertInput
  prompt: String
  value: String
}

"""aggregate max on columns"""
type ToneEnumMaxFields {
  prompt: String
  value: String
}

"""aggregate min on columns"""
type ToneEnumMinFields {
  prompt: String
  value: String
}

"""
response of any mutation on the table "tone_enum"
"""
type ToneEnumMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [ToneEnum!]!
}

"""
input type for inserting object relation for remote table "tone_enum"
"""
input ToneEnumObjRelInsertInput {
  data: ToneEnumInsertInput!

  """upsert condition"""
  onConflict: ToneEnumOnConflict
}

"""
on_conflict condition type for table "tone_enum"
"""
input ToneEnumOnConflict {
  constraint: ToneEnumConstraint!
  updateColumns: [ToneEnumUpdateColumn!]! = []
  where: ToneEnumBoolExp
}

"""Ordering options when selecting data from "tone_enum"."""
input ToneEnumOrderBy {
  chatbotsAggregate: ChatbotAggregateOrderBy
  preferencesAggregate: PreferenceAggregateOrderBy
  prompt: OrderBy
  value: OrderBy
}

"""primary key columns input for table: tone_enum"""
input ToneEnumPkColumnsInput {
  value: String!
}

"""
select columns of table "tone_enum"
"""
enum ToneEnumSelectColumn {
  """column name"""
  prompt

  """column name"""
  value
}

"""
input type for updating data in table "tone_enum"
"""
input ToneEnumSetInput {
  prompt: String
  value: String
}

"""
Streaming cursor of the table "tone_enum"
"""
input ToneEnumStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ToneEnumStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ToneEnumStreamCursorValueInput {
  prompt: String
  value: String
}

"""
update columns of table "tone_enum"
"""
enum ToneEnumUpdateColumn {
  """column name"""
  prompt

  """column name"""
  value
}

input ToneEnumUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: ToneEnumSetInput

  """filter the rows which have to be updated"""
  where: ToneEnumBoolExp!
}

"""
columns and relationships of "type_enum"
"""
type TypeEnum {
  """An array relationship"""
  chatbots(
    """distinct select on columns"""
    distinctOn: [ChatbotSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotOrderBy!]

    """filter the rows returned"""
    where: ChatbotBoolExp
  ): [Chatbot!]!

  """An aggregate relationship"""
  chatbotsAggregate(
    """distinct select on columns"""
    distinctOn: [ChatbotSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotOrderBy!]

    """filter the rows returned"""
    where: ChatbotBoolExp
  ): ChatbotAggregate!

  """An array relationship"""
  preferences(
    """distinct select on columns"""
    distinctOn: [PreferenceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PreferenceOrderBy!]

    """filter the rows returned"""
    where: PreferenceBoolExp
  ): [Preference!]!

  """An aggregate relationship"""
  preferencesAggregate(
    """distinct select on columns"""
    distinctOn: [PreferenceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PreferenceOrderBy!]

    """filter the rows returned"""
    where: PreferenceBoolExp
  ): PreferenceAggregate!
  prompt: String!
  value: String!
}

"""
aggregated selection of "type_enum"
"""
type TypeEnumAggregate {
  aggregate: TypeEnumAggregateFields
  nodes: [TypeEnum!]!
}

"""
aggregate fields of "type_enum"
"""
type TypeEnumAggregateFields {
  count(columns: [TypeEnumSelectColumn!], distinct: Boolean): Int!
  max: TypeEnumMaxFields
  min: TypeEnumMinFields
}

"""
Boolean expression to filter rows from the table "type_enum". All fields are combined with a logical 'AND'.
"""
input TypeEnumBoolExp {
  _and: [TypeEnumBoolExp!]
  _not: TypeEnumBoolExp
  _or: [TypeEnumBoolExp!]
  chatbots: ChatbotBoolExp
  chatbotsAggregate: ChatbotAggregateBoolExp
  preferences: PreferenceBoolExp
  preferencesAggregate: PreferenceAggregateBoolExp
  prompt: StringComparisonExp
  value: StringComparisonExp
}

"""
unique or primary key constraints on table "type_enum"
"""
enum TypeEnumConstraint {
  """
  unique or primary key constraint on columns "value"
  """
  default_type_enum_pkey
}

"""
input type for inserting data into table "type_enum"
"""
input TypeEnumInsertInput {
  chatbots: ChatbotArrRelInsertInput
  preferences: PreferenceArrRelInsertInput
  prompt: String
  value: String
}

"""aggregate max on columns"""
type TypeEnumMaxFields {
  prompt: String
  value: String
}

"""aggregate min on columns"""
type TypeEnumMinFields {
  prompt: String
  value: String
}

"""
response of any mutation on the table "type_enum"
"""
type TypeEnumMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [TypeEnum!]!
}

"""
input type for inserting object relation for remote table "type_enum"
"""
input TypeEnumObjRelInsertInput {
  data: TypeEnumInsertInput!

  """upsert condition"""
  onConflict: TypeEnumOnConflict
}

"""
on_conflict condition type for table "type_enum"
"""
input TypeEnumOnConflict {
  constraint: TypeEnumConstraint!
  updateColumns: [TypeEnumUpdateColumn!]! = []
  where: TypeEnumBoolExp
}

"""Ordering options when selecting data from "type_enum"."""
input TypeEnumOrderBy {
  chatbotsAggregate: ChatbotAggregateOrderBy
  preferencesAggregate: PreferenceAggregateOrderBy
  prompt: OrderBy
  value: OrderBy
}

"""primary key columns input for table: type_enum"""
input TypeEnumPkColumnsInput {
  value: String!
}

"""
select columns of table "type_enum"
"""
enum TypeEnumSelectColumn {
  """column name"""
  prompt

  """column name"""
  value
}

"""
input type for updating data in table "type_enum"
"""
input TypeEnumSetInput {
  prompt: String
  value: String
}

"""
Streaming cursor of the table "type_enum"
"""
input TypeEnumStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: TypeEnumStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input TypeEnumStreamCursorValueInput {
  prompt: String
  value: String
}

"""
update columns of table "type_enum"
"""
enum TypeEnumUpdateColumn {
  """column name"""
  prompt

  """column name"""
  value
}

input TypeEnumUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: TypeEnumSetInput

  """filter the rows which have to be updated"""
  where: TypeEnumBoolExp!
}

"""Table storing information about registered users."""
type User {
  bio: String
  dateJoined: timestamptz!
  email: String!
  favouriteTopic: String

  """An array relationship"""
  followers(
    """distinct select on columns"""
    distinctOn: [SocialFollowingSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [SocialFollowingOrderBy!]

    """filter the rows returned"""
    where: SocialFollowingBoolExp
  ): [SocialFollowing!]!

  """An aggregate relationship"""
  followersAggregate(
    """distinct select on columns"""
    distinctOn: [SocialFollowingSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [SocialFollowingOrderBy!]

    """filter the rows returned"""
    where: SocialFollowingBoolExp
  ): SocialFollowingAggregate!

  """An array relationship"""
  following(
    """distinct select on columns"""
    distinctOn: [SocialFollowingSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [SocialFollowingOrderBy!]

    """filter the rows returned"""
    where: SocialFollowingBoolExp
  ): [SocialFollowing!]!

  """An aggregate relationship"""
  followingAggregate(
    """distinct select on columns"""
    distinctOn: [SocialFollowingSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [SocialFollowingOrderBy!]

    """filter the rows returned"""
    where: SocialFollowingBoolExp
  ): SocialFollowingAggregate!
  getFreeMonth: Boolean
  isBlocked: Boolean
  isVerified: Boolean
  lastLogin: timestamptz
  password: String!

  """An array relationship"""
  preferences(
    """distinct select on columns"""
    distinctOn: [PreferenceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PreferenceOrderBy!]

    """filter the rows returned"""
    where: PreferenceBoolExp
  ): [Preference!]!

  """An aggregate relationship"""
  preferencesAggregate(
    """distinct select on columns"""
    distinctOn: [PreferenceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PreferenceOrderBy!]

    """filter the rows returned"""
    where: PreferenceBoolExp
  ): PreferenceAggregate!
  proUserSubscriptionId: String!
  profilePicture: String

  """An array relationship"""
  prompts(
    """distinct select on columns"""
    distinctOn: [PromptUserSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptUserOrderBy!]

    """filter the rows returned"""
    where: PromptUserBoolExp
  ): [PromptUser!]!

  """An aggregate relationship"""
  promptsAggregate(
    """distinct select on columns"""
    distinctOn: [PromptUserSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptUserOrderBy!]

    """filter the rows returned"""
    where: PromptUserBoolExp
  ): PromptUserAggregate!

  """An array relationship"""
  referrals(
    """distinct select on columns"""
    distinctOn: [ReferralSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ReferralOrderBy!]

    """filter the rows returned"""
    where: ReferralBoolExp
  ): [Referral!]!

  """An aggregate relationship"""
  referralsAggregate(
    """distinct select on columns"""
    distinctOn: [ReferralSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ReferralOrderBy!]

    """filter the rows returned"""
    where: ReferralBoolExp
  ): ReferralAggregate!

  """An array relationship"""
  referralsByUserId(
    """distinct select on columns"""
    distinctOn: [ReferralSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ReferralOrderBy!]

    """filter the rows returned"""
    where: ReferralBoolExp
  ): [Referral!]!

  """An aggregate relationship"""
  referralsByUserIdAggregate(
    """distinct select on columns"""
    distinctOn: [ReferralSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ReferralOrderBy!]

    """filter the rows returned"""
    where: ReferralBoolExp
  ): ReferralAggregate!
  role: user_role!
  slug: String!

  """An array relationship"""
  threads(
    """distinct select on columns"""
    distinctOn: [ThreadSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ThreadOrderBy!]

    """filter the rows returned"""
    where: ThreadBoolExp
  ): [Thread!]!

  """An aggregate relationship"""
  threadsAggregate(
    """distinct select on columns"""
    distinctOn: [ThreadSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ThreadOrderBy!]

    """filter the rows returned"""
    where: ThreadBoolExp
  ): ThreadAggregate!
  userId: uuid!

  """An array relationship"""
  userTokens(
    """distinct select on columns"""
    distinctOn: [UserTokenSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [UserTokenOrderBy!]

    """filter the rows returned"""
    where: UserTokenBoolExp
  ): [UserToken!]!

  """An aggregate relationship"""
  userTokensAggregate(
    """distinct select on columns"""
    distinctOn: [UserTokenSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [UserTokenOrderBy!]

    """filter the rows returned"""
    where: UserTokenBoolExp
  ): UserTokenAggregate!
  username: String!
}

"""
aggregated selection of "user"
"""
type UserAggregate {
  aggregate: UserAggregateFields
  nodes: [User!]!
}

"""
aggregate fields of "user"
"""
type UserAggregateFields {
  count(columns: [UserSelectColumn!], distinct: Boolean): Int!
  max: UserMaxFields
  min: UserMinFields
}

"""
Boolean expression to filter rows from the table "user". All fields are combined with a logical 'AND'.
"""
input UserBoolExp {
  _and: [UserBoolExp!]
  _not: UserBoolExp
  _or: [UserBoolExp!]
  bio: StringComparisonExp
  dateJoined: TimestamptzComparisonExp
  email: StringComparisonExp
  favouriteTopic: StringComparisonExp
  followers: SocialFollowingBoolExp
  followersAggregate: SocialFollowingAggregateBoolExp
  following: SocialFollowingBoolExp
  followingAggregate: SocialFollowingAggregateBoolExp
  getFreeMonth: BooleanComparisonExp
  isBlocked: BooleanComparisonExp
  isVerified: BooleanComparisonExp
  lastLogin: TimestamptzComparisonExp
  password: StringComparisonExp
  preferences: PreferenceBoolExp
  preferencesAggregate: PreferenceAggregateBoolExp
  proUserSubscriptionId: StringComparisonExp
  profilePicture: StringComparisonExp
  prompts: PromptUserBoolExp
  promptsAggregate: PromptUserAggregateBoolExp
  referrals: ReferralBoolExp
  referralsAggregate: ReferralAggregateBoolExp
  referralsByUserId: ReferralBoolExp
  referralsByUserIdAggregate: ReferralAggregateBoolExp
  role: UserRoleComparisonExp
  slug: StringComparisonExp
  threads: ThreadBoolExp
  threadsAggregate: ThreadAggregateBoolExp
  userId: UuidComparisonExp
  userTokens: UserTokenBoolExp
  userTokensAggregate: UserTokenAggregateBoolExp
  username: StringComparisonExp
}

"""
unique or primary key constraints on table "user"
"""
enum UserConstraint {
  """
  unique or primary key constraint on columns "slug"
  """
  unique_slug

  """
  unique or primary key constraint on columns "email"
  """
  user_email_key

  """
  unique or primary key constraint on columns "user_id"
  """
  user_pkey

  """
  unique or primary key constraint on columns "username"
  """
  user_username_key
}

"""
input type for inserting data into table "user"
"""
input UserInsertInput {
  bio: String
  dateJoined: timestamptz
  email: String
  favouriteTopic: String
  followers: SocialFollowingArrRelInsertInput
  following: SocialFollowingArrRelInsertInput
  getFreeMonth: Boolean
  isBlocked: Boolean
  isVerified: Boolean
  lastLogin: timestamptz
  password: String
  preferences: PreferenceArrRelInsertInput
  proUserSubscriptionId: String
  profilePicture: String
  prompts: PromptUserArrRelInsertInput
  referrals: ReferralArrRelInsertInput
  referralsByUserId: ReferralArrRelInsertInput
  role: user_role
  slug: String
  threads: ThreadArrRelInsertInput
  userId: uuid
  userTokens: UserTokenArrRelInsertInput
  username: String
}

"""aggregate max on columns"""
type UserMaxFields {
  bio: String
  dateJoined: timestamptz
  email: String
  favouriteTopic: String
  lastLogin: timestamptz
  password: String
  proUserSubscriptionId: String
  profilePicture: String
  role: user_role
  slug: String
  userId: uuid
  username: String
}

"""aggregate min on columns"""
type UserMinFields {
  bio: String
  dateJoined: timestamptz
  email: String
  favouriteTopic: String
  lastLogin: timestamptz
  password: String
  proUserSubscriptionId: String
  profilePicture: String
  role: user_role
  slug: String
  userId: uuid
  username: String
}

"""
response of any mutation on the table "user"
"""
type UserMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [User!]!
}

"""
input type for inserting object relation for remote table "user"
"""
input UserObjRelInsertInput {
  data: UserInsertInput!

  """upsert condition"""
  onConflict: UserOnConflict
}

"""
on_conflict condition type for table "user"
"""
input UserOnConflict {
  constraint: UserConstraint!
  updateColumns: [UserUpdateColumn!]! = []
  where: UserBoolExp
}

"""Ordering options when selecting data from "user"."""
input UserOrderBy {
  bio: OrderBy
  dateJoined: OrderBy
  email: OrderBy
  favouriteTopic: OrderBy
  followersAggregate: SocialFollowingAggregateOrderBy
  followingAggregate: SocialFollowingAggregateOrderBy
  getFreeMonth: OrderBy
  isBlocked: OrderBy
  isVerified: OrderBy
  lastLogin: OrderBy
  password: OrderBy
  preferencesAggregate: PreferenceAggregateOrderBy
  proUserSubscriptionId: OrderBy
  profilePicture: OrderBy
  promptsAggregate: PromptUserAggregateOrderBy
  referralsAggregate: ReferralAggregateOrderBy
  referralsByUserIdAggregate: ReferralAggregateOrderBy
  role: OrderBy
  slug: OrderBy
  threadsAggregate: ThreadAggregateOrderBy
  userId: OrderBy
  userTokensAggregate: UserTokenAggregateOrderBy
  username: OrderBy
}

"""primary key columns input for table: user"""
input UserPkColumnsInput {
  userId: uuid!
}

"""
Boolean expression to compare columns of type "user_role". All fields are combined with logical 'AND'.
"""
input UserRoleComparisonExp {
  _eq: user_role
  _gt: user_role
  _gte: user_role
  _in: [user_role!]
  _isNull: Boolean
  _lt: user_role
  _lte: user_role
  _neq: user_role
  _nin: [user_role!]
}

"""
select columns of table "user"
"""
enum UserSelectColumn {
  """column name"""
  bio

  """column name"""
  dateJoined

  """column name"""
  email

  """column name"""
  favouriteTopic

  """column name"""
  getFreeMonth

  """column name"""
  isBlocked

  """column name"""
  isVerified

  """column name"""
  lastLogin

  """column name"""
  password

  """column name"""
  proUserSubscriptionId

  """column name"""
  profilePicture

  """column name"""
  role

  """column name"""
  slug

  """column name"""
  userId

  """column name"""
  username
}

"""
input type for updating data in table "user"
"""
input UserSetInput {
  bio: String
  dateJoined: timestamptz
  email: String
  favouriteTopic: String
  getFreeMonth: Boolean
  isBlocked: Boolean
  isVerified: Boolean
  lastLogin: timestamptz
  password: String
  proUserSubscriptionId: String
  profilePicture: String
  role: user_role
  slug: String
  userId: uuid
  username: String
}

"""
Streaming cursor of the table "user"
"""
input UserStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: UserStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input UserStreamCursorValueInput {
  bio: String
  dateJoined: timestamptz
  email: String
  favouriteTopic: String
  getFreeMonth: Boolean
  isBlocked: Boolean
  isVerified: Boolean
  lastLogin: timestamptz
  password: String
  proUserSubscriptionId: String
  profilePicture: String
  role: user_role
  slug: String
  userId: uuid
  username: String
}

"""user <> token relationship OTP (reset password/activate account) """
type UserToken {
  token: String!

  """An object relationship"""
  tokenByToken: Token!

  """An object relationship"""
  user: User!
  userId: uuid!
}

"""
aggregated selection of "user_token"
"""
type UserTokenAggregate {
  aggregate: UserTokenAggregateFields
  nodes: [UserToken!]!
}

input UserTokenAggregateBoolExp {
  count: userTokenAggregateBoolExpCount
}

"""
aggregate fields of "user_token"
"""
type UserTokenAggregateFields {
  count(columns: [UserTokenSelectColumn!], distinct: Boolean): Int!
  max: UserTokenMaxFields
  min: UserTokenMinFields
}

"""
order by aggregate values of table "user_token"
"""
input UserTokenAggregateOrderBy {
  count: OrderBy
  max: UserTokenMaxOrderBy
  min: UserTokenMinOrderBy
}

"""
input type for inserting array relation for remote table "user_token"
"""
input UserTokenArrRelInsertInput {
  data: [UserTokenInsertInput!]!

  """upsert condition"""
  onConflict: UserTokenOnConflict
}

"""
Boolean expression to filter rows from the table "user_token". All fields are combined with a logical 'AND'.
"""
input UserTokenBoolExp {
  _and: [UserTokenBoolExp!]
  _not: UserTokenBoolExp
  _or: [UserTokenBoolExp!]
  token: StringComparisonExp
  tokenByToken: TokenBoolExp
  user: UserBoolExp
  userId: UuidComparisonExp
}

"""
unique or primary key constraints on table "user_token"
"""
enum UserTokenConstraint {
  """
  unique or primary key constraint on columns "user_id", "token"
  """
  user_token_pkey
}

"""
input type for inserting data into table "user_token"
"""
input UserTokenInsertInput {
  token: String
  tokenByToken: TokenObjRelInsertInput
  user: UserObjRelInsertInput
  userId: uuid
}

"""aggregate max on columns"""
type UserTokenMaxFields {
  token: String
  userId: uuid
}

"""
order by max() on columns of table "user_token"
"""
input UserTokenMaxOrderBy {
  token: OrderBy
  userId: OrderBy
}

"""aggregate min on columns"""
type UserTokenMinFields {
  token: String
  userId: uuid
}

"""
order by min() on columns of table "user_token"
"""
input UserTokenMinOrderBy {
  token: OrderBy
  userId: OrderBy
}

"""
response of any mutation on the table "user_token"
"""
type UserTokenMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [UserToken!]!
}

"""
on_conflict condition type for table "user_token"
"""
input UserTokenOnConflict {
  constraint: UserTokenConstraint!
  updateColumns: [UserTokenUpdateColumn!]! = []
  where: UserTokenBoolExp
}

"""Ordering options when selecting data from "user_token"."""
input UserTokenOrderBy {
  token: OrderBy
  tokenByToken: TokenOrderBy
  user: UserOrderBy
  userId: OrderBy
}

"""primary key columns input for table: user_token"""
input UserTokenPkColumnsInput {
  token: String!
  userId: uuid!
}

"""
select columns of table "user_token"
"""
enum UserTokenSelectColumn {
  """column name"""
  token

  """column name"""
  userId
}

"""
input type for updating data in table "user_token"
"""
input UserTokenSetInput {
  token: String
  userId: uuid
}

"""
Streaming cursor of the table "user_token"
"""
input UserTokenStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: UserTokenStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input UserTokenStreamCursorValueInput {
  token: String
  userId: uuid
}

"""
update columns of table "user_token"
"""
enum UserTokenUpdateColumn {
  """column name"""
  token

  """column name"""
  userId
}

input UserTokenUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: UserTokenSetInput

  """filter the rows which have to be updated"""
  where: UserTokenBoolExp!
}

"""
update columns of table "user"
"""
enum UserUpdateColumn {
  """column name"""
  bio

  """column name"""
  dateJoined

  """column name"""
  email

  """column name"""
  favouriteTopic

  """column name"""
  getFreeMonth

  """column name"""
  isBlocked

  """column name"""
  isVerified

  """column name"""
  lastLogin

  """column name"""
  password

  """column name"""
  proUserSubscriptionId

  """column name"""
  profilePicture

  """column name"""
  role

  """column name"""
  slug

  """column name"""
  userId

  """column name"""
  username
}

input UserUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: UserSetInput

  """filter the rows which have to be updated"""
  where: UserBoolExp!
}

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input UuidArrayComparisonExp {
  """is the array contained in the given array value"""
  _containedIn: [uuid!]

  """does the array contain the given value"""
  _contains: [uuid!]
  _eq: [uuid!]
  _gt: [uuid!]
  _gte: [uuid!]
  _in: [[uuid!]!]
  _isNull: Boolean
  _lt: [uuid!]
  _lte: [uuid!]
  _neq: [uuid!]
  _nin: [[uuid!]!]
}

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input UuidComparisonExp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _isNull: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

input categoryEnumAggregateBoolExpCount {
  arguments: [CategoryEnumSelectColumn!]
  distinct: Boolean
  filter: CategoryEnumBoolExp
  predicate: IntComparisonExp!
}

input chatbotAggregateBoolExpCount {
  arguments: [ChatbotSelectColumn!]
  distinct: Boolean
  filter: ChatbotBoolExp
  predicate: IntComparisonExp!
}

input chatbotCategoryAggregateBoolExpCount {
  arguments: [ChatbotCategorySelectColumn!]
  distinct: Boolean
  filter: ChatbotCategoryBoolExp
  predicate: IntComparisonExp!
}

input chatbotDomainAggregateBoolExpCount {
  arguments: [ChatbotDomainSelectColumn!]
  distinct: Boolean
  filter: ChatbotDomainBoolExp
  predicate: IntComparisonExp!
}

input exampleAggregateBoolExpCount {
  arguments: [ExampleSelectColumn!]
  distinct: Boolean
  filter: ExampleBoolExp
  predicate: IntComparisonExp!
}

scalar jsonb

input messageAggregateBoolExpCount {
  arguments: [MessageSelectColumn!]
  distinct: Boolean
  filter: MessageBoolExp
  predicate: IntComparisonExp!
}

"""mutation root"""
type mutation_root {
  """
  delete data from the table: "category"
  """
  deleteCategory(
    """filter the rows which have to be deleted"""
    where: CategoryBoolExp!
  ): CategoryMutationResponse

  """
  delete single row from the table: "category"
  """
  deleteCategoryByPk(categoryId: Int!): Category

  """
  delete data from the table: "category_enum"
  """
  deleteCategoryEnum(
    """filter the rows which have to be deleted"""
    where: CategoryEnumBoolExp!
  ): CategoryEnumMutationResponse

  """
  delete single row from the table: "category_enum"
  """
  deleteCategoryEnumByPk(domain: String!, name: String!): CategoryEnum

  """
  delete data from the table: "chatbot"
  """
  deleteChatbot(
    """filter the rows which have to be deleted"""
    where: ChatbotBoolExp!
  ): ChatbotMutationResponse

  """
  delete single row from the table: "chatbot"
  """
  deleteChatbotByPk(chatbotId: Int!): Chatbot

  """
  delete data from the table: "chatbot_category"
  """
  deleteChatbotCategory(
    """filter the rows which have to be deleted"""
    where: ChatbotCategoryBoolExp!
  ): ChatbotCategoryMutationResponse

  """
  delete single row from the table: "chatbot_category"
  """
  deleteChatbotCategoryByPk(categoryId: Int!, chatbotId: Int!): ChatbotCategory

  """
  delete data from the table: "chatbot_domain"
  """
  deleteChatbotDomain(
    """filter the rows which have to be deleted"""
    where: ChatbotDomainBoolExp!
  ): ChatbotDomainMutationResponse

  """
  delete single row from the table: "chatbot_domain"
  """
  deleteChatbotDomainByPk(chatbotId: Int!, domainName: String!): ChatbotDomain

  """
  delete data from the table: "complexity_enum"
  """
  deleteComplexityEnum(
    """filter the rows which have to be deleted"""
    where: ComplexityEnumBoolExp!
  ): ComplexityEnumMutationResponse

  """
  delete single row from the table: "complexity_enum"
  """
  deleteComplexityEnumByPk(value: String!): ComplexityEnum

  """
  delete data from the table: "domain_enum"
  """
  deleteDomainEnum(
    """filter the rows which have to be deleted"""
    where: DomainEnumBoolExp!
  ): DomainEnumMutationResponse

  """
  delete single row from the table: "domain_enum"
  """
  deleteDomainEnumByPk(name: String!): DomainEnum

  """
  delete data from the table: "example"
  """
  deleteExample(
    """filter the rows which have to be deleted"""
    where: ExampleBoolExp!
  ): ExampleMutationResponse

  """
  delete single row from the table: "example"
  """
  deleteExampleByPk(exampleId: uuid!): Example

  """
  delete data from the table: "length_enum"
  """
  deleteLengthEnum(
    """filter the rows which have to be deleted"""
    where: LengthEnumBoolExp!
  ): LengthEnumMutationResponse

  """
  delete single row from the table: "length_enum"
  """
  deleteLengthEnumByPk(value: String!): LengthEnum

  """
  delete data from the table: "message"
  """
  deleteMessage(
    """filter the rows which have to be deleted"""
    where: MessageBoolExp!
  ): MessageMutationResponse

  """
  delete single row from the table: "message"
  """
  deleteMessageByPk(messageId: uuid!): Message

  """
  delete data from the table: "message_type_enum"
  """
  deleteMessageTypeEnum(
    """filter the rows which have to be deleted"""
    where: MessageTypeEnumBoolExp!
  ): MessageTypeEnumMutationResponse

  """
  delete single row from the table: "message_type_enum"
  """
  deleteMessageTypeEnumByPk(value: String!): MessageTypeEnum

  """
  delete data from the table: "models_enum"
  """
  deleteModelsEnum(
    """filter the rows which have to be deleted"""
    where: ModelsEnumBoolExp!
  ): ModelsEnumMutationResponse

  """
  delete single row from the table: "models_enum"
  """
  deleteModelsEnumByPk(name: String!): ModelsEnum

  """
  delete data from the table: "preference"
  """
  deletePreference(
    """filter the rows which have to be deleted"""
    where: PreferenceBoolExp!
  ): PreferenceMutationResponse

  """
  delete single row from the table: "preference"
  """
  deletePreferenceByPk(preferenceId: Int!): Preference

  """
  delete data from the table: "prompt"
  """
  deletePrompt(
    """filter the rows which have to be deleted"""
    where: PromptBoolExp!
  ): PromptMutationResponse

  """
  delete single row from the table: "prompt"
  """
  deletePromptByPk(promptId: Int!): Prompt

  """
  delete data from the table: "prompt_chatbot"
  """
  deletePromptChatbot(
    """filter the rows which have to be deleted"""
    where: PromptChatbotBoolExp!
  ): PromptChatbotMutationResponse

  """
  delete single row from the table: "prompt_chatbot"
  """
  deletePromptChatbotByPk(chabotId: Int!, promptId: Int!): PromptChatbot

  """
  delete data from the table: "prompt_type_enum"
  """
  deletePromptTypeEnum(
    """filter the rows which have to be deleted"""
    where: PromptTypeEnumBoolExp!
  ): PromptTypeEnumMutationResponse

  """
  delete single row from the table: "prompt_type_enum"
  """
  deletePromptTypeEnumByPk(value: String!): PromptTypeEnum

  """
  delete data from the table: "prompt_user"
  """
  deletePromptUser(
    """filter the rows which have to be deleted"""
    where: PromptUserBoolExp!
  ): PromptUserMutationResponse

  """
  delete single row from the table: "prompt_user"
  """
  deletePromptUserByPk(promptId: Int!, userId: uuid!): PromptUser

  """
  delete data from the table: "referral"
  """
  deleteReferral(
    """filter the rows which have to be deleted"""
    where: ReferralBoolExp!
  ): ReferralMutationResponse

  """
  delete single row from the table: "referral"
  """
  deleteReferralByPk(referralCode: String!): Referral

  """
  delete data from the table: "social_following"
  """
  deleteSocialFollowing(
    """filter the rows which have to be deleted"""
    where: SocialFollowingBoolExp!
  ): SocialFollowingMutationResponse

  """
  delete data from the table: "subcategory_enum"
  """
  deleteSubcategoryEnum(
    """filter the rows which have to be deleted"""
    where: SubcategoryEnumBoolExp!
  ): SubcategoryEnumMutationResponse

  """
  delete single row from the table: "subcategory_enum"
  """
  deleteSubcategoryEnumByPk(category: String!, domain: String!, name: String!): SubcategoryEnum

  """
  delete data from the table: "tag_enum"
  """
  deleteTagEnum(
    """filter the rows which have to be deleted"""
    where: TagEnumBoolExp!
  ): TagEnumMutationResponse

  """
  delete single row from the table: "tag_enum"
  """
  deleteTagEnumByPk(tagId: uuid!): TagEnum

  """
  delete data from the table: "thread"
  """
  deleteThread(
    """filter the rows which have to be deleted"""
    where: ThreadBoolExp!
  ): ThreadMutationResponse

  """
  delete single row from the table: "thread"
  """
  deleteThreadByPk(threadId: uuid!): Thread

  """
  delete data from the table: "token"
  """
  deleteToken(
    """filter the rows which have to be deleted"""
    where: TokenBoolExp!
  ): TokenMutationResponse

  """
  delete single row from the table: "token"
  """
  deleteTokenByPk(token: String!): Token

  """
  delete data from the table: "tone_enum"
  """
  deleteToneEnum(
    """filter the rows which have to be deleted"""
    where: ToneEnumBoolExp!
  ): ToneEnumMutationResponse

  """
  delete single row from the table: "tone_enum"
  """
  deleteToneEnumByPk(value: String!): ToneEnum

  """
  delete data from the table: "type_enum"
  """
  deleteTypeEnum(
    """filter the rows which have to be deleted"""
    where: TypeEnumBoolExp!
  ): TypeEnumMutationResponse

  """
  delete single row from the table: "type_enum"
  """
  deleteTypeEnumByPk(value: String!): TypeEnum

  """
  delete data from the table: "user"
  """
  deleteUser(
    """filter the rows which have to be deleted"""
    where: UserBoolExp!
  ): UserMutationResponse

  """
  delete single row from the table: "user"
  """
  deleteUserByPk(userId: uuid!): User

  """
  delete data from the table: "user_token"
  """
  deleteUserToken(
    """filter the rows which have to be deleted"""
    where: UserTokenBoolExp!
  ): UserTokenMutationResponse

  """
  delete single row from the table: "user_token"
  """
  deleteUserTokenByPk(token: String!, userId: uuid!): UserToken

  """
  insert data into the table: "category"
  """
  insertCategory(
    """the rows to be inserted"""
    objects: [CategoryInsertInput!]!

    """upsert condition"""
    onConflict: CategoryOnConflict
  ): CategoryMutationResponse

  """
  insert data into the table: "category_enum"
  """
  insertCategoryEnum(
    """the rows to be inserted"""
    objects: [CategoryEnumInsertInput!]!

    """upsert condition"""
    onConflict: CategoryEnumOnConflict
  ): CategoryEnumMutationResponse

  """
  insert a single row into the table: "category_enum"
  """
  insertCategoryEnumOne(
    """the row to be inserted"""
    object: CategoryEnumInsertInput!

    """upsert condition"""
    onConflict: CategoryEnumOnConflict
  ): CategoryEnum

  """
  insert a single row into the table: "category"
  """
  insertCategoryOne(
    """the row to be inserted"""
    object: CategoryInsertInput!

    """upsert condition"""
    onConflict: CategoryOnConflict
  ): Category

  """
  insert data into the table: "chatbot"
  """
  insertChatbot(
    """the rows to be inserted"""
    objects: [ChatbotInsertInput!]!

    """upsert condition"""
    onConflict: ChatbotOnConflict
  ): ChatbotMutationResponse

  """
  insert data into the table: "chatbot_category"
  """
  insertChatbotCategory(
    """the rows to be inserted"""
    objects: [ChatbotCategoryInsertInput!]!

    """upsert condition"""
    onConflict: ChatbotCategoryOnConflict
  ): ChatbotCategoryMutationResponse

  """
  insert a single row into the table: "chatbot_category"
  """
  insertChatbotCategoryOne(
    """the row to be inserted"""
    object: ChatbotCategoryInsertInput!

    """upsert condition"""
    onConflict: ChatbotCategoryOnConflict
  ): ChatbotCategory

  """
  insert data into the table: "chatbot_domain"
  """
  insertChatbotDomain(
    """the rows to be inserted"""
    objects: [ChatbotDomainInsertInput!]!

    """upsert condition"""
    onConflict: ChatbotDomainOnConflict
  ): ChatbotDomainMutationResponse

  """
  insert a single row into the table: "chatbot_domain"
  """
  insertChatbotDomainOne(
    """the row to be inserted"""
    object: ChatbotDomainInsertInput!

    """upsert condition"""
    onConflict: ChatbotDomainOnConflict
  ): ChatbotDomain

  """
  insert a single row into the table: "chatbot"
  """
  insertChatbotOne(
    """the row to be inserted"""
    object: ChatbotInsertInput!

    """upsert condition"""
    onConflict: ChatbotOnConflict
  ): Chatbot

  """
  insert data into the table: "complexity_enum"
  """
  insertComplexityEnum(
    """the rows to be inserted"""
    objects: [ComplexityEnumInsertInput!]!

    """upsert condition"""
    onConflict: ComplexityEnumOnConflict
  ): ComplexityEnumMutationResponse

  """
  insert a single row into the table: "complexity_enum"
  """
  insertComplexityEnumOne(
    """the row to be inserted"""
    object: ComplexityEnumInsertInput!

    """upsert condition"""
    onConflict: ComplexityEnumOnConflict
  ): ComplexityEnum

  """
  insert data into the table: "domain_enum"
  """
  insertDomainEnum(
    """the rows to be inserted"""
    objects: [DomainEnumInsertInput!]!

    """upsert condition"""
    onConflict: DomainEnumOnConflict
  ): DomainEnumMutationResponse

  """
  insert a single row into the table: "domain_enum"
  """
  insertDomainEnumOne(
    """the row to be inserted"""
    object: DomainEnumInsertInput!

    """upsert condition"""
    onConflict: DomainEnumOnConflict
  ): DomainEnum

  """
  insert data into the table: "example"
  """
  insertExample(
    """the rows to be inserted"""
    objects: [ExampleInsertInput!]!

    """upsert condition"""
    onConflict: ExampleOnConflict
  ): ExampleMutationResponse

  """
  insert a single row into the table: "example"
  """
  insertExampleOne(
    """the row to be inserted"""
    object: ExampleInsertInput!

    """upsert condition"""
    onConflict: ExampleOnConflict
  ): Example

  """
  insert data into the table: "length_enum"
  """
  insertLengthEnum(
    """the rows to be inserted"""
    objects: [LengthEnumInsertInput!]!

    """upsert condition"""
    onConflict: LengthEnumOnConflict
  ): LengthEnumMutationResponse

  """
  insert a single row into the table: "length_enum"
  """
  insertLengthEnumOne(
    """the row to be inserted"""
    object: LengthEnumInsertInput!

    """upsert condition"""
    onConflict: LengthEnumOnConflict
  ): LengthEnum

  """
  insert data into the table: "message"
  """
  insertMessage(
    """the rows to be inserted"""
    objects: [MessageInsertInput!]!

    """upsert condition"""
    onConflict: MessageOnConflict
  ): MessageMutationResponse

  """
  insert a single row into the table: "message"
  """
  insertMessageOne(
    """the row to be inserted"""
    object: MessageInsertInput!

    """upsert condition"""
    onConflict: MessageOnConflict
  ): Message

  """
  insert data into the table: "message_type_enum"
  """
  insertMessageTypeEnum(
    """the rows to be inserted"""
    objects: [MessageTypeEnumInsertInput!]!

    """upsert condition"""
    onConflict: MessageTypeEnumOnConflict
  ): MessageTypeEnumMutationResponse

  """
  insert a single row into the table: "message_type_enum"
  """
  insertMessageTypeEnumOne(
    """the row to be inserted"""
    object: MessageTypeEnumInsertInput!

    """upsert condition"""
    onConflict: MessageTypeEnumOnConflict
  ): MessageTypeEnum

  """
  insert data into the table: "models_enum"
  """
  insertModelsEnum(
    """the rows to be inserted"""
    objects: [ModelsEnumInsertInput!]!

    """upsert condition"""
    onConflict: ModelsEnumOnConflict
  ): ModelsEnumMutationResponse

  """
  insert a single row into the table: "models_enum"
  """
  insertModelsEnumOne(
    """the row to be inserted"""
    object: ModelsEnumInsertInput!

    """upsert condition"""
    onConflict: ModelsEnumOnConflict
  ): ModelsEnum

  """
  insert data into the table: "preference"
  """
  insertPreference(
    """the rows to be inserted"""
    objects: [PreferenceInsertInput!]!

    """upsert condition"""
    onConflict: PreferenceOnConflict
  ): PreferenceMutationResponse

  """
  insert a single row into the table: "preference"
  """
  insertPreferenceOne(
    """the row to be inserted"""
    object: PreferenceInsertInput!

    """upsert condition"""
    onConflict: PreferenceOnConflict
  ): Preference

  """
  insert data into the table: "prompt"
  """
  insertPrompt(
    """the rows to be inserted"""
    objects: [PromptInsertInput!]!

    """upsert condition"""
    onConflict: PromptOnConflict
  ): PromptMutationResponse

  """
  insert data into the table: "prompt_chatbot"
  """
  insertPromptChatbot(
    """the rows to be inserted"""
    objects: [PromptChatbotInsertInput!]!

    """upsert condition"""
    onConflict: PromptChatbotOnConflict
  ): PromptChatbotMutationResponse

  """
  insert a single row into the table: "prompt_chatbot"
  """
  insertPromptChatbotOne(
    """the row to be inserted"""
    object: PromptChatbotInsertInput!

    """upsert condition"""
    onConflict: PromptChatbotOnConflict
  ): PromptChatbot

  """
  insert a single row into the table: "prompt"
  """
  insertPromptOne(
    """the row to be inserted"""
    object: PromptInsertInput!

    """upsert condition"""
    onConflict: PromptOnConflict
  ): Prompt

  """
  insert data into the table: "prompt_type_enum"
  """
  insertPromptTypeEnum(
    """the rows to be inserted"""
    objects: [PromptTypeEnumInsertInput!]!

    """upsert condition"""
    onConflict: PromptTypeEnumOnConflict
  ): PromptTypeEnumMutationResponse

  """
  insert a single row into the table: "prompt_type_enum"
  """
  insertPromptTypeEnumOne(
    """the row to be inserted"""
    object: PromptTypeEnumInsertInput!

    """upsert condition"""
    onConflict: PromptTypeEnumOnConflict
  ): PromptTypeEnum

  """
  insert data into the table: "prompt_user"
  """
  insertPromptUser(
    """the rows to be inserted"""
    objects: [PromptUserInsertInput!]!

    """upsert condition"""
    onConflict: PromptUserOnConflict
  ): PromptUserMutationResponse

  """
  insert a single row into the table: "prompt_user"
  """
  insertPromptUserOne(
    """the row to be inserted"""
    object: PromptUserInsertInput!

    """upsert condition"""
    onConflict: PromptUserOnConflict
  ): PromptUser

  """
  insert data into the table: "referral"
  """
  insertReferral(
    """the rows to be inserted"""
    objects: [ReferralInsertInput!]!

    """upsert condition"""
    onConflict: ReferralOnConflict
  ): ReferralMutationResponse

  """
  insert a single row into the table: "referral"
  """
  insertReferralOne(
    """the row to be inserted"""
    object: ReferralInsertInput!

    """upsert condition"""
    onConflict: ReferralOnConflict
  ): Referral

  """
  insert data into the table: "social_following"
  """
  insertSocialFollowing(
    """the rows to be inserted"""
    objects: [SocialFollowingInsertInput!]!
  ): SocialFollowingMutationResponse

  """
  insert a single row into the table: "social_following"
  """
  insertSocialFollowingOne(
    """the row to be inserted"""
    object: SocialFollowingInsertInput!
  ): SocialFollowing

  """
  insert data into the table: "subcategory_enum"
  """
  insertSubcategoryEnum(
    """the rows to be inserted"""
    objects: [SubcategoryEnumInsertInput!]!

    """upsert condition"""
    onConflict: SubcategoryEnumOnConflict
  ): SubcategoryEnumMutationResponse

  """
  insert a single row into the table: "subcategory_enum"
  """
  insertSubcategoryEnumOne(
    """the row to be inserted"""
    object: SubcategoryEnumInsertInput!

    """upsert condition"""
    onConflict: SubcategoryEnumOnConflict
  ): SubcategoryEnum

  """
  insert data into the table: "tag_enum"
  """
  insertTagEnum(
    """the rows to be inserted"""
    objects: [TagEnumInsertInput!]!

    """upsert condition"""
    onConflict: TagEnumOnConflict
  ): TagEnumMutationResponse

  """
  insert a single row into the table: "tag_enum"
  """
  insertTagEnumOne(
    """the row to be inserted"""
    object: TagEnumInsertInput!

    """upsert condition"""
    onConflict: TagEnumOnConflict
  ): TagEnum

  """
  insert data into the table: "thread"
  """
  insertThread(
    """the rows to be inserted"""
    objects: [ThreadInsertInput!]!

    """upsert condition"""
    onConflict: ThreadOnConflict
  ): ThreadMutationResponse

  """
  insert a single row into the table: "thread"
  """
  insertThreadOne(
    """the row to be inserted"""
    object: ThreadInsertInput!

    """upsert condition"""
    onConflict: ThreadOnConflict
  ): Thread

  """
  insert data into the table: "token"
  """
  insertToken(
    """the rows to be inserted"""
    objects: [TokenInsertInput!]!

    """upsert condition"""
    onConflict: TokenOnConflict
  ): TokenMutationResponse

  """
  insert a single row into the table: "token"
  """
  insertTokenOne(
    """the row to be inserted"""
    object: TokenInsertInput!

    """upsert condition"""
    onConflict: TokenOnConflict
  ): Token

  """
  insert data into the table: "tone_enum"
  """
  insertToneEnum(
    """the rows to be inserted"""
    objects: [ToneEnumInsertInput!]!

    """upsert condition"""
    onConflict: ToneEnumOnConflict
  ): ToneEnumMutationResponse

  """
  insert a single row into the table: "tone_enum"
  """
  insertToneEnumOne(
    """the row to be inserted"""
    object: ToneEnumInsertInput!

    """upsert condition"""
    onConflict: ToneEnumOnConflict
  ): ToneEnum

  """
  insert data into the table: "type_enum"
  """
  insertTypeEnum(
    """the rows to be inserted"""
    objects: [TypeEnumInsertInput!]!

    """upsert condition"""
    onConflict: TypeEnumOnConflict
  ): TypeEnumMutationResponse

  """
  insert a single row into the table: "type_enum"
  """
  insertTypeEnumOne(
    """the row to be inserted"""
    object: TypeEnumInsertInput!

    """upsert condition"""
    onConflict: TypeEnumOnConflict
  ): TypeEnum

  """
  insert data into the table: "user"
  """
  insertUser(
    """the rows to be inserted"""
    objects: [UserInsertInput!]!

    """upsert condition"""
    onConflict: UserOnConflict
  ): UserMutationResponse

  """
  insert a single row into the table: "user"
  """
  insertUserOne(
    """the row to be inserted"""
    object: UserInsertInput!

    """upsert condition"""
    onConflict: UserOnConflict
  ): User

  """
  insert data into the table: "user_token"
  """
  insertUserToken(
    """the rows to be inserted"""
    objects: [UserTokenInsertInput!]!

    """upsert condition"""
    onConflict: UserTokenOnConflict
  ): UserTokenMutationResponse

  """
  insert a single row into the table: "user_token"
  """
  insertUserTokenOne(
    """the row to be inserted"""
    object: UserTokenInsertInput!

    """upsert condition"""
    onConflict: UserTokenOnConflict
  ): UserToken

  """
  update data of the table: "category"
  """
  updateCategory(
    """increments the numeric columns with given value of the filtered values"""
    _inc: CategoryIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: CategorySetInput

    """filter the rows which have to be updated"""
    where: CategoryBoolExp!
  ): CategoryMutationResponse

  """
  update single row of the table: "category"
  """
  updateCategoryByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: CategoryIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: CategorySetInput
    pkColumns: CategoryPkColumnsInput!
  ): Category

  """
  update data of the table: "category_enum"
  """
  updateCategoryEnum(
    """sets the columns of the filtered rows to the given values"""
    _set: CategoryEnumSetInput

    """filter the rows which have to be updated"""
    where: CategoryEnumBoolExp!
  ): CategoryEnumMutationResponse

  """
  update single row of the table: "category_enum"
  """
  updateCategoryEnumByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: CategoryEnumSetInput
    pkColumns: CategoryEnumPkColumnsInput!
  ): CategoryEnum

  """
  update multiples rows of table: "category_enum"
  """
  updateCategoryEnumMany(
    """updates to execute, in order"""
    updates: [CategoryEnumUpdates!]!
  ): [CategoryEnumMutationResponse]

  """
  update multiples rows of table: "category"
  """
  updateCategoryMany(
    """updates to execute, in order"""
    updates: [CategoryUpdates!]!
  ): [CategoryMutationResponse]

  """
  update data of the table: "chatbot"
  """
  updateChatbot(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ChatbotIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: ChatbotSetInput

    """filter the rows which have to be updated"""
    where: ChatbotBoolExp!
  ): ChatbotMutationResponse

  """
  update single row of the table: "chatbot"
  """
  updateChatbotByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ChatbotIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: ChatbotSetInput
    pkColumns: ChatbotPkColumnsInput!
  ): Chatbot

  """
  update data of the table: "chatbot_category"
  """
  updateChatbotCategory(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ChatbotCategoryIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: ChatbotCategorySetInput

    """filter the rows which have to be updated"""
    where: ChatbotCategoryBoolExp!
  ): ChatbotCategoryMutationResponse

  """
  update single row of the table: "chatbot_category"
  """
  updateChatbotCategoryByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ChatbotCategoryIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: ChatbotCategorySetInput
    pkColumns: ChatbotCategoryPkColumnsInput!
  ): ChatbotCategory

  """
  update multiples rows of table: "chatbot_category"
  """
  updateChatbotCategoryMany(
    """updates to execute, in order"""
    updates: [ChatbotCategoryUpdates!]!
  ): [ChatbotCategoryMutationResponse]

  """
  update data of the table: "chatbot_domain"
  """
  updateChatbotDomain(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ChatbotDomainIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: ChatbotDomainSetInput

    """filter the rows which have to be updated"""
    where: ChatbotDomainBoolExp!
  ): ChatbotDomainMutationResponse

  """
  update single row of the table: "chatbot_domain"
  """
  updateChatbotDomainByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ChatbotDomainIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: ChatbotDomainSetInput
    pkColumns: ChatbotDomainPkColumnsInput!
  ): ChatbotDomain

  """
  update multiples rows of table: "chatbot_domain"
  """
  updateChatbotDomainMany(
    """updates to execute, in order"""
    updates: [ChatbotDomainUpdates!]!
  ): [ChatbotDomainMutationResponse]

  """
  update multiples rows of table: "chatbot"
  """
  updateChatbotMany(
    """updates to execute, in order"""
    updates: [ChatbotUpdates!]!
  ): [ChatbotMutationResponse]

  """
  update data of the table: "complexity_enum"
  """
  updateComplexityEnum(
    """sets the columns of the filtered rows to the given values"""
    _set: ComplexityEnumSetInput

    """filter the rows which have to be updated"""
    where: ComplexityEnumBoolExp!
  ): ComplexityEnumMutationResponse

  """
  update single row of the table: "complexity_enum"
  """
  updateComplexityEnumByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: ComplexityEnumSetInput
    pkColumns: ComplexityEnumPkColumnsInput!
  ): ComplexityEnum

  """
  update multiples rows of table: "complexity_enum"
  """
  updateComplexityEnumMany(
    """updates to execute, in order"""
    updates: [ComplexityEnumUpdates!]!
  ): [ComplexityEnumMutationResponse]

  """
  update data of the table: "domain_enum"
  """
  updateDomainEnum(
    """sets the columns of the filtered rows to the given values"""
    _set: DomainEnumSetInput

    """filter the rows which have to be updated"""
    where: DomainEnumBoolExp!
  ): DomainEnumMutationResponse

  """
  update single row of the table: "domain_enum"
  """
  updateDomainEnumByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: DomainEnumSetInput
    pkColumns: DomainEnumPkColumnsInput!
  ): DomainEnum

  """
  update multiples rows of table: "domain_enum"
  """
  updateDomainEnumMany(
    """updates to execute, in order"""
    updates: [DomainEnumUpdates!]!
  ): [DomainEnumMutationResponse]

  """
  update data of the table: "example"
  """
  updateExample(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: ExampleAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: ExampleDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: ExampleDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: ExampleDeleteKeyInput

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: ExamplePrependInput

    """sets the columns of the filtered rows to the given values"""
    _set: ExampleSetInput

    """filter the rows which have to be updated"""
    where: ExampleBoolExp!
  ): ExampleMutationResponse

  """
  update single row of the table: "example"
  """
  updateExampleByPk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: ExampleAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: ExampleDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: ExampleDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: ExampleDeleteKeyInput

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: ExamplePrependInput

    """sets the columns of the filtered rows to the given values"""
    _set: ExampleSetInput
    pkColumns: ExamplePkColumnsInput!
  ): Example

  """
  update multiples rows of table: "example"
  """
  updateExampleMany(
    """updates to execute, in order"""
    updates: [ExampleUpdates!]!
  ): [ExampleMutationResponse]

  """
  update data of the table: "length_enum"
  """
  updateLengthEnum(
    """sets the columns of the filtered rows to the given values"""
    _set: LengthEnumSetInput

    """filter the rows which have to be updated"""
    where: LengthEnumBoolExp!
  ): LengthEnumMutationResponse

  """
  update single row of the table: "length_enum"
  """
  updateLengthEnumByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: LengthEnumSetInput
    pkColumns: LengthEnumPkColumnsInput!
  ): LengthEnum

  """
  update multiples rows of table: "length_enum"
  """
  updateLengthEnumMany(
    """updates to execute, in order"""
    updates: [LengthEnumUpdates!]!
  ): [LengthEnumMutationResponse]

  """
  update data of the table: "message"
  """
  updateMessage(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: MessageAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: MessageDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: MessageDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: MessageDeleteKeyInput

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: MessagePrependInput

    """sets the columns of the filtered rows to the given values"""
    _set: MessageSetInput

    """filter the rows which have to be updated"""
    where: MessageBoolExp!
  ): MessageMutationResponse

  """
  update single row of the table: "message"
  """
  updateMessageByPk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: MessageAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: MessageDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: MessageDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: MessageDeleteKeyInput

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: MessagePrependInput

    """sets the columns of the filtered rows to the given values"""
    _set: MessageSetInput
    pkColumns: MessagePkColumnsInput!
  ): Message

  """
  update multiples rows of table: "message"
  """
  updateMessageMany(
    """updates to execute, in order"""
    updates: [MessageUpdates!]!
  ): [MessageMutationResponse]

  """
  update data of the table: "message_type_enum"
  """
  updateMessageTypeEnum(
    """sets the columns of the filtered rows to the given values"""
    _set: MessageTypeEnumSetInput

    """filter the rows which have to be updated"""
    where: MessageTypeEnumBoolExp!
  ): MessageTypeEnumMutationResponse

  """
  update single row of the table: "message_type_enum"
  """
  updateMessageTypeEnumByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: MessageTypeEnumSetInput
    pkColumns: MessageTypeEnumPkColumnsInput!
  ): MessageTypeEnum

  """
  update multiples rows of table: "message_type_enum"
  """
  updateMessageTypeEnumMany(
    """updates to execute, in order"""
    updates: [MessageTypeEnumUpdates!]!
  ): [MessageTypeEnumMutationResponse]

  """
  update data of the table: "models_enum"
  """
  updateModelsEnum(
    """sets the columns of the filtered rows to the given values"""
    _set: ModelsEnumSetInput

    """filter the rows which have to be updated"""
    where: ModelsEnumBoolExp!
  ): ModelsEnumMutationResponse

  """
  update single row of the table: "models_enum"
  """
  updateModelsEnumByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: ModelsEnumSetInput
    pkColumns: ModelsEnumPkColumnsInput!
  ): ModelsEnum

  """
  update multiples rows of table: "models_enum"
  """
  updateModelsEnumMany(
    """updates to execute, in order"""
    updates: [ModelsEnumUpdates!]!
  ): [ModelsEnumMutationResponse]

  """
  update data of the table: "preference"
  """
  updatePreference(
    """increments the numeric columns with given value of the filtered values"""
    _inc: PreferenceIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: PreferenceSetInput

    """filter the rows which have to be updated"""
    where: PreferenceBoolExp!
  ): PreferenceMutationResponse

  """
  update single row of the table: "preference"
  """
  updatePreferenceByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: PreferenceIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: PreferenceSetInput
    pkColumns: PreferencePkColumnsInput!
  ): Preference

  """
  update multiples rows of table: "preference"
  """
  updatePreferenceMany(
    """updates to execute, in order"""
    updates: [PreferenceUpdates!]!
  ): [PreferenceMutationResponse]

  """
  update data of the table: "prompt"
  """
  updatePrompt(
    """increments the numeric columns with given value of the filtered values"""
    _inc: PromptIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: PromptSetInput

    """filter the rows which have to be updated"""
    where: PromptBoolExp!
  ): PromptMutationResponse

  """
  update single row of the table: "prompt"
  """
  updatePromptByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: PromptIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: PromptSetInput
    pkColumns: PromptPkColumnsInput!
  ): Prompt

  """
  update data of the table: "prompt_chatbot"
  """
  updatePromptChatbot(
    """increments the numeric columns with given value of the filtered values"""
    _inc: PromptChatbotIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: PromptChatbotSetInput

    """filter the rows which have to be updated"""
    where: PromptChatbotBoolExp!
  ): PromptChatbotMutationResponse

  """
  update single row of the table: "prompt_chatbot"
  """
  updatePromptChatbotByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: PromptChatbotIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: PromptChatbotSetInput
    pkColumns: PromptChatbotPkColumnsInput!
  ): PromptChatbot

  """
  update multiples rows of table: "prompt_chatbot"
  """
  updatePromptChatbotMany(
    """updates to execute, in order"""
    updates: [PromptChatbotUpdates!]!
  ): [PromptChatbotMutationResponse]

  """
  update multiples rows of table: "prompt"
  """
  updatePromptMany(
    """updates to execute, in order"""
    updates: [PromptUpdates!]!
  ): [PromptMutationResponse]

  """
  update data of the table: "prompt_type_enum"
  """
  updatePromptTypeEnum(
    """sets the columns of the filtered rows to the given values"""
    _set: PromptTypeEnumSetInput

    """filter the rows which have to be updated"""
    where: PromptTypeEnumBoolExp!
  ): PromptTypeEnumMutationResponse

  """
  update single row of the table: "prompt_type_enum"
  """
  updatePromptTypeEnumByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: PromptTypeEnumSetInput
    pkColumns: PromptTypeEnumPkColumnsInput!
  ): PromptTypeEnum

  """
  update multiples rows of table: "prompt_type_enum"
  """
  updatePromptTypeEnumMany(
    """updates to execute, in order"""
    updates: [PromptTypeEnumUpdates!]!
  ): [PromptTypeEnumMutationResponse]

  """
  update data of the table: "prompt_user"
  """
  updatePromptUser(
    """increments the numeric columns with given value of the filtered values"""
    _inc: PromptUserIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: PromptUserSetInput

    """filter the rows which have to be updated"""
    where: PromptUserBoolExp!
  ): PromptUserMutationResponse

  """
  update single row of the table: "prompt_user"
  """
  updatePromptUserByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: PromptUserIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: PromptUserSetInput
    pkColumns: PromptUserPkColumnsInput!
  ): PromptUser

  """
  update multiples rows of table: "prompt_user"
  """
  updatePromptUserMany(
    """updates to execute, in order"""
    updates: [PromptUserUpdates!]!
  ): [PromptUserMutationResponse]

  """
  update data of the table: "referral"
  """
  updateReferral(
    """sets the columns of the filtered rows to the given values"""
    _set: ReferralSetInput

    """filter the rows which have to be updated"""
    where: ReferralBoolExp!
  ): ReferralMutationResponse

  """
  update single row of the table: "referral"
  """
  updateReferralByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: ReferralSetInput
    pkColumns: ReferralPkColumnsInput!
  ): Referral

  """
  update multiples rows of table: "referral"
  """
  updateReferralMany(
    """updates to execute, in order"""
    updates: [ReferralUpdates!]!
  ): [ReferralMutationResponse]

  """
  update data of the table: "social_following"
  """
  updateSocialFollowing(
    """increments the numeric columns with given value of the filtered values"""
    _inc: SocialFollowingIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: SocialFollowingSetInput

    """filter the rows which have to be updated"""
    where: SocialFollowingBoolExp!
  ): SocialFollowingMutationResponse

  """
  update multiples rows of table: "social_following"
  """
  updateSocialFollowingMany(
    """updates to execute, in order"""
    updates: [SocialFollowingUpdates!]!
  ): [SocialFollowingMutationResponse]

  """
  update data of the table: "subcategory_enum"
  """
  updateSubcategoryEnum(
    """sets the columns of the filtered rows to the given values"""
    _set: SubcategoryEnumSetInput

    """filter the rows which have to be updated"""
    where: SubcategoryEnumBoolExp!
  ): SubcategoryEnumMutationResponse

  """
  update single row of the table: "subcategory_enum"
  """
  updateSubcategoryEnumByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: SubcategoryEnumSetInput
    pkColumns: SubcategoryEnumPkColumnsInput!
  ): SubcategoryEnum

  """
  update multiples rows of table: "subcategory_enum"
  """
  updateSubcategoryEnumMany(
    """updates to execute, in order"""
    updates: [SubcategoryEnumUpdates!]!
  ): [SubcategoryEnumMutationResponse]

  """
  update data of the table: "tag_enum"
  """
  updateTagEnum(
    """increments the numeric columns with given value of the filtered values"""
    _inc: TagEnumIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: TagEnumSetInput

    """filter the rows which have to be updated"""
    where: TagEnumBoolExp!
  ): TagEnumMutationResponse

  """
  update single row of the table: "tag_enum"
  """
  updateTagEnumByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: TagEnumIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: TagEnumSetInput
    pkColumns: TagEnumPkColumnsInput!
  ): TagEnum

  """
  update multiples rows of table: "tag_enum"
  """
  updateTagEnumMany(
    """updates to execute, in order"""
    updates: [TagEnumUpdates!]!
  ): [TagEnumMutationResponse]

  """
  update data of the table: "thread"
  """
  updateThread(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ThreadIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: ThreadSetInput

    """filter the rows which have to be updated"""
    where: ThreadBoolExp!
  ): ThreadMutationResponse

  """
  update single row of the table: "thread"
  """
  updateThreadByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ThreadIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: ThreadSetInput
    pkColumns: ThreadPkColumnsInput!
  ): Thread

  """
  update multiples rows of table: "thread"
  """
  updateThreadMany(
    """updates to execute, in order"""
    updates: [ThreadUpdates!]!
  ): [ThreadMutationResponse]

  """
  update data of the table: "token"
  """
  updateToken(
    """sets the columns of the filtered rows to the given values"""
    _set: TokenSetInput

    """filter the rows which have to be updated"""
    where: TokenBoolExp!
  ): TokenMutationResponse

  """
  update single row of the table: "token"
  """
  updateTokenByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: TokenSetInput
    pkColumns: TokenPkColumnsInput!
  ): Token

  """
  update multiples rows of table: "token"
  """
  updateTokenMany(
    """updates to execute, in order"""
    updates: [TokenUpdates!]!
  ): [TokenMutationResponse]

  """
  update data of the table: "tone_enum"
  """
  updateToneEnum(
    """sets the columns of the filtered rows to the given values"""
    _set: ToneEnumSetInput

    """filter the rows which have to be updated"""
    where: ToneEnumBoolExp!
  ): ToneEnumMutationResponse

  """
  update single row of the table: "tone_enum"
  """
  updateToneEnumByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: ToneEnumSetInput
    pkColumns: ToneEnumPkColumnsInput!
  ): ToneEnum

  """
  update multiples rows of table: "tone_enum"
  """
  updateToneEnumMany(
    """updates to execute, in order"""
    updates: [ToneEnumUpdates!]!
  ): [ToneEnumMutationResponse]

  """
  update data of the table: "type_enum"
  """
  updateTypeEnum(
    """sets the columns of the filtered rows to the given values"""
    _set: TypeEnumSetInput

    """filter the rows which have to be updated"""
    where: TypeEnumBoolExp!
  ): TypeEnumMutationResponse

  """
  update single row of the table: "type_enum"
  """
  updateTypeEnumByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: TypeEnumSetInput
    pkColumns: TypeEnumPkColumnsInput!
  ): TypeEnum

  """
  update multiples rows of table: "type_enum"
  """
  updateTypeEnumMany(
    """updates to execute, in order"""
    updates: [TypeEnumUpdates!]!
  ): [TypeEnumMutationResponse]

  """
  update data of the table: "user"
  """
  updateUser(
    """sets the columns of the filtered rows to the given values"""
    _set: UserSetInput

    """filter the rows which have to be updated"""
    where: UserBoolExp!
  ): UserMutationResponse

  """
  update single row of the table: "user"
  """
  updateUserByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: UserSetInput
    pkColumns: UserPkColumnsInput!
  ): User

  """
  update multiples rows of table: "user"
  """
  updateUserMany(
    """updates to execute, in order"""
    updates: [UserUpdates!]!
  ): [UserMutationResponse]

  """
  update data of the table: "user_token"
  """
  updateUserToken(
    """sets the columns of the filtered rows to the given values"""
    _set: UserTokenSetInput

    """filter the rows which have to be updated"""
    where: UserTokenBoolExp!
  ): UserTokenMutationResponse

  """
  update single row of the table: "user_token"
  """
  updateUserTokenByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: UserTokenSetInput
    pkColumns: UserTokenPkColumnsInput!
  ): UserToken

  """
  update multiples rows of table: "user_token"
  """
  updateUserTokenMany(
    """updates to execute, in order"""
    updates: [UserTokenUpdates!]!
  ): [UserTokenMutationResponse]
}

scalar numeric

input preferenceAggregateBoolExpBool_and {
  arguments: PreferenceSelectColumnPreferenceAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: PreferenceBoolExp
  predicate: BooleanComparisonExp!
}

input preferenceAggregateBoolExpBool_or {
  arguments: PreferenceSelectColumnPreferenceAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: PreferenceBoolExp
  predicate: BooleanComparisonExp!
}

input preferenceAggregateBoolExpCount {
  arguments: [PreferenceSelectColumn!]
  distinct: Boolean
  filter: PreferenceBoolExp
  predicate: IntComparisonExp!
}

input promptAggregateBoolExpCount {
  arguments: [PromptSelectColumn!]
  distinct: Boolean
  filter: PromptBoolExp
  predicate: IntComparisonExp!
}

input promptChatbotAggregateBoolExpCount {
  arguments: [PromptChatbotSelectColumn!]
  distinct: Boolean
  filter: PromptChatbotBoolExp
  predicate: IntComparisonExp!
}

input promptUserAggregateBoolExpCount {
  arguments: [PromptUserSelectColumn!]
  distinct: Boolean
  filter: PromptUserBoolExp
  predicate: IntComparisonExp!
}

type query_root {
  """
  fetch data from the table: "category"
  """
  category(
    """distinct select on columns"""
    distinctOn: [CategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CategoryOrderBy!]

    """filter the rows returned"""
    where: CategoryBoolExp
  ): [Category!]!

  """
  fetch aggregated fields from the table: "category"
  """
  categoryAggregate(
    """distinct select on columns"""
    distinctOn: [CategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CategoryOrderBy!]

    """filter the rows returned"""
    where: CategoryBoolExp
  ): CategoryAggregate!

  """fetch data from the table: "category" using primary key columns"""
  categoryByPk(categoryId: Int!): Category

  """
  fetch data from the table: "category_enum"
  """
  categoryEnum(
    """distinct select on columns"""
    distinctOn: [CategoryEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CategoryEnumOrderBy!]

    """filter the rows returned"""
    where: CategoryEnumBoolExp
  ): [CategoryEnum!]!

  """
  fetch aggregated fields from the table: "category_enum"
  """
  categoryEnumAggregate(
    """distinct select on columns"""
    distinctOn: [CategoryEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CategoryEnumOrderBy!]

    """filter the rows returned"""
    where: CategoryEnumBoolExp
  ): CategoryEnumAggregate!

  """fetch data from the table: "category_enum" using primary key columns"""
  categoryEnumByPk(domain: String!, name: String!): CategoryEnum

  """
  fetch data from the table: "chatbot"
  """
  chatbot(
    """distinct select on columns"""
    distinctOn: [ChatbotSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotOrderBy!]

    """filter the rows returned"""
    where: ChatbotBoolExp
  ): [Chatbot!]!

  """
  fetch aggregated fields from the table: "chatbot"
  """
  chatbotAggregate(
    """distinct select on columns"""
    distinctOn: [ChatbotSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotOrderBy!]

    """filter the rows returned"""
    where: ChatbotBoolExp
  ): ChatbotAggregate!

  """fetch data from the table: "chatbot" using primary key columns"""
  chatbotByPk(chatbotId: Int!): Chatbot

  """
  fetch data from the table: "chatbot_category"
  """
  chatbotCategory(
    """distinct select on columns"""
    distinctOn: [ChatbotCategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotCategoryOrderBy!]

    """filter the rows returned"""
    where: ChatbotCategoryBoolExp
  ): [ChatbotCategory!]!

  """
  fetch aggregated fields from the table: "chatbot_category"
  """
  chatbotCategoryAggregate(
    """distinct select on columns"""
    distinctOn: [ChatbotCategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotCategoryOrderBy!]

    """filter the rows returned"""
    where: ChatbotCategoryBoolExp
  ): ChatbotCategoryAggregate!

  """
  fetch data from the table: "chatbot_category" using primary key columns
  """
  chatbotCategoryByPk(categoryId: Int!, chatbotId: Int!): ChatbotCategory

  """
  fetch data from the table: "chatbot_domain"
  """
  chatbotDomain(
    """distinct select on columns"""
    distinctOn: [ChatbotDomainSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotDomainOrderBy!]

    """filter the rows returned"""
    where: ChatbotDomainBoolExp
  ): [ChatbotDomain!]!

  """
  fetch aggregated fields from the table: "chatbot_domain"
  """
  chatbotDomainAggregate(
    """distinct select on columns"""
    distinctOn: [ChatbotDomainSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotDomainOrderBy!]

    """filter the rows returned"""
    where: ChatbotDomainBoolExp
  ): ChatbotDomainAggregate!

  """fetch data from the table: "chatbot_domain" using primary key columns"""
  chatbotDomainByPk(chatbotId: Int!, domainName: String!): ChatbotDomain

  """
  fetch data from the table: "complexity_enum"
  """
  complexityEnum(
    """distinct select on columns"""
    distinctOn: [ComplexityEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ComplexityEnumOrderBy!]

    """filter the rows returned"""
    where: ComplexityEnumBoolExp
  ): [ComplexityEnum!]!

  """
  fetch aggregated fields from the table: "complexity_enum"
  """
  complexityEnumAggregate(
    """distinct select on columns"""
    distinctOn: [ComplexityEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ComplexityEnumOrderBy!]

    """filter the rows returned"""
    where: ComplexityEnumBoolExp
  ): ComplexityEnumAggregate!

  """fetch data from the table: "complexity_enum" using primary key columns"""
  complexityEnumByPk(value: String!): ComplexityEnum

  """
  fetch data from the table: "domain_enum"
  """
  domainEnum(
    """distinct select on columns"""
    distinctOn: [DomainEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [DomainEnumOrderBy!]

    """filter the rows returned"""
    where: DomainEnumBoolExp
  ): [DomainEnum!]!

  """
  fetch aggregated fields from the table: "domain_enum"
  """
  domainEnumAggregate(
    """distinct select on columns"""
    distinctOn: [DomainEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [DomainEnumOrderBy!]

    """filter the rows returned"""
    where: DomainEnumBoolExp
  ): DomainEnumAggregate!

  """fetch data from the table: "domain_enum" using primary key columns"""
  domainEnumByPk(name: String!): DomainEnum

  """
  fetch data from the table: "example"
  """
  example(
    """distinct select on columns"""
    distinctOn: [ExampleSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ExampleOrderBy!]

    """filter the rows returned"""
    where: ExampleBoolExp
  ): [Example!]!

  """
  fetch aggregated fields from the table: "example"
  """
  exampleAggregate(
    """distinct select on columns"""
    distinctOn: [ExampleSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ExampleOrderBy!]

    """filter the rows returned"""
    where: ExampleBoolExp
  ): ExampleAggregate!

  """fetch data from the table: "example" using primary key columns"""
  exampleByPk(exampleId: uuid!): Example

  """
  fetch data from the table: "length_enum"
  """
  lengthEnum(
    """distinct select on columns"""
    distinctOn: [LengthEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [LengthEnumOrderBy!]

    """filter the rows returned"""
    where: LengthEnumBoolExp
  ): [LengthEnum!]!

  """
  fetch aggregated fields from the table: "length_enum"
  """
  lengthEnumAggregate(
    """distinct select on columns"""
    distinctOn: [LengthEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [LengthEnumOrderBy!]

    """filter the rows returned"""
    where: LengthEnumBoolExp
  ): LengthEnumAggregate!

  """fetch data from the table: "length_enum" using primary key columns"""
  lengthEnumByPk(value: String!): LengthEnum

  """
  fetch data from the table: "message"
  """
  message(
    """distinct select on columns"""
    distinctOn: [MessageSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MessageOrderBy!]

    """filter the rows returned"""
    where: MessageBoolExp
  ): [Message!]!

  """
  fetch aggregated fields from the table: "message"
  """
  messageAggregate(
    """distinct select on columns"""
    distinctOn: [MessageSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MessageOrderBy!]

    """filter the rows returned"""
    where: MessageBoolExp
  ): MessageAggregate!

  """fetch data from the table: "message" using primary key columns"""
  messageByPk(messageId: uuid!): Message

  """
  fetch data from the table: "message_type_enum"
  """
  messageTypeEnum(
    """distinct select on columns"""
    distinctOn: [MessageTypeEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MessageTypeEnumOrderBy!]

    """filter the rows returned"""
    where: MessageTypeEnumBoolExp
  ): [MessageTypeEnum!]!

  """
  fetch aggregated fields from the table: "message_type_enum"
  """
  messageTypeEnumAggregate(
    """distinct select on columns"""
    distinctOn: [MessageTypeEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MessageTypeEnumOrderBy!]

    """filter the rows returned"""
    where: MessageTypeEnumBoolExp
  ): MessageTypeEnumAggregate!

  """
  fetch data from the table: "message_type_enum" using primary key columns
  """
  messageTypeEnumByPk(value: String!): MessageTypeEnum

  """
  fetch data from the table: "models_enum"
  """
  modelsEnum(
    """distinct select on columns"""
    distinctOn: [ModelsEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ModelsEnumOrderBy!]

    """filter the rows returned"""
    where: ModelsEnumBoolExp
  ): [ModelsEnum!]!

  """
  fetch aggregated fields from the table: "models_enum"
  """
  modelsEnumAggregate(
    """distinct select on columns"""
    distinctOn: [ModelsEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ModelsEnumOrderBy!]

    """filter the rows returned"""
    where: ModelsEnumBoolExp
  ): ModelsEnumAggregate!

  """fetch data from the table: "models_enum" using primary key columns"""
  modelsEnumByPk(name: String!): ModelsEnum

  """
  fetch data from the table: "preference"
  """
  preference(
    """distinct select on columns"""
    distinctOn: [PreferenceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PreferenceOrderBy!]

    """filter the rows returned"""
    where: PreferenceBoolExp
  ): [Preference!]!

  """
  fetch aggregated fields from the table: "preference"
  """
  preferenceAggregate(
    """distinct select on columns"""
    distinctOn: [PreferenceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PreferenceOrderBy!]

    """filter the rows returned"""
    where: PreferenceBoolExp
  ): PreferenceAggregate!

  """fetch data from the table: "preference" using primary key columns"""
  preferenceByPk(preferenceId: Int!): Preference

  """
  fetch data from the table: "prompt"
  """
  prompt(
    """distinct select on columns"""
    distinctOn: [PromptSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptOrderBy!]

    """filter the rows returned"""
    where: PromptBoolExp
  ): [Prompt!]!

  """
  fetch aggregated fields from the table: "prompt"
  """
  promptAggregate(
    """distinct select on columns"""
    distinctOn: [PromptSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptOrderBy!]

    """filter the rows returned"""
    where: PromptBoolExp
  ): PromptAggregate!

  """fetch data from the table: "prompt" using primary key columns"""
  promptByPk(promptId: Int!): Prompt

  """
  fetch data from the table: "prompt_chatbot"
  """
  promptChatbot(
    """distinct select on columns"""
    distinctOn: [PromptChatbotSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptChatbotOrderBy!]

    """filter the rows returned"""
    where: PromptChatbotBoolExp
  ): [PromptChatbot!]!

  """
  fetch aggregated fields from the table: "prompt_chatbot"
  """
  promptChatbotAggregate(
    """distinct select on columns"""
    distinctOn: [PromptChatbotSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptChatbotOrderBy!]

    """filter the rows returned"""
    where: PromptChatbotBoolExp
  ): PromptChatbotAggregate!

  """fetch data from the table: "prompt_chatbot" using primary key columns"""
  promptChatbotByPk(chabotId: Int!, promptId: Int!): PromptChatbot

  """
  fetch data from the table: "prompt_type_enum"
  """
  promptTypeEnum(
    """distinct select on columns"""
    distinctOn: [PromptTypeEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptTypeEnumOrderBy!]

    """filter the rows returned"""
    where: PromptTypeEnumBoolExp
  ): [PromptTypeEnum!]!

  """
  fetch aggregated fields from the table: "prompt_type_enum"
  """
  promptTypeEnumAggregate(
    """distinct select on columns"""
    distinctOn: [PromptTypeEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptTypeEnumOrderBy!]

    """filter the rows returned"""
    where: PromptTypeEnumBoolExp
  ): PromptTypeEnumAggregate!

  """
  fetch data from the table: "prompt_type_enum" using primary key columns
  """
  promptTypeEnumByPk(value: String!): PromptTypeEnum

  """
  fetch data from the table: "prompt_user"
  """
  promptUser(
    """distinct select on columns"""
    distinctOn: [PromptUserSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptUserOrderBy!]

    """filter the rows returned"""
    where: PromptUserBoolExp
  ): [PromptUser!]!

  """
  fetch aggregated fields from the table: "prompt_user"
  """
  promptUserAggregate(
    """distinct select on columns"""
    distinctOn: [PromptUserSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptUserOrderBy!]

    """filter the rows returned"""
    where: PromptUserBoolExp
  ): PromptUserAggregate!

  """fetch data from the table: "prompt_user" using primary key columns"""
  promptUserByPk(promptId: Int!, userId: uuid!): PromptUser

  """
  fetch data from the table: "referral"
  """
  referral(
    """distinct select on columns"""
    distinctOn: [ReferralSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ReferralOrderBy!]

    """filter the rows returned"""
    where: ReferralBoolExp
  ): [Referral!]!

  """
  fetch aggregated fields from the table: "referral"
  """
  referralAggregate(
    """distinct select on columns"""
    distinctOn: [ReferralSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ReferralOrderBy!]

    """filter the rows returned"""
    where: ReferralBoolExp
  ): ReferralAggregate!

  """fetch data from the table: "referral" using primary key columns"""
  referralByPk(referralCode: String!): Referral

  """
  fetch data from the table: "social_following"
  """
  socialFollowing(
    """distinct select on columns"""
    distinctOn: [SocialFollowingSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [SocialFollowingOrderBy!]

    """filter the rows returned"""
    where: SocialFollowingBoolExp
  ): [SocialFollowing!]!

  """
  fetch aggregated fields from the table: "social_following"
  """
  socialFollowingAggregate(
    """distinct select on columns"""
    distinctOn: [SocialFollowingSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [SocialFollowingOrderBy!]

    """filter the rows returned"""
    where: SocialFollowingBoolExp
  ): SocialFollowingAggregate!

  """
  fetch data from the table: "subcategory_enum"
  """
  subcategoryEnum(
    """distinct select on columns"""
    distinctOn: [SubcategoryEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [SubcategoryEnumOrderBy!]

    """filter the rows returned"""
    where: SubcategoryEnumBoolExp
  ): [SubcategoryEnum!]!

  """
  fetch aggregated fields from the table: "subcategory_enum"
  """
  subcategoryEnumAggregate(
    """distinct select on columns"""
    distinctOn: [SubcategoryEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [SubcategoryEnumOrderBy!]

    """filter the rows returned"""
    where: SubcategoryEnumBoolExp
  ): SubcategoryEnumAggregate!

  """
  fetch data from the table: "subcategory_enum" using primary key columns
  """
  subcategoryEnumByPk(category: String!, domain: String!, name: String!): SubcategoryEnum

  """
  fetch data from the table: "tag_enum"
  """
  tagEnum(
    """distinct select on columns"""
    distinctOn: [TagEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TagEnumOrderBy!]

    """filter the rows returned"""
    where: TagEnumBoolExp
  ): [TagEnum!]!

  """
  fetch aggregated fields from the table: "tag_enum"
  """
  tagEnumAggregate(
    """distinct select on columns"""
    distinctOn: [TagEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TagEnumOrderBy!]

    """filter the rows returned"""
    where: TagEnumBoolExp
  ): TagEnumAggregate!

  """fetch data from the table: "tag_enum" using primary key columns"""
  tagEnumByPk(tagId: uuid!): TagEnum

  """
  fetch data from the table: "thread"
  """
  thread(
    """distinct select on columns"""
    distinctOn: [ThreadSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ThreadOrderBy!]

    """filter the rows returned"""
    where: ThreadBoolExp
  ): [Thread!]!

  """
  fetch aggregated fields from the table: "thread"
  """
  threadAggregate(
    """distinct select on columns"""
    distinctOn: [ThreadSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ThreadOrderBy!]

    """filter the rows returned"""
    where: ThreadBoolExp
  ): ThreadAggregate!

  """fetch data from the table: "thread" using primary key columns"""
  threadByPk(threadId: uuid!): Thread

  """
  fetch data from the table: "token"
  """
  token(
    """distinct select on columns"""
    distinctOn: [TokenSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TokenOrderBy!]

    """filter the rows returned"""
    where: TokenBoolExp
  ): [Token!]!

  """
  fetch aggregated fields from the table: "token"
  """
  tokenAggregate(
    """distinct select on columns"""
    distinctOn: [TokenSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TokenOrderBy!]

    """filter the rows returned"""
    where: TokenBoolExp
  ): TokenAggregate!

  """fetch data from the table: "token" using primary key columns"""
  tokenByPk(token: String!): Token

  """
  fetch data from the table: "tone_enum"
  """
  toneEnum(
    """distinct select on columns"""
    distinctOn: [ToneEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ToneEnumOrderBy!]

    """filter the rows returned"""
    where: ToneEnumBoolExp
  ): [ToneEnum!]!

  """
  fetch aggregated fields from the table: "tone_enum"
  """
  toneEnumAggregate(
    """distinct select on columns"""
    distinctOn: [ToneEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ToneEnumOrderBy!]

    """filter the rows returned"""
    where: ToneEnumBoolExp
  ): ToneEnumAggregate!

  """fetch data from the table: "tone_enum" using primary key columns"""
  toneEnumByPk(value: String!): ToneEnum

  """
  fetch data from the table: "type_enum"
  """
  typeEnum(
    """distinct select on columns"""
    distinctOn: [TypeEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TypeEnumOrderBy!]

    """filter the rows returned"""
    where: TypeEnumBoolExp
  ): [TypeEnum!]!

  """
  fetch aggregated fields from the table: "type_enum"
  """
  typeEnumAggregate(
    """distinct select on columns"""
    distinctOn: [TypeEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TypeEnumOrderBy!]

    """filter the rows returned"""
    where: TypeEnumBoolExp
  ): TypeEnumAggregate!

  """fetch data from the table: "type_enum" using primary key columns"""
  typeEnumByPk(value: String!): TypeEnum

  """
  fetch data from the table: "user"
  """
  user(
    """distinct select on columns"""
    distinctOn: [UserSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [UserOrderBy!]

    """filter the rows returned"""
    where: UserBoolExp
  ): [User!]!

  """
  fetch aggregated fields from the table: "user"
  """
  userAggregate(
    """distinct select on columns"""
    distinctOn: [UserSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [UserOrderBy!]

    """filter the rows returned"""
    where: UserBoolExp
  ): UserAggregate!

  """fetch data from the table: "user" using primary key columns"""
  userByPk(userId: uuid!): User

  """
  fetch data from the table: "user_token"
  """
  userToken(
    """distinct select on columns"""
    distinctOn: [UserTokenSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [UserTokenOrderBy!]

    """filter the rows returned"""
    where: UserTokenBoolExp
  ): [UserToken!]!

  """
  fetch aggregated fields from the table: "user_token"
  """
  userTokenAggregate(
    """distinct select on columns"""
    distinctOn: [UserTokenSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [UserTokenOrderBy!]

    """filter the rows returned"""
    where: UserTokenBoolExp
  ): UserTokenAggregate!

  """fetch data from the table: "user_token" using primary key columns"""
  userTokenByPk(token: String!, userId: uuid!): UserToken
}

input referralAggregateBoolExpCount {
  arguments: [ReferralSelectColumn!]
  distinct: Boolean
  filter: ReferralBoolExp
  predicate: IntComparisonExp!
}

input socialFollowingAggregateBoolExpCount {
  arguments: [SocialFollowingSelectColumn!]
  distinct: Boolean
  filter: SocialFollowingBoolExp
  predicate: IntComparisonExp!
}

input subcategoryEnumAggregateBoolExpCount {
  arguments: [SubcategoryEnumSelectColumn!]
  distinct: Boolean
  filter: SubcategoryEnumBoolExp
  predicate: IntComparisonExp!
}

type subscription_root {
  """
  fetch data from the table: "category"
  """
  category(
    """distinct select on columns"""
    distinctOn: [CategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CategoryOrderBy!]

    """filter the rows returned"""
    where: CategoryBoolExp
  ): [Category!]!

  """
  fetch aggregated fields from the table: "category"
  """
  categoryAggregate(
    """distinct select on columns"""
    distinctOn: [CategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CategoryOrderBy!]

    """filter the rows returned"""
    where: CategoryBoolExp
  ): CategoryAggregate!

  """fetch data from the table: "category" using primary key columns"""
  categoryByPk(categoryId: Int!): Category

  """
  fetch data from the table: "category_enum"
  """
  categoryEnum(
    """distinct select on columns"""
    distinctOn: [CategoryEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CategoryEnumOrderBy!]

    """filter the rows returned"""
    where: CategoryEnumBoolExp
  ): [CategoryEnum!]!

  """
  fetch aggregated fields from the table: "category_enum"
  """
  categoryEnumAggregate(
    """distinct select on columns"""
    distinctOn: [CategoryEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CategoryEnumOrderBy!]

    """filter the rows returned"""
    where: CategoryEnumBoolExp
  ): CategoryEnumAggregate!

  """fetch data from the table: "category_enum" using primary key columns"""
  categoryEnumByPk(domain: String!, name: String!): CategoryEnum

  """
  fetch data from the table in a streaming manner: "category_enum"
  """
  categoryEnumStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [CategoryEnumStreamCursorInput]!

    """filter the rows returned"""
    where: CategoryEnumBoolExp
  ): [CategoryEnum!]!

  """
  fetch data from the table in a streaming manner: "category"
  """
  categoryStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [CategoryStreamCursorInput]!

    """filter the rows returned"""
    where: CategoryBoolExp
  ): [Category!]!

  """
  fetch data from the table: "chatbot"
  """
  chatbot(
    """distinct select on columns"""
    distinctOn: [ChatbotSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotOrderBy!]

    """filter the rows returned"""
    where: ChatbotBoolExp
  ): [Chatbot!]!

  """
  fetch aggregated fields from the table: "chatbot"
  """
  chatbotAggregate(
    """distinct select on columns"""
    distinctOn: [ChatbotSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotOrderBy!]

    """filter the rows returned"""
    where: ChatbotBoolExp
  ): ChatbotAggregate!

  """fetch data from the table: "chatbot" using primary key columns"""
  chatbotByPk(chatbotId: Int!): Chatbot

  """
  fetch data from the table: "chatbot_category"
  """
  chatbotCategory(
    """distinct select on columns"""
    distinctOn: [ChatbotCategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotCategoryOrderBy!]

    """filter the rows returned"""
    where: ChatbotCategoryBoolExp
  ): [ChatbotCategory!]!

  """
  fetch aggregated fields from the table: "chatbot_category"
  """
  chatbotCategoryAggregate(
    """distinct select on columns"""
    distinctOn: [ChatbotCategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotCategoryOrderBy!]

    """filter the rows returned"""
    where: ChatbotCategoryBoolExp
  ): ChatbotCategoryAggregate!

  """
  fetch data from the table: "chatbot_category" using primary key columns
  """
  chatbotCategoryByPk(categoryId: Int!, chatbotId: Int!): ChatbotCategory

  """
  fetch data from the table in a streaming manner: "chatbot_category"
  """
  chatbotCategoryStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ChatbotCategoryStreamCursorInput]!

    """filter the rows returned"""
    where: ChatbotCategoryBoolExp
  ): [ChatbotCategory!]!

  """
  fetch data from the table: "chatbot_domain"
  """
  chatbotDomain(
    """distinct select on columns"""
    distinctOn: [ChatbotDomainSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotDomainOrderBy!]

    """filter the rows returned"""
    where: ChatbotDomainBoolExp
  ): [ChatbotDomain!]!

  """
  fetch aggregated fields from the table: "chatbot_domain"
  """
  chatbotDomainAggregate(
    """distinct select on columns"""
    distinctOn: [ChatbotDomainSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotDomainOrderBy!]

    """filter the rows returned"""
    where: ChatbotDomainBoolExp
  ): ChatbotDomainAggregate!

  """fetch data from the table: "chatbot_domain" using primary key columns"""
  chatbotDomainByPk(chatbotId: Int!, domainName: String!): ChatbotDomain

  """
  fetch data from the table in a streaming manner: "chatbot_domain"
  """
  chatbotDomainStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ChatbotDomainStreamCursorInput]!

    """filter the rows returned"""
    where: ChatbotDomainBoolExp
  ): [ChatbotDomain!]!

  """
  fetch data from the table in a streaming manner: "chatbot"
  """
  chatbotStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ChatbotStreamCursorInput]!

    """filter the rows returned"""
    where: ChatbotBoolExp
  ): [Chatbot!]!

  """
  fetch data from the table: "complexity_enum"
  """
  complexityEnum(
    """distinct select on columns"""
    distinctOn: [ComplexityEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ComplexityEnumOrderBy!]

    """filter the rows returned"""
    where: ComplexityEnumBoolExp
  ): [ComplexityEnum!]!

  """
  fetch aggregated fields from the table: "complexity_enum"
  """
  complexityEnumAggregate(
    """distinct select on columns"""
    distinctOn: [ComplexityEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ComplexityEnumOrderBy!]

    """filter the rows returned"""
    where: ComplexityEnumBoolExp
  ): ComplexityEnumAggregate!

  """fetch data from the table: "complexity_enum" using primary key columns"""
  complexityEnumByPk(value: String!): ComplexityEnum

  """
  fetch data from the table in a streaming manner: "complexity_enum"
  """
  complexityEnumStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ComplexityEnumStreamCursorInput]!

    """filter the rows returned"""
    where: ComplexityEnumBoolExp
  ): [ComplexityEnum!]!

  """
  fetch data from the table: "domain_enum"
  """
  domainEnum(
    """distinct select on columns"""
    distinctOn: [DomainEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [DomainEnumOrderBy!]

    """filter the rows returned"""
    where: DomainEnumBoolExp
  ): [DomainEnum!]!

  """
  fetch aggregated fields from the table: "domain_enum"
  """
  domainEnumAggregate(
    """distinct select on columns"""
    distinctOn: [DomainEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [DomainEnumOrderBy!]

    """filter the rows returned"""
    where: DomainEnumBoolExp
  ): DomainEnumAggregate!

  """fetch data from the table: "domain_enum" using primary key columns"""
  domainEnumByPk(name: String!): DomainEnum

  """
  fetch data from the table in a streaming manner: "domain_enum"
  """
  domainEnumStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [DomainEnumStreamCursorInput]!

    """filter the rows returned"""
    where: DomainEnumBoolExp
  ): [DomainEnum!]!

  """
  fetch data from the table: "example"
  """
  example(
    """distinct select on columns"""
    distinctOn: [ExampleSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ExampleOrderBy!]

    """filter the rows returned"""
    where: ExampleBoolExp
  ): [Example!]!

  """
  fetch aggregated fields from the table: "example"
  """
  exampleAggregate(
    """distinct select on columns"""
    distinctOn: [ExampleSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ExampleOrderBy!]

    """filter the rows returned"""
    where: ExampleBoolExp
  ): ExampleAggregate!

  """fetch data from the table: "example" using primary key columns"""
  exampleByPk(exampleId: uuid!): Example

  """
  fetch data from the table in a streaming manner: "example"
  """
  exampleStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ExampleStreamCursorInput]!

    """filter the rows returned"""
    where: ExampleBoolExp
  ): [Example!]!

  """
  fetch data from the table: "length_enum"
  """
  lengthEnum(
    """distinct select on columns"""
    distinctOn: [LengthEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [LengthEnumOrderBy!]

    """filter the rows returned"""
    where: LengthEnumBoolExp
  ): [LengthEnum!]!

  """
  fetch aggregated fields from the table: "length_enum"
  """
  lengthEnumAggregate(
    """distinct select on columns"""
    distinctOn: [LengthEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [LengthEnumOrderBy!]

    """filter the rows returned"""
    where: LengthEnumBoolExp
  ): LengthEnumAggregate!

  """fetch data from the table: "length_enum" using primary key columns"""
  lengthEnumByPk(value: String!): LengthEnum

  """
  fetch data from the table in a streaming manner: "length_enum"
  """
  lengthEnumStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [LengthEnumStreamCursorInput]!

    """filter the rows returned"""
    where: LengthEnumBoolExp
  ): [LengthEnum!]!

  """
  fetch data from the table: "message"
  """
  message(
    """distinct select on columns"""
    distinctOn: [MessageSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MessageOrderBy!]

    """filter the rows returned"""
    where: MessageBoolExp
  ): [Message!]!

  """
  fetch aggregated fields from the table: "message"
  """
  messageAggregate(
    """distinct select on columns"""
    distinctOn: [MessageSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MessageOrderBy!]

    """filter the rows returned"""
    where: MessageBoolExp
  ): MessageAggregate!

  """fetch data from the table: "message" using primary key columns"""
  messageByPk(messageId: uuid!): Message

  """
  fetch data from the table in a streaming manner: "message"
  """
  messageStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [MessageStreamCursorInput]!

    """filter the rows returned"""
    where: MessageBoolExp
  ): [Message!]!

  """
  fetch data from the table: "message_type_enum"
  """
  messageTypeEnum(
    """distinct select on columns"""
    distinctOn: [MessageTypeEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MessageTypeEnumOrderBy!]

    """filter the rows returned"""
    where: MessageTypeEnumBoolExp
  ): [MessageTypeEnum!]!

  """
  fetch aggregated fields from the table: "message_type_enum"
  """
  messageTypeEnumAggregate(
    """distinct select on columns"""
    distinctOn: [MessageTypeEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MessageTypeEnumOrderBy!]

    """filter the rows returned"""
    where: MessageTypeEnumBoolExp
  ): MessageTypeEnumAggregate!

  """
  fetch data from the table: "message_type_enum" using primary key columns
  """
  messageTypeEnumByPk(value: String!): MessageTypeEnum

  """
  fetch data from the table in a streaming manner: "message_type_enum"
  """
  messageTypeEnumStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [MessageTypeEnumStreamCursorInput]!

    """filter the rows returned"""
    where: MessageTypeEnumBoolExp
  ): [MessageTypeEnum!]!

  """
  fetch data from the table: "models_enum"
  """
  modelsEnum(
    """distinct select on columns"""
    distinctOn: [ModelsEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ModelsEnumOrderBy!]

    """filter the rows returned"""
    where: ModelsEnumBoolExp
  ): [ModelsEnum!]!

  """
  fetch aggregated fields from the table: "models_enum"
  """
  modelsEnumAggregate(
    """distinct select on columns"""
    distinctOn: [ModelsEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ModelsEnumOrderBy!]

    """filter the rows returned"""
    where: ModelsEnumBoolExp
  ): ModelsEnumAggregate!

  """fetch data from the table: "models_enum" using primary key columns"""
  modelsEnumByPk(name: String!): ModelsEnum

  """
  fetch data from the table in a streaming manner: "models_enum"
  """
  modelsEnumStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ModelsEnumStreamCursorInput]!

    """filter the rows returned"""
    where: ModelsEnumBoolExp
  ): [ModelsEnum!]!

  """
  fetch data from the table: "preference"
  """
  preference(
    """distinct select on columns"""
    distinctOn: [PreferenceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PreferenceOrderBy!]

    """filter the rows returned"""
    where: PreferenceBoolExp
  ): [Preference!]!

  """
  fetch aggregated fields from the table: "preference"
  """
  preferenceAggregate(
    """distinct select on columns"""
    distinctOn: [PreferenceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PreferenceOrderBy!]

    """filter the rows returned"""
    where: PreferenceBoolExp
  ): PreferenceAggregate!

  """fetch data from the table: "preference" using primary key columns"""
  preferenceByPk(preferenceId: Int!): Preference

  """
  fetch data from the table in a streaming manner: "preference"
  """
  preferenceStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [PreferenceStreamCursorInput]!

    """filter the rows returned"""
    where: PreferenceBoolExp
  ): [Preference!]!

  """
  fetch data from the table: "prompt"
  """
  prompt(
    """distinct select on columns"""
    distinctOn: [PromptSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptOrderBy!]

    """filter the rows returned"""
    where: PromptBoolExp
  ): [Prompt!]!

  """
  fetch aggregated fields from the table: "prompt"
  """
  promptAggregate(
    """distinct select on columns"""
    distinctOn: [PromptSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptOrderBy!]

    """filter the rows returned"""
    where: PromptBoolExp
  ): PromptAggregate!

  """fetch data from the table: "prompt" using primary key columns"""
  promptByPk(promptId: Int!): Prompt

  """
  fetch data from the table: "prompt_chatbot"
  """
  promptChatbot(
    """distinct select on columns"""
    distinctOn: [PromptChatbotSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptChatbotOrderBy!]

    """filter the rows returned"""
    where: PromptChatbotBoolExp
  ): [PromptChatbot!]!

  """
  fetch aggregated fields from the table: "prompt_chatbot"
  """
  promptChatbotAggregate(
    """distinct select on columns"""
    distinctOn: [PromptChatbotSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptChatbotOrderBy!]

    """filter the rows returned"""
    where: PromptChatbotBoolExp
  ): PromptChatbotAggregate!

  """fetch data from the table: "prompt_chatbot" using primary key columns"""
  promptChatbotByPk(chabotId: Int!, promptId: Int!): PromptChatbot

  """
  fetch data from the table in a streaming manner: "prompt_chatbot"
  """
  promptChatbotStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [PromptChatbotStreamCursorInput]!

    """filter the rows returned"""
    where: PromptChatbotBoolExp
  ): [PromptChatbot!]!

  """
  fetch data from the table in a streaming manner: "prompt"
  """
  promptStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [PromptStreamCursorInput]!

    """filter the rows returned"""
    where: PromptBoolExp
  ): [Prompt!]!

  """
  fetch data from the table: "prompt_type_enum"
  """
  promptTypeEnum(
    """distinct select on columns"""
    distinctOn: [PromptTypeEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptTypeEnumOrderBy!]

    """filter the rows returned"""
    where: PromptTypeEnumBoolExp
  ): [PromptTypeEnum!]!

  """
  fetch aggregated fields from the table: "prompt_type_enum"
  """
  promptTypeEnumAggregate(
    """distinct select on columns"""
    distinctOn: [PromptTypeEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptTypeEnumOrderBy!]

    """filter the rows returned"""
    where: PromptTypeEnumBoolExp
  ): PromptTypeEnumAggregate!

  """
  fetch data from the table: "prompt_type_enum" using primary key columns
  """
  promptTypeEnumByPk(value: String!): PromptTypeEnum

  """
  fetch data from the table in a streaming manner: "prompt_type_enum"
  """
  promptTypeEnumStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [PromptTypeEnumStreamCursorInput]!

    """filter the rows returned"""
    where: PromptTypeEnumBoolExp
  ): [PromptTypeEnum!]!

  """
  fetch data from the table: "prompt_user"
  """
  promptUser(
    """distinct select on columns"""
    distinctOn: [PromptUserSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptUserOrderBy!]

    """filter the rows returned"""
    where: PromptUserBoolExp
  ): [PromptUser!]!

  """
  fetch aggregated fields from the table: "prompt_user"
  """
  promptUserAggregate(
    """distinct select on columns"""
    distinctOn: [PromptUserSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptUserOrderBy!]

    """filter the rows returned"""
    where: PromptUserBoolExp
  ): PromptUserAggregate!

  """fetch data from the table: "prompt_user" using primary key columns"""
  promptUserByPk(promptId: Int!, userId: uuid!): PromptUser

  """
  fetch data from the table in a streaming manner: "prompt_user"
  """
  promptUserStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [PromptUserStreamCursorInput]!

    """filter the rows returned"""
    where: PromptUserBoolExp
  ): [PromptUser!]!

  """
  fetch data from the table: "referral"
  """
  referral(
    """distinct select on columns"""
    distinctOn: [ReferralSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ReferralOrderBy!]

    """filter the rows returned"""
    where: ReferralBoolExp
  ): [Referral!]!

  """
  fetch aggregated fields from the table: "referral"
  """
  referralAggregate(
    """distinct select on columns"""
    distinctOn: [ReferralSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ReferralOrderBy!]

    """filter the rows returned"""
    where: ReferralBoolExp
  ): ReferralAggregate!

  """fetch data from the table: "referral" using primary key columns"""
  referralByPk(referralCode: String!): Referral

  """
  fetch data from the table in a streaming manner: "referral"
  """
  referralStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ReferralStreamCursorInput]!

    """filter the rows returned"""
    where: ReferralBoolExp
  ): [Referral!]!

  """
  fetch data from the table: "social_following"
  """
  socialFollowing(
    """distinct select on columns"""
    distinctOn: [SocialFollowingSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [SocialFollowingOrderBy!]

    """filter the rows returned"""
    where: SocialFollowingBoolExp
  ): [SocialFollowing!]!

  """
  fetch aggregated fields from the table: "social_following"
  """
  socialFollowingAggregate(
    """distinct select on columns"""
    distinctOn: [SocialFollowingSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [SocialFollowingOrderBy!]

    """filter the rows returned"""
    where: SocialFollowingBoolExp
  ): SocialFollowingAggregate!

  """
  fetch data from the table in a streaming manner: "social_following"
  """
  socialFollowingStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [SocialFollowingStreamCursorInput]!

    """filter the rows returned"""
    where: SocialFollowingBoolExp
  ): [SocialFollowing!]!

  """
  fetch data from the table: "subcategory_enum"
  """
  subcategoryEnum(
    """distinct select on columns"""
    distinctOn: [SubcategoryEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [SubcategoryEnumOrderBy!]

    """filter the rows returned"""
    where: SubcategoryEnumBoolExp
  ): [SubcategoryEnum!]!

  """
  fetch aggregated fields from the table: "subcategory_enum"
  """
  subcategoryEnumAggregate(
    """distinct select on columns"""
    distinctOn: [SubcategoryEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [SubcategoryEnumOrderBy!]

    """filter the rows returned"""
    where: SubcategoryEnumBoolExp
  ): SubcategoryEnumAggregate!

  """
  fetch data from the table: "subcategory_enum" using primary key columns
  """
  subcategoryEnumByPk(category: String!, domain: String!, name: String!): SubcategoryEnum

  """
  fetch data from the table in a streaming manner: "subcategory_enum"
  """
  subcategoryEnumStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [SubcategoryEnumStreamCursorInput]!

    """filter the rows returned"""
    where: SubcategoryEnumBoolExp
  ): [SubcategoryEnum!]!

  """
  fetch data from the table: "tag_enum"
  """
  tagEnum(
    """distinct select on columns"""
    distinctOn: [TagEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TagEnumOrderBy!]

    """filter the rows returned"""
    where: TagEnumBoolExp
  ): [TagEnum!]!

  """
  fetch aggregated fields from the table: "tag_enum"
  """
  tagEnumAggregate(
    """distinct select on columns"""
    distinctOn: [TagEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TagEnumOrderBy!]

    """filter the rows returned"""
    where: TagEnumBoolExp
  ): TagEnumAggregate!

  """fetch data from the table: "tag_enum" using primary key columns"""
  tagEnumByPk(tagId: uuid!): TagEnum

  """
  fetch data from the table in a streaming manner: "tag_enum"
  """
  tagEnumStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [TagEnumStreamCursorInput]!

    """filter the rows returned"""
    where: TagEnumBoolExp
  ): [TagEnum!]!

  """
  fetch data from the table: "thread"
  """
  thread(
    """distinct select on columns"""
    distinctOn: [ThreadSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ThreadOrderBy!]

    """filter the rows returned"""
    where: ThreadBoolExp
  ): [Thread!]!

  """
  fetch aggregated fields from the table: "thread"
  """
  threadAggregate(
    """distinct select on columns"""
    distinctOn: [ThreadSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ThreadOrderBy!]

    """filter the rows returned"""
    where: ThreadBoolExp
  ): ThreadAggregate!

  """fetch data from the table: "thread" using primary key columns"""
  threadByPk(threadId: uuid!): Thread

  """
  fetch data from the table in a streaming manner: "thread"
  """
  threadStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ThreadStreamCursorInput]!

    """filter the rows returned"""
    where: ThreadBoolExp
  ): [Thread!]!

  """
  fetch data from the table: "token"
  """
  token(
    """distinct select on columns"""
    distinctOn: [TokenSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TokenOrderBy!]

    """filter the rows returned"""
    where: TokenBoolExp
  ): [Token!]!

  """
  fetch aggregated fields from the table: "token"
  """
  tokenAggregate(
    """distinct select on columns"""
    distinctOn: [TokenSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TokenOrderBy!]

    """filter the rows returned"""
    where: TokenBoolExp
  ): TokenAggregate!

  """fetch data from the table: "token" using primary key columns"""
  tokenByPk(token: String!): Token

  """
  fetch data from the table in a streaming manner: "token"
  """
  tokenStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [TokenStreamCursorInput]!

    """filter the rows returned"""
    where: TokenBoolExp
  ): [Token!]!

  """
  fetch data from the table: "tone_enum"
  """
  toneEnum(
    """distinct select on columns"""
    distinctOn: [ToneEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ToneEnumOrderBy!]

    """filter the rows returned"""
    where: ToneEnumBoolExp
  ): [ToneEnum!]!

  """
  fetch aggregated fields from the table: "tone_enum"
  """
  toneEnumAggregate(
    """distinct select on columns"""
    distinctOn: [ToneEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ToneEnumOrderBy!]

    """filter the rows returned"""
    where: ToneEnumBoolExp
  ): ToneEnumAggregate!

  """fetch data from the table: "tone_enum" using primary key columns"""
  toneEnumByPk(value: String!): ToneEnum

  """
  fetch data from the table in a streaming manner: "tone_enum"
  """
  toneEnumStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ToneEnumStreamCursorInput]!

    """filter the rows returned"""
    where: ToneEnumBoolExp
  ): [ToneEnum!]!

  """
  fetch data from the table: "type_enum"
  """
  typeEnum(
    """distinct select on columns"""
    distinctOn: [TypeEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TypeEnumOrderBy!]

    """filter the rows returned"""
    where: TypeEnumBoolExp
  ): [TypeEnum!]!

  """
  fetch aggregated fields from the table: "type_enum"
  """
  typeEnumAggregate(
    """distinct select on columns"""
    distinctOn: [TypeEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TypeEnumOrderBy!]

    """filter the rows returned"""
    where: TypeEnumBoolExp
  ): TypeEnumAggregate!

  """fetch data from the table: "type_enum" using primary key columns"""
  typeEnumByPk(value: String!): TypeEnum

  """
  fetch data from the table in a streaming manner: "type_enum"
  """
  typeEnumStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [TypeEnumStreamCursorInput]!

    """filter the rows returned"""
    where: TypeEnumBoolExp
  ): [TypeEnum!]!

  """
  fetch data from the table: "user"
  """
  user(
    """distinct select on columns"""
    distinctOn: [UserSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [UserOrderBy!]

    """filter the rows returned"""
    where: UserBoolExp
  ): [User!]!

  """
  fetch aggregated fields from the table: "user"
  """
  userAggregate(
    """distinct select on columns"""
    distinctOn: [UserSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [UserOrderBy!]

    """filter the rows returned"""
    where: UserBoolExp
  ): UserAggregate!

  """fetch data from the table: "user" using primary key columns"""
  userByPk(userId: uuid!): User

  """
  fetch data from the table in a streaming manner: "user"
  """
  userStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [UserStreamCursorInput]!

    """filter the rows returned"""
    where: UserBoolExp
  ): [User!]!

  """
  fetch data from the table: "user_token"
  """
  userToken(
    """distinct select on columns"""
    distinctOn: [UserTokenSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [UserTokenOrderBy!]

    """filter the rows returned"""
    where: UserTokenBoolExp
  ): [UserToken!]!

  """
  fetch aggregated fields from the table: "user_token"
  """
  userTokenAggregate(
    """distinct select on columns"""
    distinctOn: [UserTokenSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [UserTokenOrderBy!]

    """filter the rows returned"""
    where: UserTokenBoolExp
  ): UserTokenAggregate!

  """fetch data from the table: "user_token" using primary key columns"""
  userTokenByPk(token: String!, userId: uuid!): UserToken

  """
  fetch data from the table in a streaming manner: "user_token"
  """
  userTokenStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [UserTokenStreamCursorInput]!

    """filter the rows returned"""
    where: UserTokenBoolExp
  ): [UserToken!]!
}

input tagEnumAggregateBoolExpCount {
  arguments: [TagEnumSelectColumn!]
  distinct: Boolean
  filter: TagEnumBoolExp
  predicate: IntComparisonExp!
}

input threadAggregateBoolExpBool_and {
  arguments: ThreadSelectColumnThreadAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: ThreadBoolExp
  predicate: BooleanComparisonExp!
}

input threadAggregateBoolExpBool_or {
  arguments: ThreadSelectColumnThreadAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: ThreadBoolExp
  predicate: BooleanComparisonExp!
}

input threadAggregateBoolExpCount {
  arguments: [ThreadSelectColumn!]
  distinct: Boolean
  filter: ThreadBoolExp
  predicate: IntComparisonExp!
}

scalar timestamptz

input userTokenAggregateBoolExpCount {
  arguments: [UserTokenSelectColumn!]
  distinct: Boolean
  filter: UserTokenBoolExp
  predicate: IntComparisonExp!
}

scalar user_role

scalar uuid