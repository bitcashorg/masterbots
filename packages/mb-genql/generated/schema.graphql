schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """measured in seconds"""
  ttl: Int! = 60

  """refresh the cache entry"""
  refresh: Boolean! = false
) on QUERY

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input BooleanComparisonExp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _isNull: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""Table to store different categories for chatbots."""
type Category {
  categoryId: Int!

  """An array relationship"""
  chatbots(
    """distinct select on columns"""
    distinctOn: [ChatbotCategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotCategoryOrderBy!]

    """filter the rows returned"""
    where: ChatbotCategoryBoolExp
  ): [ChatbotCategory!]!

  """An aggregate relationship"""
  chatbotsAggregate(
    """distinct select on columns"""
    distinctOn: [ChatbotCategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotCategoryOrderBy!]

    """filter the rows returned"""
    where: ChatbotCategoryBoolExp
  ): ChatbotCategoryAggregate!

  """An array relationship"""
  metadataLabels(
    """distinct select on columns"""
    distinctOn: [LabelChatbotCategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [LabelChatbotCategoryOrderBy!]

    """filter the rows returned"""
    where: LabelChatbotCategoryBoolExp
  ): [LabelChatbotCategory!]!

  """An aggregate relationship"""
  metadataLabelsAggregate(
    """distinct select on columns"""
    distinctOn: [LabelChatbotCategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [LabelChatbotCategoryOrderBy!]

    """filter the rows returned"""
    where: LabelChatbotCategoryBoolExp
  ): LabelChatbotCategoryAggregate!
  name: String!
}

"""
aggregated selection of "category"
"""
type CategoryAggregate {
  aggregate: CategoryAggregateFields
  nodes: [Category!]!
}

"""
aggregate fields of "category"
"""
type CategoryAggregateFields {
  avg: CategoryAvgFields
  count(columns: [CategorySelectColumn!], distinct: Boolean): Int!
  max: CategoryMaxFields
  min: CategoryMinFields
  stddev: CategoryStddevFields
  stddevPop: CategoryStddevPopFields
  stddevSamp: CategoryStddevSampFields
  sum: CategorySumFields
  varPop: CategoryVarPopFields
  varSamp: CategoryVarSampFields
  variance: CategoryVarianceFields
}

"""aggregate avg on columns"""
type CategoryAvgFields {
  categoryId: Float
}

"""
Boolean expression to filter rows from the table "category". All fields are combined with a logical 'AND'.
"""
input CategoryBoolExp {
  _and: [CategoryBoolExp!]
  _not: CategoryBoolExp
  _or: [CategoryBoolExp!]
  categoryId: IntComparisonExp
  chatbots: ChatbotCategoryBoolExp
  chatbotsAggregate: ChatbotCategoryAggregateBoolExp
  metadataLabels: LabelChatbotCategoryBoolExp
  metadataLabelsAggregate: LabelChatbotCategoryAggregateBoolExp
  name: StringComparisonExp
}

"""
unique or primary key constraints on table "category"
"""
enum CategoryConstraint {
  """
  unique or primary key constraint on columns "name"
  """
  category_name_key

  """
  unique or primary key constraint on columns "category_id"
  """
  category_pkey
}

"""
input type for incrementing numeric columns in table "category"
"""
input CategoryIncInput {
  categoryId: Int
}

"""
input type for inserting data into table "category"
"""
input CategoryInsertInput {
  categoryId: Int
  chatbots: ChatbotCategoryArrRelInsertInput
  metadataLabels: LabelChatbotCategoryArrRelInsertInput
  name: String
}

"""aggregate max on columns"""
type CategoryMaxFields {
  categoryId: Int
  name: String
}

"""aggregate min on columns"""
type CategoryMinFields {
  categoryId: Int
  name: String
}

"""
response of any mutation on the table "category"
"""
type CategoryMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Category!]!
}

"""
input type for inserting object relation for remote table "category"
"""
input CategoryObjRelInsertInput {
  data: CategoryInsertInput!

  """upsert condition"""
  onConflict: CategoryOnConflict
}

"""
on_conflict condition type for table "category"
"""
input CategoryOnConflict {
  constraint: CategoryConstraint!
  updateColumns: [CategoryUpdateColumn!]! = []
  where: CategoryBoolExp
}

"""Ordering options when selecting data from "category"."""
input CategoryOrderBy {
  categoryId: OrderBy
  chatbotsAggregate: ChatbotCategoryAggregateOrderBy
  metadataLabelsAggregate: LabelChatbotCategoryAggregateOrderBy
  name: OrderBy
}

"""primary key columns input for table: category"""
input CategoryPkColumnsInput {
  categoryId: Int!
}

"""
select columns of table "category"
"""
enum CategorySelectColumn {
  """column name"""
  categoryId

  """column name"""
  name
}

"""
input type for updating data in table "category"
"""
input CategorySetInput {
  categoryId: Int
  name: String
}

"""aggregate stddev on columns"""
type CategoryStddevFields {
  categoryId: Float
}

"""aggregate stddevPop on columns"""
type CategoryStddevPopFields {
  categoryId: Float
}

"""aggregate stddevSamp on columns"""
type CategoryStddevSampFields {
  categoryId: Float
}

"""
Streaming cursor of the table "category"
"""
input CategoryStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: CategoryStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input CategoryStreamCursorValueInput {
  categoryId: Int
  name: String
}

"""aggregate sum on columns"""
type CategorySumFields {
  categoryId: Int
}

"""
update columns of table "category"
"""
enum CategoryUpdateColumn {
  """column name"""
  categoryId

  """column name"""
  name
}

input CategoryUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: CategoryIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: CategorySetInput

  """filter the rows which have to be updated"""
  where: CategoryBoolExp!
}

"""aggregate varPop on columns"""
type CategoryVarPopFields {
  categoryId: Float
}

"""aggregate varSamp on columns"""
type CategoryVarSampFields {
  categoryId: Float
}

"""aggregate variance on columns"""
type CategoryVarianceFields {
  categoryId: Float
}

"""
Table to store links to GPT chat conversations and associate them with a specific GPT chatbot and the user who added the link.
"""
type Chat {
  addedBy: uuid
  chatId: Int!

  """An object relationship"""
  chatbot: Chatbot!
  chatbotId: Int!
  conversationLink: String!

  """An object relationship"""
  user: User
}

"""
aggregated selection of "chat"
"""
type ChatAggregate {
  aggregate: ChatAggregateFields
  nodes: [Chat!]!
}

input ChatAggregateBoolExp {
  count: chatAggregateBoolExpCount
}

"""
aggregate fields of "chat"
"""
type ChatAggregateFields {
  avg: ChatAvgFields
  count(columns: [ChatSelectColumn!], distinct: Boolean): Int!
  max: ChatMaxFields
  min: ChatMinFields
  stddev: ChatStddevFields
  stddevPop: ChatStddevPopFields
  stddevSamp: ChatStddevSampFields
  sum: ChatSumFields
  varPop: ChatVarPopFields
  varSamp: ChatVarSampFields
  variance: ChatVarianceFields
}

"""
order by aggregate values of table "chat"
"""
input ChatAggregateOrderBy {
  avg: ChatAvgOrderBy
  count: OrderBy
  max: ChatMaxOrderBy
  min: ChatMinOrderBy
  stddev: ChatStddevOrderBy
  stddevPop: ChatStddevPopOrderBy
  stddevSamp: ChatStddevSampOrderBy
  sum: ChatSumOrderBy
  varPop: ChatVarPopOrderBy
  varSamp: ChatVarSampOrderBy
  variance: ChatVarianceOrderBy
}

"""
input type for inserting array relation for remote table "chat"
"""
input ChatArrRelInsertInput {
  data: [ChatInsertInput!]!

  """upsert condition"""
  onConflict: ChatOnConflict
}

"""aggregate avg on columns"""
type ChatAvgFields {
  chatId: Float
  chatbotId: Float
}

"""
order by avg() on columns of table "chat"
"""
input ChatAvgOrderBy {
  chatId: OrderBy
  chatbotId: OrderBy
}

"""
Boolean expression to filter rows from the table "chat". All fields are combined with a logical 'AND'.
"""
input ChatBoolExp {
  _and: [ChatBoolExp!]
  _not: ChatBoolExp
  _or: [ChatBoolExp!]
  addedBy: UuidComparisonExp
  chatId: IntComparisonExp
  chatbot: ChatbotBoolExp
  chatbotId: IntComparisonExp
  conversationLink: StringComparisonExp
  user: UserBoolExp
}

"""
unique or primary key constraints on table "chat"
"""
enum ChatConstraint {
  """
  unique or primary key constraint on columns "conversation_link"
  """
  gpt_chat_conversation_link_key

  """
  unique or primary key constraint on columns "chat_id"
  """
  gpt_chat_pkey
}

"""
input type for incrementing numeric columns in table "chat"
"""
input ChatIncInput {
  chatId: Int
  chatbotId: Int
}

"""
input type for inserting data into table "chat"
"""
input ChatInsertInput {
  addedBy: uuid
  chatId: Int
  chatbot: ChatbotObjRelInsertInput
  chatbotId: Int
  conversationLink: String
  user: UserObjRelInsertInput
}

"""aggregate max on columns"""
type ChatMaxFields {
  addedBy: uuid
  chatId: Int
  chatbotId: Int
  conversationLink: String
}

"""
order by max() on columns of table "chat"
"""
input ChatMaxOrderBy {
  addedBy: OrderBy
  chatId: OrderBy
  chatbotId: OrderBy
  conversationLink: OrderBy
}

"""aggregate min on columns"""
type ChatMinFields {
  addedBy: uuid
  chatId: Int
  chatbotId: Int
  conversationLink: String
}

"""
order by min() on columns of table "chat"
"""
input ChatMinOrderBy {
  addedBy: OrderBy
  chatId: OrderBy
  chatbotId: OrderBy
  conversationLink: OrderBy
}

"""
response of any mutation on the table "chat"
"""
type ChatMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Chat!]!
}

"""
on_conflict condition type for table "chat"
"""
input ChatOnConflict {
  constraint: ChatConstraint!
  updateColumns: [ChatUpdateColumn!]! = []
  where: ChatBoolExp
}

"""Ordering options when selecting data from "chat"."""
input ChatOrderBy {
  addedBy: OrderBy
  chatId: OrderBy
  chatbot: ChatbotOrderBy
  chatbotId: OrderBy
  conversationLink: OrderBy
  user: UserOrderBy
}

"""primary key columns input for table: chat"""
input ChatPkColumnsInput {
  chatId: Int!
}

"""
select columns of table "chat"
"""
enum ChatSelectColumn {
  """column name"""
  addedBy

  """column name"""
  chatId

  """column name"""
  chatbotId

  """column name"""
  conversationLink
}

"""
input type for updating data in table "chat"
"""
input ChatSetInput {
  addedBy: uuid
  chatId: Int
  chatbotId: Int
  conversationLink: String
}

"""aggregate stddev on columns"""
type ChatStddevFields {
  chatId: Float
  chatbotId: Float
}

"""
order by stddev() on columns of table "chat"
"""
input ChatStddevOrderBy {
  chatId: OrderBy
  chatbotId: OrderBy
}

"""aggregate stddevPop on columns"""
type ChatStddevPopFields {
  chatId: Float
  chatbotId: Float
}

"""
order by stddevPop() on columns of table "chat"
"""
input ChatStddevPopOrderBy {
  chatId: OrderBy
  chatbotId: OrderBy
}

"""aggregate stddevSamp on columns"""
type ChatStddevSampFields {
  chatId: Float
  chatbotId: Float
}

"""
order by stddevSamp() on columns of table "chat"
"""
input ChatStddevSampOrderBy {
  chatId: OrderBy
  chatbotId: OrderBy
}

"""
Streaming cursor of the table "chat"
"""
input ChatStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ChatStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ChatStreamCursorValueInput {
  addedBy: uuid
  chatId: Int
  chatbotId: Int
  conversationLink: String
}

"""aggregate sum on columns"""
type ChatSumFields {
  chatId: Int
  chatbotId: Int
}

"""
order by sum() on columns of table "chat"
"""
input ChatSumOrderBy {
  chatId: OrderBy
  chatbotId: OrderBy
}

"""
update columns of table "chat"
"""
enum ChatUpdateColumn {
  """column name"""
  addedBy

  """column name"""
  chatId

  """column name"""
  chatbotId

  """column name"""
  conversationLink
}

input ChatUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: ChatIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: ChatSetInput

  """filter the rows which have to be updated"""
  where: ChatBoolExp!
}

"""aggregate varPop on columns"""
type ChatVarPopFields {
  chatId: Float
  chatbotId: Float
}

"""
order by varPop() on columns of table "chat"
"""
input ChatVarPopOrderBy {
  chatId: OrderBy
  chatbotId: OrderBy
}

"""aggregate varSamp on columns"""
type ChatVarSampFields {
  chatId: Float
  chatbotId: Float
}

"""
order by varSamp() on columns of table "chat"
"""
input ChatVarSampOrderBy {
  chatId: OrderBy
  chatbotId: OrderBy
}

"""aggregate variance on columns"""
type ChatVarianceFields {
  chatId: Float
  chatbotId: Float
}

"""
order by variance() on columns of table "chat"
"""
input ChatVarianceOrderBy {
  chatId: OrderBy
  chatbotId: OrderBy
}

"""
Table storing information about chatbots, their characteristics, and default settings.
"""
type Chatbot {
  avatar: String

  """An array relationship"""
  categories(
    """distinct select on columns"""
    distinctOn: [ChatbotCategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotCategoryOrderBy!]

    """filter the rows returned"""
    where: ChatbotCategoryBoolExp
  ): [ChatbotCategory!]!

  """An aggregate relationship"""
  categoriesAggregate(
    """distinct select on columns"""
    distinctOn: [ChatbotCategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotCategoryOrderBy!]

    """filter the rows returned"""
    where: ChatbotCategoryBoolExp
  ): ChatbotCategoryAggregate!
  chatbotId: Int!

  """An array relationship"""
  chats(
    """distinct select on columns"""
    distinctOn: [ChatSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatOrderBy!]

    """filter the rows returned"""
    where: ChatBoolExp
  ): [Chat!]!

  """An aggregate relationship"""
  chatsAggregate(
    """distinct select on columns"""
    distinctOn: [ChatSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatOrderBy!]

    """filter the rows returned"""
    where: ChatBoolExp
  ): ChatAggregate!

  """An object relationship"""
  complexityEnum: ComplexityEnum
  createdBy: String!
  defaultComplexity: String
  defaultLength: String
  defaultTone: String
  defaultType: String
  description: String

  """An object relationship"""
  lengthEnum: LengthEnum

  """An array relationship"""
  metadataLabels(
    """distinct select on columns"""
    distinctOn: [LabelChatbotCategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [LabelChatbotCategoryOrderBy!]

    """filter the rows returned"""
    where: LabelChatbotCategoryBoolExp
  ): [LabelChatbotCategory!]!

  """An aggregate relationship"""
  metadataLabelsAggregate(
    """distinct select on columns"""
    distinctOn: [LabelChatbotCategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [LabelChatbotCategoryOrderBy!]

    """filter the rows returned"""
    where: LabelChatbotCategoryBoolExp
  ): LabelChatbotCategoryAggregate!
  name: String!

  """An array relationship"""
  preferences(
    """distinct select on columns"""
    distinctOn: [PreferenceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PreferenceOrderBy!]

    """filter the rows returned"""
    where: PreferenceBoolExp
  ): [Preference!]!

  """An aggregate relationship"""
  preferencesAggregate(
    """distinct select on columns"""
    distinctOn: [PreferenceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PreferenceOrderBy!]

    """filter the rows returned"""
    where: PreferenceBoolExp
  ): PreferenceAggregate!

  """An array relationship"""
  prompts(
    """distinct select on columns"""
    distinctOn: [PromptChatbotSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptChatbotOrderBy!]

    """filter the rows returned"""
    where: PromptChatbotBoolExp
  ): [PromptChatbot!]!

  """An aggregate relationship"""
  promptsAggregate(
    """distinct select on columns"""
    distinctOn: [PromptChatbotSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptChatbotOrderBy!]

    """filter the rows returned"""
    where: PromptChatbotBoolExp
  ): PromptChatbotAggregate!

  """An array relationship"""
  threads(
    """distinct select on columns"""
    distinctOn: [ThreadSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ThreadOrderBy!]

    """filter the rows returned"""
    where: ThreadBoolExp
  ): [Thread!]!

  """An aggregate relationship"""
  threadsAggregate(
    """distinct select on columns"""
    distinctOn: [ThreadSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ThreadOrderBy!]

    """filter the rows returned"""
    where: ThreadBoolExp
  ): ThreadAggregate!

  """An object relationship"""
  toneEnum: ToneEnum

  """An object relationship"""
  typeEnum: TypeEnum
}

"""
aggregated selection of "chatbot"
"""
type ChatbotAggregate {
  aggregate: ChatbotAggregateFields
  nodes: [Chatbot!]!
}

input ChatbotAggregateBoolExp {
  count: chatbotAggregateBoolExpCount
}

"""
aggregate fields of "chatbot"
"""
type ChatbotAggregateFields {
  avg: ChatbotAvgFields
  count(columns: [ChatbotSelectColumn!], distinct: Boolean): Int!
  max: ChatbotMaxFields
  min: ChatbotMinFields
  stddev: ChatbotStddevFields
  stddevPop: ChatbotStddevPopFields
  stddevSamp: ChatbotStddevSampFields
  sum: ChatbotSumFields
  varPop: ChatbotVarPopFields
  varSamp: ChatbotVarSampFields
  variance: ChatbotVarianceFields
}

"""
order by aggregate values of table "chatbot"
"""
input ChatbotAggregateOrderBy {
  avg: ChatbotAvgOrderBy
  count: OrderBy
  max: ChatbotMaxOrderBy
  min: ChatbotMinOrderBy
  stddev: ChatbotStddevOrderBy
  stddevPop: ChatbotStddevPopOrderBy
  stddevSamp: ChatbotStddevSampOrderBy
  sum: ChatbotSumOrderBy
  varPop: ChatbotVarPopOrderBy
  varSamp: ChatbotVarSampOrderBy
  variance: ChatbotVarianceOrderBy
}

"""
input type for inserting array relation for remote table "chatbot"
"""
input ChatbotArrRelInsertInput {
  data: [ChatbotInsertInput!]!

  """upsert condition"""
  onConflict: ChatbotOnConflict
}

"""aggregate avg on columns"""
type ChatbotAvgFields {
  chatbotId: Float
}

"""
order by avg() on columns of table "chatbot"
"""
input ChatbotAvgOrderBy {
  chatbotId: OrderBy
}

"""
Boolean expression to filter rows from the table "chatbot". All fields are combined with a logical 'AND'.
"""
input ChatbotBoolExp {
  _and: [ChatbotBoolExp!]
  _not: ChatbotBoolExp
  _or: [ChatbotBoolExp!]
  avatar: StringComparisonExp
  categories: ChatbotCategoryBoolExp
  categoriesAggregate: ChatbotCategoryAggregateBoolExp
  chatbotId: IntComparisonExp
  chats: ChatBoolExp
  chatsAggregate: ChatAggregateBoolExp
  complexityEnum: ComplexityEnumBoolExp
  createdBy: StringComparisonExp
  defaultComplexity: StringComparisonExp
  defaultLength: StringComparisonExp
  defaultTone: StringComparisonExp
  defaultType: StringComparisonExp
  description: StringComparisonExp
  lengthEnum: LengthEnumBoolExp
  metadataLabels: LabelChatbotCategoryBoolExp
  metadataLabelsAggregate: LabelChatbotCategoryAggregateBoolExp
  name: StringComparisonExp
  preferences: PreferenceBoolExp
  preferencesAggregate: PreferenceAggregateBoolExp
  prompts: PromptChatbotBoolExp
  promptsAggregate: PromptChatbotAggregateBoolExp
  threads: ThreadBoolExp
  threadsAggregate: ThreadAggregateBoolExp
  toneEnum: ToneEnumBoolExp
  typeEnum: TypeEnumBoolExp
}

"""
Junction table to manage the many-to-many relationships between chatbots and their categories.
"""
type ChatbotCategory {
  """An object relationship"""
  category: Category!
  categoryId: Int!

  """An object relationship"""
  chatbot: Chatbot!
  chatbotId: Int!
}

"""
aggregated selection of "chatbot_category"
"""
type ChatbotCategoryAggregate {
  aggregate: ChatbotCategoryAggregateFields
  nodes: [ChatbotCategory!]!
}

input ChatbotCategoryAggregateBoolExp {
  count: chatbotCategoryAggregateBoolExpCount
}

"""
aggregate fields of "chatbot_category"
"""
type ChatbotCategoryAggregateFields {
  avg: ChatbotCategoryAvgFields
  count(columns: [ChatbotCategorySelectColumn!], distinct: Boolean): Int!
  max: ChatbotCategoryMaxFields
  min: ChatbotCategoryMinFields
  stddev: ChatbotCategoryStddevFields
  stddevPop: ChatbotCategoryStddevPopFields
  stddevSamp: ChatbotCategoryStddevSampFields
  sum: ChatbotCategorySumFields
  varPop: ChatbotCategoryVarPopFields
  varSamp: ChatbotCategoryVarSampFields
  variance: ChatbotCategoryVarianceFields
}

"""
order by aggregate values of table "chatbot_category"
"""
input ChatbotCategoryAggregateOrderBy {
  avg: ChatbotCategoryAvgOrderBy
  count: OrderBy
  max: ChatbotCategoryMaxOrderBy
  min: ChatbotCategoryMinOrderBy
  stddev: ChatbotCategoryStddevOrderBy
  stddevPop: ChatbotCategoryStddevPopOrderBy
  stddevSamp: ChatbotCategoryStddevSampOrderBy
  sum: ChatbotCategorySumOrderBy
  varPop: ChatbotCategoryVarPopOrderBy
  varSamp: ChatbotCategoryVarSampOrderBy
  variance: ChatbotCategoryVarianceOrderBy
}

"""
input type for inserting array relation for remote table "chatbot_category"
"""
input ChatbotCategoryArrRelInsertInput {
  data: [ChatbotCategoryInsertInput!]!

  """upsert condition"""
  onConflict: ChatbotCategoryOnConflict
}

"""aggregate avg on columns"""
type ChatbotCategoryAvgFields {
  categoryId: Float
  chatbotId: Float
}

"""
order by avg() on columns of table "chatbot_category"
"""
input ChatbotCategoryAvgOrderBy {
  categoryId: OrderBy
  chatbotId: OrderBy
}

"""
Boolean expression to filter rows from the table "chatbot_category". All fields are combined with a logical 'AND'.
"""
input ChatbotCategoryBoolExp {
  _and: [ChatbotCategoryBoolExp!]
  _not: ChatbotCategoryBoolExp
  _or: [ChatbotCategoryBoolExp!]
  category: CategoryBoolExp
  categoryId: IntComparisonExp
  chatbot: ChatbotBoolExp
  chatbotId: IntComparisonExp
}

"""
unique or primary key constraints on table "chatbot_category"
"""
enum ChatbotCategoryConstraint {
  """
  unique or primary key constraint on columns "category_id", "chatbot_id"
  """
  chatbot_category_pkey
}

"""
input type for incrementing numeric columns in table "chatbot_category"
"""
input ChatbotCategoryIncInput {
  categoryId: Int
  chatbotId: Int
}

"""
input type for inserting data into table "chatbot_category"
"""
input ChatbotCategoryInsertInput {
  category: CategoryObjRelInsertInput
  categoryId: Int
  chatbot: ChatbotObjRelInsertInput
  chatbotId: Int
}

"""aggregate max on columns"""
type ChatbotCategoryMaxFields {
  categoryId: Int
  chatbotId: Int
}

"""
order by max() on columns of table "chatbot_category"
"""
input ChatbotCategoryMaxOrderBy {
  categoryId: OrderBy
  chatbotId: OrderBy
}

"""aggregate min on columns"""
type ChatbotCategoryMinFields {
  categoryId: Int
  chatbotId: Int
}

"""
order by min() on columns of table "chatbot_category"
"""
input ChatbotCategoryMinOrderBy {
  categoryId: OrderBy
  chatbotId: OrderBy
}

"""
response of any mutation on the table "chatbot_category"
"""
type ChatbotCategoryMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [ChatbotCategory!]!
}

"""
on_conflict condition type for table "chatbot_category"
"""
input ChatbotCategoryOnConflict {
  constraint: ChatbotCategoryConstraint!
  updateColumns: [ChatbotCategoryUpdateColumn!]! = []
  where: ChatbotCategoryBoolExp
}

"""Ordering options when selecting data from "chatbot_category"."""
input ChatbotCategoryOrderBy {
  category: CategoryOrderBy
  categoryId: OrderBy
  chatbot: ChatbotOrderBy
  chatbotId: OrderBy
}

"""primary key columns input for table: chatbot_category"""
input ChatbotCategoryPkColumnsInput {
  categoryId: Int!
  chatbotId: Int!
}

"""
select columns of table "chatbot_category"
"""
enum ChatbotCategorySelectColumn {
  """column name"""
  categoryId

  """column name"""
  chatbotId
}

"""
input type for updating data in table "chatbot_category"
"""
input ChatbotCategorySetInput {
  categoryId: Int
  chatbotId: Int
}

"""aggregate stddev on columns"""
type ChatbotCategoryStddevFields {
  categoryId: Float
  chatbotId: Float
}

"""
order by stddev() on columns of table "chatbot_category"
"""
input ChatbotCategoryStddevOrderBy {
  categoryId: OrderBy
  chatbotId: OrderBy
}

"""aggregate stddevPop on columns"""
type ChatbotCategoryStddevPopFields {
  categoryId: Float
  chatbotId: Float
}

"""
order by stddevPop() on columns of table "chatbot_category"
"""
input ChatbotCategoryStddevPopOrderBy {
  categoryId: OrderBy
  chatbotId: OrderBy
}

"""aggregate stddevSamp on columns"""
type ChatbotCategoryStddevSampFields {
  categoryId: Float
  chatbotId: Float
}

"""
order by stddevSamp() on columns of table "chatbot_category"
"""
input ChatbotCategoryStddevSampOrderBy {
  categoryId: OrderBy
  chatbotId: OrderBy
}

"""
Streaming cursor of the table "chatbot_category"
"""
input ChatbotCategoryStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ChatbotCategoryStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ChatbotCategoryStreamCursorValueInput {
  categoryId: Int
  chatbotId: Int
}

"""aggregate sum on columns"""
type ChatbotCategorySumFields {
  categoryId: Int
  chatbotId: Int
}

"""
order by sum() on columns of table "chatbot_category"
"""
input ChatbotCategorySumOrderBy {
  categoryId: OrderBy
  chatbotId: OrderBy
}

"""
update columns of table "chatbot_category"
"""
enum ChatbotCategoryUpdateColumn {
  """column name"""
  categoryId

  """column name"""
  chatbotId
}

input ChatbotCategoryUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: ChatbotCategoryIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: ChatbotCategorySetInput

  """filter the rows which have to be updated"""
  where: ChatbotCategoryBoolExp!
}

"""aggregate varPop on columns"""
type ChatbotCategoryVarPopFields {
  categoryId: Float
  chatbotId: Float
}

"""
order by varPop() on columns of table "chatbot_category"
"""
input ChatbotCategoryVarPopOrderBy {
  categoryId: OrderBy
  chatbotId: OrderBy
}

"""aggregate varSamp on columns"""
type ChatbotCategoryVarSampFields {
  categoryId: Float
  chatbotId: Float
}

"""
order by varSamp() on columns of table "chatbot_category"
"""
input ChatbotCategoryVarSampOrderBy {
  categoryId: OrderBy
  chatbotId: OrderBy
}

"""aggregate variance on columns"""
type ChatbotCategoryVarianceFields {
  categoryId: Float
  chatbotId: Float
}

"""
order by variance() on columns of table "chatbot_category"
"""
input ChatbotCategoryVarianceOrderBy {
  categoryId: OrderBy
  chatbotId: OrderBy
}

"""
unique or primary key constraints on table "chatbot"
"""
enum ChatbotConstraint {
  """
  unique or primary key constraint on columns "name"
  """
  chatbot_name_key

  """
  unique or primary key constraint on columns "chatbot_id"
  """
  chatbot_pkey
}

"""
input type for incrementing numeric columns in table "chatbot"
"""
input ChatbotIncInput {
  chatbotId: Int
}

"""
input type for inserting data into table "chatbot"
"""
input ChatbotInsertInput {
  avatar: String
  categories: ChatbotCategoryArrRelInsertInput
  chatbotId: Int
  chats: ChatArrRelInsertInput
  complexityEnum: ComplexityEnumObjRelInsertInput
  createdBy: String
  defaultComplexity: String
  defaultLength: String
  defaultTone: String
  defaultType: String
  description: String
  lengthEnum: LengthEnumObjRelInsertInput
  metadataLabels: LabelChatbotCategoryArrRelInsertInput
  name: String
  preferences: PreferenceArrRelInsertInput
  prompts: PromptChatbotArrRelInsertInput
  threads: ThreadArrRelInsertInput
  toneEnum: ToneEnumObjRelInsertInput
  typeEnum: TypeEnumObjRelInsertInput
}

"""aggregate max on columns"""
type ChatbotMaxFields {
  avatar: String
  chatbotId: Int
  createdBy: String
  defaultComplexity: String
  defaultLength: String
  defaultTone: String
  defaultType: String
  description: String
  name: String
}

"""
order by max() on columns of table "chatbot"
"""
input ChatbotMaxOrderBy {
  avatar: OrderBy
  chatbotId: OrderBy
  createdBy: OrderBy
  defaultComplexity: OrderBy
  defaultLength: OrderBy
  defaultTone: OrderBy
  defaultType: OrderBy
  description: OrderBy
  name: OrderBy
}

"""aggregate min on columns"""
type ChatbotMinFields {
  avatar: String
  chatbotId: Int
  createdBy: String
  defaultComplexity: String
  defaultLength: String
  defaultTone: String
  defaultType: String
  description: String
  name: String
}

"""
order by min() on columns of table "chatbot"
"""
input ChatbotMinOrderBy {
  avatar: OrderBy
  chatbotId: OrderBy
  createdBy: OrderBy
  defaultComplexity: OrderBy
  defaultLength: OrderBy
  defaultTone: OrderBy
  defaultType: OrderBy
  description: OrderBy
  name: OrderBy
}

"""
response of any mutation on the table "chatbot"
"""
type ChatbotMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Chatbot!]!
}

"""
input type for inserting object relation for remote table "chatbot"
"""
input ChatbotObjRelInsertInput {
  data: ChatbotInsertInput!

  """upsert condition"""
  onConflict: ChatbotOnConflict
}

"""
on_conflict condition type for table "chatbot"
"""
input ChatbotOnConflict {
  constraint: ChatbotConstraint!
  updateColumns: [ChatbotUpdateColumn!]! = []
  where: ChatbotBoolExp
}

"""Ordering options when selecting data from "chatbot"."""
input ChatbotOrderBy {
  avatar: OrderBy
  categoriesAggregate: ChatbotCategoryAggregateOrderBy
  chatbotId: OrderBy
  chatsAggregate: ChatAggregateOrderBy
  complexityEnum: ComplexityEnumOrderBy
  createdBy: OrderBy
  defaultComplexity: OrderBy
  defaultLength: OrderBy
  defaultTone: OrderBy
  defaultType: OrderBy
  description: OrderBy
  lengthEnum: LengthEnumOrderBy
  metadataLabelsAggregate: LabelChatbotCategoryAggregateOrderBy
  name: OrderBy
  preferencesAggregate: PreferenceAggregateOrderBy
  promptsAggregate: PromptChatbotAggregateOrderBy
  threadsAggregate: ThreadAggregateOrderBy
  toneEnum: ToneEnumOrderBy
  typeEnum: TypeEnumOrderBy
}

"""primary key columns input for table: chatbot"""
input ChatbotPkColumnsInput {
  chatbotId: Int!
}

"""
select columns of table "chatbot"
"""
enum ChatbotSelectColumn {
  """column name"""
  avatar

  """column name"""
  chatbotId

  """column name"""
  createdBy

  """column name"""
  defaultComplexity

  """column name"""
  defaultLength

  """column name"""
  defaultTone

  """column name"""
  defaultType

  """column name"""
  description

  """column name"""
  name
}

"""
input type for updating data in table "chatbot"
"""
input ChatbotSetInput {
  avatar: String
  chatbotId: Int
  createdBy: String
  defaultComplexity: String
  defaultLength: String
  defaultTone: String
  defaultType: String
  description: String
  name: String
}

"""aggregate stddev on columns"""
type ChatbotStddevFields {
  chatbotId: Float
}

"""
order by stddev() on columns of table "chatbot"
"""
input ChatbotStddevOrderBy {
  chatbotId: OrderBy
}

"""aggregate stddevPop on columns"""
type ChatbotStddevPopFields {
  chatbotId: Float
}

"""
order by stddevPop() on columns of table "chatbot"
"""
input ChatbotStddevPopOrderBy {
  chatbotId: OrderBy
}

"""aggregate stddevSamp on columns"""
type ChatbotStddevSampFields {
  chatbotId: Float
}

"""
order by stddevSamp() on columns of table "chatbot"
"""
input ChatbotStddevSampOrderBy {
  chatbotId: OrderBy
}

"""
Streaming cursor of the table "chatbot"
"""
input ChatbotStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ChatbotStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ChatbotStreamCursorValueInput {
  avatar: String
  chatbotId: Int
  createdBy: String
  defaultComplexity: String
  defaultLength: String
  defaultTone: String
  defaultType: String
  description: String
  name: String
}

"""aggregate sum on columns"""
type ChatbotSumFields {
  chatbotId: Int
}

"""
order by sum() on columns of table "chatbot"
"""
input ChatbotSumOrderBy {
  chatbotId: OrderBy
}

"""
update columns of table "chatbot"
"""
enum ChatbotUpdateColumn {
  """column name"""
  avatar

  """column name"""
  chatbotId

  """column name"""
  createdBy

  """column name"""
  defaultComplexity

  """column name"""
  defaultLength

  """column name"""
  defaultTone

  """column name"""
  defaultType

  """column name"""
  description

  """column name"""
  name
}

input ChatbotUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: ChatbotIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: ChatbotSetInput

  """filter the rows which have to be updated"""
  where: ChatbotBoolExp!
}

"""aggregate varPop on columns"""
type ChatbotVarPopFields {
  chatbotId: Float
}

"""
order by varPop() on columns of table "chatbot"
"""
input ChatbotVarPopOrderBy {
  chatbotId: OrderBy
}

"""aggregate varSamp on columns"""
type ChatbotVarSampFields {
  chatbotId: Float
}

"""
order by varSamp() on columns of table "chatbot"
"""
input ChatbotVarSampOrderBy {
  chatbotId: OrderBy
}

"""aggregate variance on columns"""
type ChatbotVarianceFields {
  chatbotId: Float
}

"""
order by variance() on columns of table "chatbot"
"""
input ChatbotVarianceOrderBy {
  chatbotId: OrderBy
}

"""
columns and relationships of "complexity_enum"
"""
type ComplexityEnum {
  """An array relationship"""
  chatbots(
    """distinct select on columns"""
    distinctOn: [ChatbotSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotOrderBy!]

    """filter the rows returned"""
    where: ChatbotBoolExp
  ): [Chatbot!]!

  """An aggregate relationship"""
  chatbotsAggregate(
    """distinct select on columns"""
    distinctOn: [ChatbotSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotOrderBy!]

    """filter the rows returned"""
    where: ChatbotBoolExp
  ): ChatbotAggregate!

  """An array relationship"""
  preferences(
    """distinct select on columns"""
    distinctOn: [PreferenceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PreferenceOrderBy!]

    """filter the rows returned"""
    where: PreferenceBoolExp
  ): [Preference!]!

  """An aggregate relationship"""
  preferencesAggregate(
    """distinct select on columns"""
    distinctOn: [PreferenceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PreferenceOrderBy!]

    """filter the rows returned"""
    where: PreferenceBoolExp
  ): PreferenceAggregate!
  value: String!
}

"""
aggregated selection of "complexity_enum"
"""
type ComplexityEnumAggregate {
  aggregate: ComplexityEnumAggregateFields
  nodes: [ComplexityEnum!]!
}

"""
aggregate fields of "complexity_enum"
"""
type ComplexityEnumAggregateFields {
  count(columns: [ComplexityEnumSelectColumn!], distinct: Boolean): Int!
  max: ComplexityEnumMaxFields
  min: ComplexityEnumMinFields
}

"""
Boolean expression to filter rows from the table "complexity_enum". All fields are combined with a logical 'AND'.
"""
input ComplexityEnumBoolExp {
  _and: [ComplexityEnumBoolExp!]
  _not: ComplexityEnumBoolExp
  _or: [ComplexityEnumBoolExp!]
  chatbots: ChatbotBoolExp
  chatbotsAggregate: ChatbotAggregateBoolExp
  preferences: PreferenceBoolExp
  preferencesAggregate: PreferenceAggregateBoolExp
  value: StringComparisonExp
}

"""
unique or primary key constraints on table "complexity_enum"
"""
enum ComplexityEnumConstraint {
  """
  unique or primary key constraint on columns "value"
  """
  default_complexity_enum_pkey
}

"""
input type for inserting data into table "complexity_enum"
"""
input ComplexityEnumInsertInput {
  chatbots: ChatbotArrRelInsertInput
  preferences: PreferenceArrRelInsertInput
  value: String
}

"""aggregate max on columns"""
type ComplexityEnumMaxFields {
  value: String
}

"""aggregate min on columns"""
type ComplexityEnumMinFields {
  value: String
}

"""
response of any mutation on the table "complexity_enum"
"""
type ComplexityEnumMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [ComplexityEnum!]!
}

"""
input type for inserting object relation for remote table "complexity_enum"
"""
input ComplexityEnumObjRelInsertInput {
  data: ComplexityEnumInsertInput!

  """upsert condition"""
  onConflict: ComplexityEnumOnConflict
}

"""
on_conflict condition type for table "complexity_enum"
"""
input ComplexityEnumOnConflict {
  constraint: ComplexityEnumConstraint!
  updateColumns: [ComplexityEnumUpdateColumn!]! = []
  where: ComplexityEnumBoolExp
}

"""Ordering options when selecting data from "complexity_enum"."""
input ComplexityEnumOrderBy {
  chatbotsAggregate: ChatbotAggregateOrderBy
  preferencesAggregate: PreferenceAggregateOrderBy
  value: OrderBy
}

"""primary key columns input for table: complexity_enum"""
input ComplexityEnumPkColumnsInput {
  value: String!
}

"""
select columns of table "complexity_enum"
"""
enum ComplexityEnumSelectColumn {
  """column name"""
  value
}

"""
input type for updating data in table "complexity_enum"
"""
input ComplexityEnumSetInput {
  value: String
}

"""
Streaming cursor of the table "complexity_enum"
"""
input ComplexityEnumStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ComplexityEnumStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ComplexityEnumStreamCursorValueInput {
  value: String
}

"""
update columns of table "complexity_enum"
"""
enum ComplexityEnumUpdateColumn {
  """column name"""
  value
}

input ComplexityEnumUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: ComplexityEnumSetInput

  """filter the rows which have to be updated"""
  where: ComplexityEnumBoolExp!
}

"""ordering argument of a cursor"""
enum CursorOrdering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input IntComparisonExp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _isNull: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""Labels for chatbots (e.g.: domain, category, sub-category, tags """
type Label {
  advancedLabels: Boolean!
  categories: String!
  labelId: Int!

  """An array relationship"""
  metadataLabels(
    """distinct select on columns"""
    distinctOn: [LabelChatbotCategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [LabelChatbotCategoryOrderBy!]

    """filter the rows returned"""
    where: LabelChatbotCategoryBoolExp
  ): [LabelChatbotCategory!]!

  """An aggregate relationship"""
  metadataLabelsAggregate(
    """distinct select on columns"""
    distinctOn: [LabelChatbotCategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [LabelChatbotCategoryOrderBy!]

    """filter the rows returned"""
    where: LabelChatbotCategoryBoolExp
  ): LabelChatbotCategoryAggregate!
  questions: String!
  subCategories: String!
  tags: String!
}

"""
aggregated selection of "label"
"""
type LabelAggregate {
  aggregate: LabelAggregateFields
  nodes: [Label!]!
}

"""
aggregate fields of "label"
"""
type LabelAggregateFields {
  avg: LabelAvgFields
  count(columns: [LabelSelectColumn!], distinct: Boolean): Int!
  max: LabelMaxFields
  min: LabelMinFields
  stddev: LabelStddevFields
  stddevPop: LabelStddevPopFields
  stddevSamp: LabelStddevSampFields
  sum: LabelSumFields
  varPop: LabelVarPopFields
  varSamp: LabelVarSampFields
  variance: LabelVarianceFields
}

"""aggregate avg on columns"""
type LabelAvgFields {
  labelId: Float
}

"""
Boolean expression to filter rows from the table "label". All fields are combined with a logical 'AND'.
"""
input LabelBoolExp {
  _and: [LabelBoolExp!]
  _not: LabelBoolExp
  _or: [LabelBoolExp!]
  advancedLabels: BooleanComparisonExp
  categories: StringComparisonExp
  labelId: IntComparisonExp
  metadataLabels: LabelChatbotCategoryBoolExp
  metadataLabelsAggregate: LabelChatbotCategoryAggregateBoolExp
  questions: StringComparisonExp
  subCategories: StringComparisonExp
  tags: StringComparisonExp
}

"""
Junction table to connect between Label, Chatbot and Categories tables.
"""
type LabelChatbotCategory {
  """An object relationship"""
  category: Category!
  categoryId: Int!

  """An object relationship"""
  chatbot: Chatbot!
  chatbotId: Int!

  """An object relationship"""
  label: Label!
  labelId: Int!
}

"""
aggregated selection of "label_chatbot_category"
"""
type LabelChatbotCategoryAggregate {
  aggregate: LabelChatbotCategoryAggregateFields
  nodes: [LabelChatbotCategory!]!
}

input LabelChatbotCategoryAggregateBoolExp {
  count: labelChatbotCategoryAggregateBoolExpCount
}

"""
aggregate fields of "label_chatbot_category"
"""
type LabelChatbotCategoryAggregateFields {
  avg: LabelChatbotCategoryAvgFields
  count(columns: [LabelChatbotCategorySelectColumn!], distinct: Boolean): Int!
  max: LabelChatbotCategoryMaxFields
  min: LabelChatbotCategoryMinFields
  stddev: LabelChatbotCategoryStddevFields
  stddevPop: LabelChatbotCategoryStddevPopFields
  stddevSamp: LabelChatbotCategoryStddevSampFields
  sum: LabelChatbotCategorySumFields
  varPop: LabelChatbotCategoryVarPopFields
  varSamp: LabelChatbotCategoryVarSampFields
  variance: LabelChatbotCategoryVarianceFields
}

"""
order by aggregate values of table "label_chatbot_category"
"""
input LabelChatbotCategoryAggregateOrderBy {
  avg: LabelChatbotCategoryAvgOrderBy
  count: OrderBy
  max: LabelChatbotCategoryMaxOrderBy
  min: LabelChatbotCategoryMinOrderBy
  stddev: LabelChatbotCategoryStddevOrderBy
  stddevPop: LabelChatbotCategoryStddevPopOrderBy
  stddevSamp: LabelChatbotCategoryStddevSampOrderBy
  sum: LabelChatbotCategorySumOrderBy
  varPop: LabelChatbotCategoryVarPopOrderBy
  varSamp: LabelChatbotCategoryVarSampOrderBy
  variance: LabelChatbotCategoryVarianceOrderBy
}

"""
input type for inserting array relation for remote table "label_chatbot_category"
"""
input LabelChatbotCategoryArrRelInsertInput {
  data: [LabelChatbotCategoryInsertInput!]!

  """upsert condition"""
  onConflict: LabelChatbotCategoryOnConflict
}

"""aggregate avg on columns"""
type LabelChatbotCategoryAvgFields {
  categoryId: Float
  chatbotId: Float
  labelId: Float
}

"""
order by avg() on columns of table "label_chatbot_category"
"""
input LabelChatbotCategoryAvgOrderBy {
  categoryId: OrderBy
  chatbotId: OrderBy
  labelId: OrderBy
}

"""
Boolean expression to filter rows from the table "label_chatbot_category". All fields are combined with a logical 'AND'.
"""
input LabelChatbotCategoryBoolExp {
  _and: [LabelChatbotCategoryBoolExp!]
  _not: LabelChatbotCategoryBoolExp
  _or: [LabelChatbotCategoryBoolExp!]
  category: CategoryBoolExp
  categoryId: IntComparisonExp
  chatbot: ChatbotBoolExp
  chatbotId: IntComparisonExp
  label: LabelBoolExp
  labelId: IntComparisonExp
}

"""
unique or primary key constraints on table "label_chatbot_category"
"""
enum LabelChatbotCategoryConstraint {
  """
  unique or primary key constraint on columns "label_id", "category_id", "chatbot_id"
  """
  label_chatbot_category_pkey
}

"""
input type for incrementing numeric columns in table "label_chatbot_category"
"""
input LabelChatbotCategoryIncInput {
  categoryId: Int
  chatbotId: Int
  labelId: Int
}

"""
input type for inserting data into table "label_chatbot_category"
"""
input LabelChatbotCategoryInsertInput {
  category: CategoryObjRelInsertInput
  categoryId: Int
  chatbot: ChatbotObjRelInsertInput
  chatbotId: Int
  label: LabelObjRelInsertInput
  labelId: Int
}

"""aggregate max on columns"""
type LabelChatbotCategoryMaxFields {
  categoryId: Int
  chatbotId: Int
  labelId: Int
}

"""
order by max() on columns of table "label_chatbot_category"
"""
input LabelChatbotCategoryMaxOrderBy {
  categoryId: OrderBy
  chatbotId: OrderBy
  labelId: OrderBy
}

"""aggregate min on columns"""
type LabelChatbotCategoryMinFields {
  categoryId: Int
  chatbotId: Int
  labelId: Int
}

"""
order by min() on columns of table "label_chatbot_category"
"""
input LabelChatbotCategoryMinOrderBy {
  categoryId: OrderBy
  chatbotId: OrderBy
  labelId: OrderBy
}

"""
response of any mutation on the table "label_chatbot_category"
"""
type LabelChatbotCategoryMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [LabelChatbotCategory!]!
}

"""
on_conflict condition type for table "label_chatbot_category"
"""
input LabelChatbotCategoryOnConflict {
  constraint: LabelChatbotCategoryConstraint!
  updateColumns: [LabelChatbotCategoryUpdateColumn!]! = []
  where: LabelChatbotCategoryBoolExp
}

"""Ordering options when selecting data from "label_chatbot_category"."""
input LabelChatbotCategoryOrderBy {
  category: CategoryOrderBy
  categoryId: OrderBy
  chatbot: ChatbotOrderBy
  chatbotId: OrderBy
  label: LabelOrderBy
  labelId: OrderBy
}

"""primary key columns input for table: label_chatbot_category"""
input LabelChatbotCategoryPkColumnsInput {
  categoryId: Int!
  chatbotId: Int!
  labelId: Int!
}

"""
select columns of table "label_chatbot_category"
"""
enum LabelChatbotCategorySelectColumn {
  """column name"""
  categoryId

  """column name"""
  chatbotId

  """column name"""
  labelId
}

"""
input type for updating data in table "label_chatbot_category"
"""
input LabelChatbotCategorySetInput {
  categoryId: Int
  chatbotId: Int
  labelId: Int
}

"""aggregate stddev on columns"""
type LabelChatbotCategoryStddevFields {
  categoryId: Float
  chatbotId: Float
  labelId: Float
}

"""
order by stddev() on columns of table "label_chatbot_category"
"""
input LabelChatbotCategoryStddevOrderBy {
  categoryId: OrderBy
  chatbotId: OrderBy
  labelId: OrderBy
}

"""aggregate stddevPop on columns"""
type LabelChatbotCategoryStddevPopFields {
  categoryId: Float
  chatbotId: Float
  labelId: Float
}

"""
order by stddevPop() on columns of table "label_chatbot_category"
"""
input LabelChatbotCategoryStddevPopOrderBy {
  categoryId: OrderBy
  chatbotId: OrderBy
  labelId: OrderBy
}

"""aggregate stddevSamp on columns"""
type LabelChatbotCategoryStddevSampFields {
  categoryId: Float
  chatbotId: Float
  labelId: Float
}

"""
order by stddevSamp() on columns of table "label_chatbot_category"
"""
input LabelChatbotCategoryStddevSampOrderBy {
  categoryId: OrderBy
  chatbotId: OrderBy
  labelId: OrderBy
}

"""
Streaming cursor of the table "label_chatbot_category"
"""
input LabelChatbotCategoryStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: LabelChatbotCategoryStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input LabelChatbotCategoryStreamCursorValueInput {
  categoryId: Int
  chatbotId: Int
  labelId: Int
}

"""aggregate sum on columns"""
type LabelChatbotCategorySumFields {
  categoryId: Int
  chatbotId: Int
  labelId: Int
}

"""
order by sum() on columns of table "label_chatbot_category"
"""
input LabelChatbotCategorySumOrderBy {
  categoryId: OrderBy
  chatbotId: OrderBy
  labelId: OrderBy
}

"""
update columns of table "label_chatbot_category"
"""
enum LabelChatbotCategoryUpdateColumn {
  """column name"""
  categoryId

  """column name"""
  chatbotId

  """column name"""
  labelId
}

input LabelChatbotCategoryUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: LabelChatbotCategoryIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: LabelChatbotCategorySetInput

  """filter the rows which have to be updated"""
  where: LabelChatbotCategoryBoolExp!
}

"""aggregate varPop on columns"""
type LabelChatbotCategoryVarPopFields {
  categoryId: Float
  chatbotId: Float
  labelId: Float
}

"""
order by varPop() on columns of table "label_chatbot_category"
"""
input LabelChatbotCategoryVarPopOrderBy {
  categoryId: OrderBy
  chatbotId: OrderBy
  labelId: OrderBy
}

"""aggregate varSamp on columns"""
type LabelChatbotCategoryVarSampFields {
  categoryId: Float
  chatbotId: Float
  labelId: Float
}

"""
order by varSamp() on columns of table "label_chatbot_category"
"""
input LabelChatbotCategoryVarSampOrderBy {
  categoryId: OrderBy
  chatbotId: OrderBy
  labelId: OrderBy
}

"""aggregate variance on columns"""
type LabelChatbotCategoryVarianceFields {
  categoryId: Float
  chatbotId: Float
  labelId: Float
}

"""
order by variance() on columns of table "label_chatbot_category"
"""
input LabelChatbotCategoryVarianceOrderBy {
  categoryId: OrderBy
  chatbotId: OrderBy
  labelId: OrderBy
}

"""
unique or primary key constraints on table "label"
"""
enum LabelConstraint {
  """
  unique or primary key constraint on columns "label_id"
  """
  label_label_id_key

  """
  unique or primary key constraint on columns "label_id"
  """
  label_pkey
}

"""
input type for incrementing numeric columns in table "label"
"""
input LabelIncInput {
  labelId: Int
}

"""
input type for inserting data into table "label"
"""
input LabelInsertInput {
  advancedLabels: Boolean
  categories: String
  labelId: Int
  metadataLabels: LabelChatbotCategoryArrRelInsertInput
  questions: String
  subCategories: String
  tags: String
}

"""aggregate max on columns"""
type LabelMaxFields {
  categories: String
  labelId: Int
  questions: String
  subCategories: String
  tags: String
}

"""aggregate min on columns"""
type LabelMinFields {
  categories: String
  labelId: Int
  questions: String
  subCategories: String
  tags: String
}

"""
response of any mutation on the table "label"
"""
type LabelMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Label!]!
}

"""
input type for inserting object relation for remote table "label"
"""
input LabelObjRelInsertInput {
  data: LabelInsertInput!

  """upsert condition"""
  onConflict: LabelOnConflict
}

"""
on_conflict condition type for table "label"
"""
input LabelOnConflict {
  constraint: LabelConstraint!
  updateColumns: [LabelUpdateColumn!]! = []
  where: LabelBoolExp
}

"""Ordering options when selecting data from "label"."""
input LabelOrderBy {
  advancedLabels: OrderBy
  categories: OrderBy
  labelId: OrderBy
  metadataLabelsAggregate: LabelChatbotCategoryAggregateOrderBy
  questions: OrderBy
  subCategories: OrderBy
  tags: OrderBy
}

"""primary key columns input for table: label"""
input LabelPkColumnsInput {
  labelId: Int!
}

"""
select columns of table "label"
"""
enum LabelSelectColumn {
  """column name"""
  advancedLabels

  """column name"""
  categories

  """column name"""
  labelId

  """column name"""
  questions

  """column name"""
  subCategories

  """column name"""
  tags
}

"""
input type for updating data in table "label"
"""
input LabelSetInput {
  advancedLabels: Boolean
  categories: String
  labelId: Int
  questions: String
  subCategories: String
  tags: String
}

"""aggregate stddev on columns"""
type LabelStddevFields {
  labelId: Float
}

"""aggregate stddevPop on columns"""
type LabelStddevPopFields {
  labelId: Float
}

"""aggregate stddevSamp on columns"""
type LabelStddevSampFields {
  labelId: Float
}

"""
Streaming cursor of the table "label"
"""
input LabelStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: LabelStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input LabelStreamCursorValueInput {
  advancedLabels: Boolean
  categories: String
  labelId: Int
  questions: String
  subCategories: String
  tags: String
}

"""aggregate sum on columns"""
type LabelSumFields {
  labelId: Int
}

"""
update columns of table "label"
"""
enum LabelUpdateColumn {
  """column name"""
  advancedLabels

  """column name"""
  categories

  """column name"""
  labelId

  """column name"""
  questions

  """column name"""
  subCategories

  """column name"""
  tags
}

input LabelUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: LabelIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: LabelSetInput

  """filter the rows which have to be updated"""
  where: LabelBoolExp!
}

"""aggregate varPop on columns"""
type LabelVarPopFields {
  labelId: Float
}

"""aggregate varSamp on columns"""
type LabelVarSampFields {
  labelId: Float
}

"""aggregate variance on columns"""
type LabelVarianceFields {
  labelId: Float
}

"""
columns and relationships of "length_enum"
"""
type LengthEnum {
  """An array relationship"""
  chatbots(
    """distinct select on columns"""
    distinctOn: [ChatbotSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotOrderBy!]

    """filter the rows returned"""
    where: ChatbotBoolExp
  ): [Chatbot!]!

  """An aggregate relationship"""
  chatbotsAggregate(
    """distinct select on columns"""
    distinctOn: [ChatbotSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotOrderBy!]

    """filter the rows returned"""
    where: ChatbotBoolExp
  ): ChatbotAggregate!

  """An array relationship"""
  preferences(
    """distinct select on columns"""
    distinctOn: [PreferenceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PreferenceOrderBy!]

    """filter the rows returned"""
    where: PreferenceBoolExp
  ): [Preference!]!

  """An aggregate relationship"""
  preferencesAggregate(
    """distinct select on columns"""
    distinctOn: [PreferenceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PreferenceOrderBy!]

    """filter the rows returned"""
    where: PreferenceBoolExp
  ): PreferenceAggregate!
  value: String!
}

"""
aggregated selection of "length_enum"
"""
type LengthEnumAggregate {
  aggregate: LengthEnumAggregateFields
  nodes: [LengthEnum!]!
}

"""
aggregate fields of "length_enum"
"""
type LengthEnumAggregateFields {
  count(columns: [LengthEnumSelectColumn!], distinct: Boolean): Int!
  max: LengthEnumMaxFields
  min: LengthEnumMinFields
}

"""
Boolean expression to filter rows from the table "length_enum". All fields are combined with a logical 'AND'.
"""
input LengthEnumBoolExp {
  _and: [LengthEnumBoolExp!]
  _not: LengthEnumBoolExp
  _or: [LengthEnumBoolExp!]
  chatbots: ChatbotBoolExp
  chatbotsAggregate: ChatbotAggregateBoolExp
  preferences: PreferenceBoolExp
  preferencesAggregate: PreferenceAggregateBoolExp
  value: StringComparisonExp
}

"""
unique or primary key constraints on table "length_enum"
"""
enum LengthEnumConstraint {
  """
  unique or primary key constraint on columns "value"
  """
  default_length_enum_pkey
}

"""
input type for inserting data into table "length_enum"
"""
input LengthEnumInsertInput {
  chatbots: ChatbotArrRelInsertInput
  preferences: PreferenceArrRelInsertInput
  value: String
}

"""aggregate max on columns"""
type LengthEnumMaxFields {
  value: String
}

"""aggregate min on columns"""
type LengthEnumMinFields {
  value: String
}

"""
response of any mutation on the table "length_enum"
"""
type LengthEnumMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [LengthEnum!]!
}

"""
input type for inserting object relation for remote table "length_enum"
"""
input LengthEnumObjRelInsertInput {
  data: LengthEnumInsertInput!

  """upsert condition"""
  onConflict: LengthEnumOnConflict
}

"""
on_conflict condition type for table "length_enum"
"""
input LengthEnumOnConflict {
  constraint: LengthEnumConstraint!
  updateColumns: [LengthEnumUpdateColumn!]! = []
  where: LengthEnumBoolExp
}

"""Ordering options when selecting data from "length_enum"."""
input LengthEnumOrderBy {
  chatbotsAggregate: ChatbotAggregateOrderBy
  preferencesAggregate: PreferenceAggregateOrderBy
  value: OrderBy
}

"""primary key columns input for table: length_enum"""
input LengthEnumPkColumnsInput {
  value: String!
}

"""
select columns of table "length_enum"
"""
enum LengthEnumSelectColumn {
  """column name"""
  value
}

"""
input type for updating data in table "length_enum"
"""
input LengthEnumSetInput {
  value: String
}

"""
Streaming cursor of the table "length_enum"
"""
input LengthEnumStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: LengthEnumStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input LengthEnumStreamCursorValueInput {
  value: String
}

"""
update columns of table "length_enum"
"""
enum LengthEnumUpdateColumn {
  """column name"""
  value
}

input LengthEnumUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: LengthEnumSetInput

  """filter the rows which have to be updated"""
  where: LengthEnumBoolExp!
}

"""This table stores the messages exchanged between users and chatbots."""
type Message {
  content: String!
  createdAt: timestamptz!
  messageId: uuid!

  """An object relationship"""
  messageTypeEnum: MessageTypeEnum!
  role: String!

  """An object relationship"""
  thread: Thread
  threadId: uuid
}

"""
aggregated selection of "message"
"""
type MessageAggregate {
  aggregate: MessageAggregateFields
  nodes: [Message!]!
}

input MessageAggregateBoolExp {
  count: messageAggregateBoolExpCount
}

"""
aggregate fields of "message"
"""
type MessageAggregateFields {
  count(columns: [MessageSelectColumn!], distinct: Boolean): Int!
  max: MessageMaxFields
  min: MessageMinFields
}

"""
order by aggregate values of table "message"
"""
input MessageAggregateOrderBy {
  count: OrderBy
  max: MessageMaxOrderBy
  min: MessageMinOrderBy
}

"""
input type for inserting array relation for remote table "message"
"""
input MessageArrRelInsertInput {
  data: [MessageInsertInput!]!

  """upsert condition"""
  onConflict: MessageOnConflict
}

"""
Boolean expression to filter rows from the table "message". All fields are combined with a logical 'AND'.
"""
input MessageBoolExp {
  _and: [MessageBoolExp!]
  _not: MessageBoolExp
  _or: [MessageBoolExp!]
  content: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  messageId: UuidComparisonExp
  messageTypeEnum: MessageTypeEnumBoolExp
  role: StringComparisonExp
  thread: ThreadBoolExp
  threadId: UuidComparisonExp
}

"""
unique or primary key constraints on table "message"
"""
enum MessageConstraint {
  """
  unique or primary key constraint on columns "message_id"
  """
  message_id_key

  """
  unique or primary key constraint on columns "message_id"
  """
  message_pkey
}

"""
input type for inserting data into table "message"
"""
input MessageInsertInput {
  content: String
  createdAt: timestamptz
  messageId: uuid
  messageTypeEnum: MessageTypeEnumObjRelInsertInput
  role: String
  thread: ThreadObjRelInsertInput
  threadId: uuid
}

"""aggregate max on columns"""
type MessageMaxFields {
  content: String
  createdAt: timestamptz
  messageId: uuid
  role: String
  threadId: uuid
}

"""
order by max() on columns of table "message"
"""
input MessageMaxOrderBy {
  content: OrderBy
  createdAt: OrderBy
  messageId: OrderBy
  role: OrderBy
  threadId: OrderBy
}

"""aggregate min on columns"""
type MessageMinFields {
  content: String
  createdAt: timestamptz
  messageId: uuid
  role: String
  threadId: uuid
}

"""
order by min() on columns of table "message"
"""
input MessageMinOrderBy {
  content: OrderBy
  createdAt: OrderBy
  messageId: OrderBy
  role: OrderBy
  threadId: OrderBy
}

"""
response of any mutation on the table "message"
"""
type MessageMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Message!]!
}

"""
on_conflict condition type for table "message"
"""
input MessageOnConflict {
  constraint: MessageConstraint!
  updateColumns: [MessageUpdateColumn!]! = []
  where: MessageBoolExp
}

"""Ordering options when selecting data from "message"."""
input MessageOrderBy {
  content: OrderBy
  createdAt: OrderBy
  messageId: OrderBy
  messageTypeEnum: MessageTypeEnumOrderBy
  role: OrderBy
  thread: ThreadOrderBy
  threadId: OrderBy
}

"""primary key columns input for table: message"""
input MessagePkColumnsInput {
  messageId: uuid!
}

"""
select columns of table "message"
"""
enum MessageSelectColumn {
  """column name"""
  content

  """column name"""
  createdAt

  """column name"""
  messageId

  """column name"""
  role

  """column name"""
  threadId
}

"""
input type for updating data in table "message"
"""
input MessageSetInput {
  content: String
  createdAt: timestamptz
  messageId: uuid
  role: String
  threadId: uuid
}

"""
Streaming cursor of the table "message"
"""
input MessageStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: MessageStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input MessageStreamCursorValueInput {
  content: String
  createdAt: timestamptz
  messageId: uuid
  role: String
  threadId: uuid
}

"""
columns and relationships of "message_type_enum"
"""
type MessageTypeEnum {
  """An array relationship"""
  messages(
    """distinct select on columns"""
    distinctOn: [MessageSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MessageOrderBy!]

    """filter the rows returned"""
    where: MessageBoolExp
  ): [Message!]!

  """An aggregate relationship"""
  messagesAggregate(
    """distinct select on columns"""
    distinctOn: [MessageSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MessageOrderBy!]

    """filter the rows returned"""
    where: MessageBoolExp
  ): MessageAggregate!
  value: String!
}

"""
aggregated selection of "message_type_enum"
"""
type MessageTypeEnumAggregate {
  aggregate: MessageTypeEnumAggregateFields
  nodes: [MessageTypeEnum!]!
}

"""
aggregate fields of "message_type_enum"
"""
type MessageTypeEnumAggregateFields {
  count(columns: [MessageTypeEnumSelectColumn!], distinct: Boolean): Int!
  max: MessageTypeEnumMaxFields
  min: MessageTypeEnumMinFields
}

"""
Boolean expression to filter rows from the table "message_type_enum". All fields are combined with a logical 'AND'.
"""
input MessageTypeEnumBoolExp {
  _and: [MessageTypeEnumBoolExp!]
  _not: MessageTypeEnumBoolExp
  _or: [MessageTypeEnumBoolExp!]
  messages: MessageBoolExp
  messagesAggregate: MessageAggregateBoolExp
  value: StringComparisonExp
}

"""
unique or primary key constraints on table "message_type_enum"
"""
enum MessageTypeEnumConstraint {
  """
  unique or primary key constraint on columns "value"
  """
  message_type_enum_pkey
}

"""
input type for inserting data into table "message_type_enum"
"""
input MessageTypeEnumInsertInput {
  messages: MessageArrRelInsertInput
  value: String
}

"""aggregate max on columns"""
type MessageTypeEnumMaxFields {
  value: String
}

"""aggregate min on columns"""
type MessageTypeEnumMinFields {
  value: String
}

"""
response of any mutation on the table "message_type_enum"
"""
type MessageTypeEnumMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [MessageTypeEnum!]!
}

"""
input type for inserting object relation for remote table "message_type_enum"
"""
input MessageTypeEnumObjRelInsertInput {
  data: MessageTypeEnumInsertInput!

  """upsert condition"""
  onConflict: MessageTypeEnumOnConflict
}

"""
on_conflict condition type for table "message_type_enum"
"""
input MessageTypeEnumOnConflict {
  constraint: MessageTypeEnumConstraint!
  updateColumns: [MessageTypeEnumUpdateColumn!]! = []
  where: MessageTypeEnumBoolExp
}

"""Ordering options when selecting data from "message_type_enum"."""
input MessageTypeEnumOrderBy {
  messagesAggregate: MessageAggregateOrderBy
  value: OrderBy
}

"""primary key columns input for table: message_type_enum"""
input MessageTypeEnumPkColumnsInput {
  value: String!
}

"""
select columns of table "message_type_enum"
"""
enum MessageTypeEnumSelectColumn {
  """column name"""
  value
}

"""
input type for updating data in table "message_type_enum"
"""
input MessageTypeEnumSetInput {
  value: String
}

"""
Streaming cursor of the table "message_type_enum"
"""
input MessageTypeEnumStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: MessageTypeEnumStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input MessageTypeEnumStreamCursorValueInput {
  value: String
}

"""
update columns of table "message_type_enum"
"""
enum MessageTypeEnumUpdateColumn {
  """column name"""
  value
}

input MessageTypeEnumUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: MessageTypeEnumSetInput

  """filter the rows which have to be updated"""
  where: MessageTypeEnumBoolExp!
}

"""
update columns of table "message"
"""
enum MessageUpdateColumn {
  """column name"""
  content

  """column name"""
  createdAt

  """column name"""
  messageId

  """column name"""
  role

  """column name"""
  threadId
}

input MessageUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: MessageSetInput

  """filter the rows which have to be updated"""
  where: MessageBoolExp!
}

"""
columns and relationships of "models_enum"
"""
type ModelsEnum {
  name: String!

  """An array relationship"""
  threads(
    """distinct select on columns"""
    distinctOn: [ThreadSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ThreadOrderBy!]

    """filter the rows returned"""
    where: ThreadBoolExp
  ): [Thread!]!

  """An aggregate relationship"""
  threadsAggregate(
    """distinct select on columns"""
    distinctOn: [ThreadSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ThreadOrderBy!]

    """filter the rows returned"""
    where: ThreadBoolExp
  ): ThreadAggregate!
  value: String!
}

"""
aggregated selection of "models_enum"
"""
type ModelsEnumAggregate {
  aggregate: ModelsEnumAggregateFields
  nodes: [ModelsEnum!]!
}

"""
aggregate fields of "models_enum"
"""
type ModelsEnumAggregateFields {
  count(columns: [ModelsEnumSelectColumn!], distinct: Boolean): Int!
  max: ModelsEnumMaxFields
  min: ModelsEnumMinFields
}

"""
Boolean expression to filter rows from the table "models_enum". All fields are combined with a logical 'AND'.
"""
input ModelsEnumBoolExp {
  _and: [ModelsEnumBoolExp!]
  _not: ModelsEnumBoolExp
  _or: [ModelsEnumBoolExp!]
  name: StringComparisonExp
  threads: ThreadBoolExp
  threadsAggregate: ThreadAggregateBoolExp
  value: StringComparisonExp
}

"""
unique or primary key constraints on table "models_enum"
"""
enum ModelsEnumConstraint {
  """
  unique or primary key constraint on columns "name"
  """
  models_enum_pkey

  """
  unique or primary key constraint on columns "value"
  """
  models_enum_value_key
}

enum ModelsEnumEnum {
  """claude3_haiku"""
  ANTHROPIC

  """gpt-4o-mini"""
  OPENAI

  """llama3_7B"""
  PERPLEXITY

  """wordware"""
  WORDWARE
}

"""
Boolean expression to compare columns of type "ModelsEnumEnum". All fields are combined with logical 'AND'.
"""
input ModelsEnumEnumComparisonExp {
  _eq: ModelsEnumEnum
  _in: [ModelsEnumEnum!]
  _isNull: Boolean
  _neq: ModelsEnumEnum
  _nin: [ModelsEnumEnum!]
}

"""
input type for inserting data into table "models_enum"
"""
input ModelsEnumInsertInput {
  name: String
  threads: ThreadArrRelInsertInput
  value: String
}

"""aggregate max on columns"""
type ModelsEnumMaxFields {
  name: String
  value: String
}

"""aggregate min on columns"""
type ModelsEnumMinFields {
  name: String
  value: String
}

"""
response of any mutation on the table "models_enum"
"""
type ModelsEnumMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [ModelsEnum!]!
}

"""
input type for inserting object relation for remote table "models_enum"
"""
input ModelsEnumObjRelInsertInput {
  data: ModelsEnumInsertInput!

  """upsert condition"""
  onConflict: ModelsEnumOnConflict
}

"""
on_conflict condition type for table "models_enum"
"""
input ModelsEnumOnConflict {
  constraint: ModelsEnumConstraint!
  updateColumns: [ModelsEnumUpdateColumn!]! = []
  where: ModelsEnumBoolExp
}

"""Ordering options when selecting data from "models_enum"."""
input ModelsEnumOrderBy {
  name: OrderBy
  threadsAggregate: ThreadAggregateOrderBy
  value: OrderBy
}

"""primary key columns input for table: models_enum"""
input ModelsEnumPkColumnsInput {
  name: String!
}

"""
select columns of table "models_enum"
"""
enum ModelsEnumSelectColumn {
  """column name"""
  name

  """column name"""
  value
}

"""
input type for updating data in table "models_enum"
"""
input ModelsEnumSetInput {
  name: String
  value: String
}

"""
Streaming cursor of the table "models_enum"
"""
input ModelsEnumStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ModelsEnumStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ModelsEnumStreamCursorValueInput {
  name: String
  value: String
}

"""
update columns of table "models_enum"
"""
enum ModelsEnumUpdateColumn {
  """column name"""
  name

  """column name"""
  value
}

input ModelsEnumUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: ModelsEnumSetInput

  """filter the rows which have to be updated"""
  where: ModelsEnumBoolExp!
}

"""column ordering options"""
enum OrderBy {
  """in ascending order, nulls last"""
  ASC

  """in ascending order, nulls first"""
  ASC_NULLS_FIRST

  """in ascending order, nulls last"""
  ASC_NULLS_LAST

  """in descending order, nulls first"""
  DESC

  """in descending order, nulls first"""
  DESC_NULLS_FIRST

  """in descending order, nulls last"""
  DESC_NULLS_LAST
}

"""
This table stores user-specific preferences for quick access when they interact with a chatbot.
"""
type Preference {
  """An object relationship"""
  chatbot: Chatbot!
  chatbotId: Int!

  """An object relationship"""
  complexityEnum: ComplexityEnum!
  favorite: Boolean

  """An object relationship"""
  lengthEnum: LengthEnum!
  preferenceId: Int!
  preferredComplexity: String!
  preferredLength: String!
  preferredTone: String!
  preferredType: String!

  """An object relationship"""
  toneEnum: ToneEnum!

  """An object relationship"""
  typeEnum: TypeEnum!

  """An object relationship"""
  user: User
  userId: uuid
}

"""
aggregated selection of "preference"
"""
type PreferenceAggregate {
  aggregate: PreferenceAggregateFields
  nodes: [Preference!]!
}

input PreferenceAggregateBoolExp {
  bool_and: preferenceAggregateBoolExpBool_and
  bool_or: preferenceAggregateBoolExpBool_or
  count: preferenceAggregateBoolExpCount
}

"""
aggregate fields of "preference"
"""
type PreferenceAggregateFields {
  avg: PreferenceAvgFields
  count(columns: [PreferenceSelectColumn!], distinct: Boolean): Int!
  max: PreferenceMaxFields
  min: PreferenceMinFields
  stddev: PreferenceStddevFields
  stddevPop: PreferenceStddevPopFields
  stddevSamp: PreferenceStddevSampFields
  sum: PreferenceSumFields
  varPop: PreferenceVarPopFields
  varSamp: PreferenceVarSampFields
  variance: PreferenceVarianceFields
}

"""
order by aggregate values of table "preference"
"""
input PreferenceAggregateOrderBy {
  avg: PreferenceAvgOrderBy
  count: OrderBy
  max: PreferenceMaxOrderBy
  min: PreferenceMinOrderBy
  stddev: PreferenceStddevOrderBy
  stddevPop: PreferenceStddevPopOrderBy
  stddevSamp: PreferenceStddevSampOrderBy
  sum: PreferenceSumOrderBy
  varPop: PreferenceVarPopOrderBy
  varSamp: PreferenceVarSampOrderBy
  variance: PreferenceVarianceOrderBy
}

"""
input type for inserting array relation for remote table "preference"
"""
input PreferenceArrRelInsertInput {
  data: [PreferenceInsertInput!]!

  """upsert condition"""
  onConflict: PreferenceOnConflict
}

"""aggregate avg on columns"""
type PreferenceAvgFields {
  chatbotId: Float
  preferenceId: Float
}

"""
order by avg() on columns of table "preference"
"""
input PreferenceAvgOrderBy {
  chatbotId: OrderBy
  preferenceId: OrderBy
}

"""
Boolean expression to filter rows from the table "preference". All fields are combined with a logical 'AND'.
"""
input PreferenceBoolExp {
  _and: [PreferenceBoolExp!]
  _not: PreferenceBoolExp
  _or: [PreferenceBoolExp!]
  chatbot: ChatbotBoolExp
  chatbotId: IntComparisonExp
  complexityEnum: ComplexityEnumBoolExp
  favorite: BooleanComparisonExp
  lengthEnum: LengthEnumBoolExp
  preferenceId: IntComparisonExp
  preferredComplexity: StringComparisonExp
  preferredLength: StringComparisonExp
  preferredTone: StringComparisonExp
  preferredType: StringComparisonExp
  toneEnum: ToneEnumBoolExp
  typeEnum: TypeEnumBoolExp
  user: UserBoolExp
  userId: UuidComparisonExp
}

"""
unique or primary key constraints on table "preference"
"""
enum PreferenceConstraint {
  """
  unique or primary key constraint on columns "preference_id"
  """
  user_chatbot_preference_pkey
}

"""
input type for incrementing numeric columns in table "preference"
"""
input PreferenceIncInput {
  chatbotId: Int
  preferenceId: Int
}

"""
input type for inserting data into table "preference"
"""
input PreferenceInsertInput {
  chatbot: ChatbotObjRelInsertInput
  chatbotId: Int
  complexityEnum: ComplexityEnumObjRelInsertInput
  favorite: Boolean
  lengthEnum: LengthEnumObjRelInsertInput
  preferenceId: Int
  preferredComplexity: String
  preferredLength: String
  preferredTone: String
  preferredType: String
  toneEnum: ToneEnumObjRelInsertInput
  typeEnum: TypeEnumObjRelInsertInput
  user: UserObjRelInsertInput
  userId: uuid
}

"""aggregate max on columns"""
type PreferenceMaxFields {
  chatbotId: Int
  preferenceId: Int
  preferredComplexity: String
  preferredLength: String
  preferredTone: String
  preferredType: String
  userId: uuid
}

"""
order by max() on columns of table "preference"
"""
input PreferenceMaxOrderBy {
  chatbotId: OrderBy
  preferenceId: OrderBy
  preferredComplexity: OrderBy
  preferredLength: OrderBy
  preferredTone: OrderBy
  preferredType: OrderBy
  userId: OrderBy
}

"""aggregate min on columns"""
type PreferenceMinFields {
  chatbotId: Int
  preferenceId: Int
  preferredComplexity: String
  preferredLength: String
  preferredTone: String
  preferredType: String
  userId: uuid
}

"""
order by min() on columns of table "preference"
"""
input PreferenceMinOrderBy {
  chatbotId: OrderBy
  preferenceId: OrderBy
  preferredComplexity: OrderBy
  preferredLength: OrderBy
  preferredTone: OrderBy
  preferredType: OrderBy
  userId: OrderBy
}

"""
response of any mutation on the table "preference"
"""
type PreferenceMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Preference!]!
}

"""
on_conflict condition type for table "preference"
"""
input PreferenceOnConflict {
  constraint: PreferenceConstraint!
  updateColumns: [PreferenceUpdateColumn!]! = []
  where: PreferenceBoolExp
}

"""Ordering options when selecting data from "preference"."""
input PreferenceOrderBy {
  chatbot: ChatbotOrderBy
  chatbotId: OrderBy
  complexityEnum: ComplexityEnumOrderBy
  favorite: OrderBy
  lengthEnum: LengthEnumOrderBy
  preferenceId: OrderBy
  preferredComplexity: OrderBy
  preferredLength: OrderBy
  preferredTone: OrderBy
  preferredType: OrderBy
  toneEnum: ToneEnumOrderBy
  typeEnum: TypeEnumOrderBy
  user: UserOrderBy
  userId: OrderBy
}

"""primary key columns input for table: preference"""
input PreferencePkColumnsInput {
  preferenceId: Int!
}

"""
select columns of table "preference"
"""
enum PreferenceSelectColumn {
  """column name"""
  chatbotId

  """column name"""
  favorite

  """column name"""
  preferenceId

  """column name"""
  preferredComplexity

  """column name"""
  preferredLength

  """column name"""
  preferredTone

  """column name"""
  preferredType

  """column name"""
  userId
}

"""
select "preferenceAggregateBoolExpBool_andArgumentsColumns" columns of table "preference"
"""
enum PreferenceSelectColumnPreferenceAggregateBoolExpBool_andArgumentsColumns {
  """column name"""
  favorite
}

"""
select "preferenceAggregateBoolExpBool_orArgumentsColumns" columns of table "preference"
"""
enum PreferenceSelectColumnPreferenceAggregateBoolExpBool_orArgumentsColumns {
  """column name"""
  favorite
}

"""
input type for updating data in table "preference"
"""
input PreferenceSetInput {
  chatbotId: Int
  favorite: Boolean
  preferenceId: Int
  preferredComplexity: String
  preferredLength: String
  preferredTone: String
  preferredType: String
  userId: uuid
}

"""aggregate stddev on columns"""
type PreferenceStddevFields {
  chatbotId: Float
  preferenceId: Float
}

"""
order by stddev() on columns of table "preference"
"""
input PreferenceStddevOrderBy {
  chatbotId: OrderBy
  preferenceId: OrderBy
}

"""aggregate stddevPop on columns"""
type PreferenceStddevPopFields {
  chatbotId: Float
  preferenceId: Float
}

"""
order by stddevPop() on columns of table "preference"
"""
input PreferenceStddevPopOrderBy {
  chatbotId: OrderBy
  preferenceId: OrderBy
}

"""aggregate stddevSamp on columns"""
type PreferenceStddevSampFields {
  chatbotId: Float
  preferenceId: Float
}

"""
order by stddevSamp() on columns of table "preference"
"""
input PreferenceStddevSampOrderBy {
  chatbotId: OrderBy
  preferenceId: OrderBy
}

"""
Streaming cursor of the table "preference"
"""
input PreferenceStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PreferenceStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PreferenceStreamCursorValueInput {
  chatbotId: Int
  favorite: Boolean
  preferenceId: Int
  preferredComplexity: String
  preferredLength: String
  preferredTone: String
  preferredType: String
  userId: uuid
}

"""aggregate sum on columns"""
type PreferenceSumFields {
  chatbotId: Int
  preferenceId: Int
}

"""
order by sum() on columns of table "preference"
"""
input PreferenceSumOrderBy {
  chatbotId: OrderBy
  preferenceId: OrderBy
}

"""
update columns of table "preference"
"""
enum PreferenceUpdateColumn {
  """column name"""
  chatbotId

  """column name"""
  favorite

  """column name"""
  preferenceId

  """column name"""
  preferredComplexity

  """column name"""
  preferredLength

  """column name"""
  preferredTone

  """column name"""
  preferredType

  """column name"""
  userId
}

input PreferenceUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: PreferenceIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: PreferenceSetInput

  """filter the rows which have to be updated"""
  where: PreferenceBoolExp!
}

"""aggregate varPop on columns"""
type PreferenceVarPopFields {
  chatbotId: Float
  preferenceId: Float
}

"""
order by varPop() on columns of table "preference"
"""
input PreferenceVarPopOrderBy {
  chatbotId: OrderBy
  preferenceId: OrderBy
}

"""aggregate varSamp on columns"""
type PreferenceVarSampFields {
  chatbotId: Float
  preferenceId: Float
}

"""
order by varSamp() on columns of table "preference"
"""
input PreferenceVarSampOrderBy {
  chatbotId: OrderBy
  preferenceId: OrderBy
}

"""aggregate variance on columns"""
type PreferenceVarianceFields {
  chatbotId: Float
  preferenceId: Float
}

"""
order by variance() on columns of table "preference"
"""
input PreferenceVarianceOrderBy {
  chatbotId: OrderBy
  preferenceId: OrderBy
}

"""
columns and relationships of "prompt"
"""
type Prompt {
  """An array relationship"""
  chatbots(
    """distinct select on columns"""
    distinctOn: [PromptChatbotSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptChatbotOrderBy!]

    """filter the rows returned"""
    where: PromptChatbotBoolExp
  ): [PromptChatbot!]!

  """An aggregate relationship"""
  chatbotsAggregate(
    """distinct select on columns"""
    distinctOn: [PromptChatbotSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptChatbotOrderBy!]

    """filter the rows returned"""
    where: PromptChatbotBoolExp
  ): PromptChatbotAggregate!
  content: String!
  promptId: Int!
  promptName: String

  """An object relationship"""
  promptTypeEnum: PromptTypeEnum!
  type: String!

  """An array relationship"""
  users(
    """distinct select on columns"""
    distinctOn: [PromptUserSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptUserOrderBy!]

    """filter the rows returned"""
    where: PromptUserBoolExp
  ): [PromptUser!]!

  """An aggregate relationship"""
  usersAggregate(
    """distinct select on columns"""
    distinctOn: [PromptUserSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptUserOrderBy!]

    """filter the rows returned"""
    where: PromptUserBoolExp
  ): PromptUserAggregate!
}

"""
aggregated selection of "prompt"
"""
type PromptAggregate {
  aggregate: PromptAggregateFields
  nodes: [Prompt!]!
}

input PromptAggregateBoolExp {
  count: promptAggregateBoolExpCount
}

"""
aggregate fields of "prompt"
"""
type PromptAggregateFields {
  avg: PromptAvgFields
  count(columns: [PromptSelectColumn!], distinct: Boolean): Int!
  max: PromptMaxFields
  min: PromptMinFields
  stddev: PromptStddevFields
  stddevPop: PromptStddevPopFields
  stddevSamp: PromptStddevSampFields
  sum: PromptSumFields
  varPop: PromptVarPopFields
  varSamp: PromptVarSampFields
  variance: PromptVarianceFields
}

"""
order by aggregate values of table "prompt"
"""
input PromptAggregateOrderBy {
  avg: PromptAvgOrderBy
  count: OrderBy
  max: PromptMaxOrderBy
  min: PromptMinOrderBy
  stddev: PromptStddevOrderBy
  stddevPop: PromptStddevPopOrderBy
  stddevSamp: PromptStddevSampOrderBy
  sum: PromptSumOrderBy
  varPop: PromptVarPopOrderBy
  varSamp: PromptVarSampOrderBy
  variance: PromptVarianceOrderBy
}

"""
input type for inserting array relation for remote table "prompt"
"""
input PromptArrRelInsertInput {
  data: [PromptInsertInput!]!

  """upsert condition"""
  onConflict: PromptOnConflict
}

"""aggregate avg on columns"""
type PromptAvgFields {
  promptId: Float
}

"""
order by avg() on columns of table "prompt"
"""
input PromptAvgOrderBy {
  promptId: OrderBy
}

"""
Boolean expression to filter rows from the table "prompt". All fields are combined with a logical 'AND'.
"""
input PromptBoolExp {
  _and: [PromptBoolExp!]
  _not: PromptBoolExp
  _or: [PromptBoolExp!]
  chatbots: PromptChatbotBoolExp
  chatbotsAggregate: PromptChatbotAggregateBoolExp
  content: StringComparisonExp
  promptId: IntComparisonExp
  promptName: StringComparisonExp
  promptTypeEnum: PromptTypeEnumBoolExp
  type: StringComparisonExp
  users: PromptUserBoolExp
  usersAggregate: PromptUserAggregateBoolExp
}

"""Junction table for prompts/instructions and chatbots."""
type PromptChatbot {
  chabotId: Int!

  """An object relationship"""
  chatbot: Chatbot!

  """An object relationship"""
  prompt: Prompt!
  promptId: Int!
}

"""
aggregated selection of "prompt_chatbot"
"""
type PromptChatbotAggregate {
  aggregate: PromptChatbotAggregateFields
  nodes: [PromptChatbot!]!
}

input PromptChatbotAggregateBoolExp {
  count: promptChatbotAggregateBoolExpCount
}

"""
aggregate fields of "prompt_chatbot"
"""
type PromptChatbotAggregateFields {
  avg: PromptChatbotAvgFields
  count(columns: [PromptChatbotSelectColumn!], distinct: Boolean): Int!
  max: PromptChatbotMaxFields
  min: PromptChatbotMinFields
  stddev: PromptChatbotStddevFields
  stddevPop: PromptChatbotStddevPopFields
  stddevSamp: PromptChatbotStddevSampFields
  sum: PromptChatbotSumFields
  varPop: PromptChatbotVarPopFields
  varSamp: PromptChatbotVarSampFields
  variance: PromptChatbotVarianceFields
}

"""
order by aggregate values of table "prompt_chatbot"
"""
input PromptChatbotAggregateOrderBy {
  avg: PromptChatbotAvgOrderBy
  count: OrderBy
  max: PromptChatbotMaxOrderBy
  min: PromptChatbotMinOrderBy
  stddev: PromptChatbotStddevOrderBy
  stddevPop: PromptChatbotStddevPopOrderBy
  stddevSamp: PromptChatbotStddevSampOrderBy
  sum: PromptChatbotSumOrderBy
  varPop: PromptChatbotVarPopOrderBy
  varSamp: PromptChatbotVarSampOrderBy
  variance: PromptChatbotVarianceOrderBy
}

"""
input type for inserting array relation for remote table "prompt_chatbot"
"""
input PromptChatbotArrRelInsertInput {
  data: [PromptChatbotInsertInput!]!

  """upsert condition"""
  onConflict: PromptChatbotOnConflict
}

"""aggregate avg on columns"""
type PromptChatbotAvgFields {
  chabotId: Float
  promptId: Float
}

"""
order by avg() on columns of table "prompt_chatbot"
"""
input PromptChatbotAvgOrderBy {
  chabotId: OrderBy
  promptId: OrderBy
}

"""
Boolean expression to filter rows from the table "prompt_chatbot". All fields are combined with a logical 'AND'.
"""
input PromptChatbotBoolExp {
  _and: [PromptChatbotBoolExp!]
  _not: PromptChatbotBoolExp
  _or: [PromptChatbotBoolExp!]
  chabotId: IntComparisonExp
  chatbot: ChatbotBoolExp
  prompt: PromptBoolExp
  promptId: IntComparisonExp
}

"""
unique or primary key constraints on table "prompt_chatbot"
"""
enum PromptChatbotConstraint {
  """
  unique or primary key constraint on columns "prompt_id", "chabot_id"
  """
  prompt_chatbot_pkey
}

"""
input type for incrementing numeric columns in table "prompt_chatbot"
"""
input PromptChatbotIncInput {
  chabotId: Int
  promptId: Int
}

"""
input type for inserting data into table "prompt_chatbot"
"""
input PromptChatbotInsertInput {
  chabotId: Int
  chatbot: ChatbotObjRelInsertInput
  prompt: PromptObjRelInsertInput
  promptId: Int
}

"""aggregate max on columns"""
type PromptChatbotMaxFields {
  chabotId: Int
  promptId: Int
}

"""
order by max() on columns of table "prompt_chatbot"
"""
input PromptChatbotMaxOrderBy {
  chabotId: OrderBy
  promptId: OrderBy
}

"""aggregate min on columns"""
type PromptChatbotMinFields {
  chabotId: Int
  promptId: Int
}

"""
order by min() on columns of table "prompt_chatbot"
"""
input PromptChatbotMinOrderBy {
  chabotId: OrderBy
  promptId: OrderBy
}

"""
response of any mutation on the table "prompt_chatbot"
"""
type PromptChatbotMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [PromptChatbot!]!
}

"""
on_conflict condition type for table "prompt_chatbot"
"""
input PromptChatbotOnConflict {
  constraint: PromptChatbotConstraint!
  updateColumns: [PromptChatbotUpdateColumn!]! = []
  where: PromptChatbotBoolExp
}

"""Ordering options when selecting data from "prompt_chatbot"."""
input PromptChatbotOrderBy {
  chabotId: OrderBy
  chatbot: ChatbotOrderBy
  prompt: PromptOrderBy
  promptId: OrderBy
}

"""primary key columns input for table: prompt_chatbot"""
input PromptChatbotPkColumnsInput {
  chabotId: Int!
  promptId: Int!
}

"""
select columns of table "prompt_chatbot"
"""
enum PromptChatbotSelectColumn {
  """column name"""
  chabotId

  """column name"""
  promptId
}

"""
input type for updating data in table "prompt_chatbot"
"""
input PromptChatbotSetInput {
  chabotId: Int
  promptId: Int
}

"""aggregate stddev on columns"""
type PromptChatbotStddevFields {
  chabotId: Float
  promptId: Float
}

"""
order by stddev() on columns of table "prompt_chatbot"
"""
input PromptChatbotStddevOrderBy {
  chabotId: OrderBy
  promptId: OrderBy
}

"""aggregate stddevPop on columns"""
type PromptChatbotStddevPopFields {
  chabotId: Float
  promptId: Float
}

"""
order by stddevPop() on columns of table "prompt_chatbot"
"""
input PromptChatbotStddevPopOrderBy {
  chabotId: OrderBy
  promptId: OrderBy
}

"""aggregate stddevSamp on columns"""
type PromptChatbotStddevSampFields {
  chabotId: Float
  promptId: Float
}

"""
order by stddevSamp() on columns of table "prompt_chatbot"
"""
input PromptChatbotStddevSampOrderBy {
  chabotId: OrderBy
  promptId: OrderBy
}

"""
Streaming cursor of the table "prompt_chatbot"
"""
input PromptChatbotStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PromptChatbotStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PromptChatbotStreamCursorValueInput {
  chabotId: Int
  promptId: Int
}

"""aggregate sum on columns"""
type PromptChatbotSumFields {
  chabotId: Int
  promptId: Int
}

"""
order by sum() on columns of table "prompt_chatbot"
"""
input PromptChatbotSumOrderBy {
  chabotId: OrderBy
  promptId: OrderBy
}

"""
update columns of table "prompt_chatbot"
"""
enum PromptChatbotUpdateColumn {
  """column name"""
  chabotId

  """column name"""
  promptId
}

input PromptChatbotUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: PromptChatbotIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: PromptChatbotSetInput

  """filter the rows which have to be updated"""
  where: PromptChatbotBoolExp!
}

"""aggregate varPop on columns"""
type PromptChatbotVarPopFields {
  chabotId: Float
  promptId: Float
}

"""
order by varPop() on columns of table "prompt_chatbot"
"""
input PromptChatbotVarPopOrderBy {
  chabotId: OrderBy
  promptId: OrderBy
}

"""aggregate varSamp on columns"""
type PromptChatbotVarSampFields {
  chabotId: Float
  promptId: Float
}

"""
order by varSamp() on columns of table "prompt_chatbot"
"""
input PromptChatbotVarSampOrderBy {
  chabotId: OrderBy
  promptId: OrderBy
}

"""aggregate variance on columns"""
type PromptChatbotVarianceFields {
  chabotId: Float
  promptId: Float
}

"""
order by variance() on columns of table "prompt_chatbot"
"""
input PromptChatbotVarianceOrderBy {
  chabotId: OrderBy
  promptId: OrderBy
}

"""
unique or primary key constraints on table "prompt"
"""
enum PromptConstraint {
  """
  unique or primary key constraint on columns "prompt_id"
  """
  prompt_pkey

  """
  unique or primary key constraint on columns "prompt_id"
  """
  prompt_prompt_id_key
}

"""
input type for incrementing numeric columns in table "prompt"
"""
input PromptIncInput {
  promptId: Int
}

"""
input type for inserting data into table "prompt"
"""
input PromptInsertInput {
  chatbots: PromptChatbotArrRelInsertInput
  content: String
  promptId: Int
  promptName: String
  promptTypeEnum: PromptTypeEnumObjRelInsertInput
  type: String
  users: PromptUserArrRelInsertInput
}

"""aggregate max on columns"""
type PromptMaxFields {
  content: String
  promptId: Int
  promptName: String
  type: String
}

"""
order by max() on columns of table "prompt"
"""
input PromptMaxOrderBy {
  content: OrderBy
  promptId: OrderBy
  promptName: OrderBy
  type: OrderBy
}

"""aggregate min on columns"""
type PromptMinFields {
  content: String
  promptId: Int
  promptName: String
  type: String
}

"""
order by min() on columns of table "prompt"
"""
input PromptMinOrderBy {
  content: OrderBy
  promptId: OrderBy
  promptName: OrderBy
  type: OrderBy
}

"""
response of any mutation on the table "prompt"
"""
type PromptMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Prompt!]!
}

"""
input type for inserting object relation for remote table "prompt"
"""
input PromptObjRelInsertInput {
  data: PromptInsertInput!

  """upsert condition"""
  onConflict: PromptOnConflict
}

"""
on_conflict condition type for table "prompt"
"""
input PromptOnConflict {
  constraint: PromptConstraint!
  updateColumns: [PromptUpdateColumn!]! = []
  where: PromptBoolExp
}

"""Ordering options when selecting data from "prompt"."""
input PromptOrderBy {
  chatbotsAggregate: PromptChatbotAggregateOrderBy
  content: OrderBy
  promptId: OrderBy
  promptName: OrderBy
  promptTypeEnum: PromptTypeEnumOrderBy
  type: OrderBy
  usersAggregate: PromptUserAggregateOrderBy
}

"""primary key columns input for table: prompt"""
input PromptPkColumnsInput {
  promptId: Int!
}

"""
select columns of table "prompt"
"""
enum PromptSelectColumn {
  """column name"""
  content

  """column name"""
  promptId

  """column name"""
  promptName

  """column name"""
  type
}

"""
input type for updating data in table "prompt"
"""
input PromptSetInput {
  content: String
  promptId: Int
  promptName: String
  type: String
}

"""aggregate stddev on columns"""
type PromptStddevFields {
  promptId: Float
}

"""
order by stddev() on columns of table "prompt"
"""
input PromptStddevOrderBy {
  promptId: OrderBy
}

"""aggregate stddevPop on columns"""
type PromptStddevPopFields {
  promptId: Float
}

"""
order by stddevPop() on columns of table "prompt"
"""
input PromptStddevPopOrderBy {
  promptId: OrderBy
}

"""aggregate stddevSamp on columns"""
type PromptStddevSampFields {
  promptId: Float
}

"""
order by stddevSamp() on columns of table "prompt"
"""
input PromptStddevSampOrderBy {
  promptId: OrderBy
}

"""
Streaming cursor of the table "prompt"
"""
input PromptStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PromptStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PromptStreamCursorValueInput {
  content: String
  promptId: Int
  promptName: String
  type: String
}

"""aggregate sum on columns"""
type PromptSumFields {
  promptId: Int
}

"""
order by sum() on columns of table "prompt"
"""
input PromptSumOrderBy {
  promptId: OrderBy
}

"""
columns and relationships of "prompt_type_enum"
"""
type PromptTypeEnum {
  """An array relationship"""
  prompts(
    """distinct select on columns"""
    distinctOn: [PromptSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptOrderBy!]

    """filter the rows returned"""
    where: PromptBoolExp
  ): [Prompt!]!

  """An aggregate relationship"""
  promptsAggregate(
    """distinct select on columns"""
    distinctOn: [PromptSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptOrderBy!]

    """filter the rows returned"""
    where: PromptBoolExp
  ): PromptAggregate!
  value: String!
}

"""
aggregated selection of "prompt_type_enum"
"""
type PromptTypeEnumAggregate {
  aggregate: PromptTypeEnumAggregateFields
  nodes: [PromptTypeEnum!]!
}

"""
aggregate fields of "prompt_type_enum"
"""
type PromptTypeEnumAggregateFields {
  count(columns: [PromptTypeEnumSelectColumn!], distinct: Boolean): Int!
  max: PromptTypeEnumMaxFields
  min: PromptTypeEnumMinFields
}

"""
Boolean expression to filter rows from the table "prompt_type_enum". All fields are combined with a logical 'AND'.
"""
input PromptTypeEnumBoolExp {
  _and: [PromptTypeEnumBoolExp!]
  _not: PromptTypeEnumBoolExp
  _or: [PromptTypeEnumBoolExp!]
  prompts: PromptBoolExp
  promptsAggregate: PromptAggregateBoolExp
  value: StringComparisonExp
}

"""
unique or primary key constraints on table "prompt_type_enum"
"""
enum PromptTypeEnumConstraint {
  """
  unique or primary key constraint on columns "value"
  """
  type_enum_pkey
}

"""
input type for inserting data into table "prompt_type_enum"
"""
input PromptTypeEnumInsertInput {
  prompts: PromptArrRelInsertInput
  value: String
}

"""aggregate max on columns"""
type PromptTypeEnumMaxFields {
  value: String
}

"""aggregate min on columns"""
type PromptTypeEnumMinFields {
  value: String
}

"""
response of any mutation on the table "prompt_type_enum"
"""
type PromptTypeEnumMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [PromptTypeEnum!]!
}

"""
input type for inserting object relation for remote table "prompt_type_enum"
"""
input PromptTypeEnumObjRelInsertInput {
  data: PromptTypeEnumInsertInput!

  """upsert condition"""
  onConflict: PromptTypeEnumOnConflict
}

"""
on_conflict condition type for table "prompt_type_enum"
"""
input PromptTypeEnumOnConflict {
  constraint: PromptTypeEnumConstraint!
  updateColumns: [PromptTypeEnumUpdateColumn!]! = []
  where: PromptTypeEnumBoolExp
}

"""Ordering options when selecting data from "prompt_type_enum"."""
input PromptTypeEnumOrderBy {
  promptsAggregate: PromptAggregateOrderBy
  value: OrderBy
}

"""primary key columns input for table: prompt_type_enum"""
input PromptTypeEnumPkColumnsInput {
  value: String!
}

"""
select columns of table "prompt_type_enum"
"""
enum PromptTypeEnumSelectColumn {
  """column name"""
  value
}

"""
input type for updating data in table "prompt_type_enum"
"""
input PromptTypeEnumSetInput {
  value: String
}

"""
Streaming cursor of the table "prompt_type_enum"
"""
input PromptTypeEnumStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PromptTypeEnumStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PromptTypeEnumStreamCursorValueInput {
  value: String
}

"""
update columns of table "prompt_type_enum"
"""
enum PromptTypeEnumUpdateColumn {
  """column name"""
  value
}

input PromptTypeEnumUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: PromptTypeEnumSetInput

  """filter the rows which have to be updated"""
  where: PromptTypeEnumBoolExp!
}

"""
update columns of table "prompt"
"""
enum PromptUpdateColumn {
  """column name"""
  content

  """column name"""
  promptId

  """column name"""
  promptName

  """column name"""
  type
}

input PromptUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: PromptIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: PromptSetInput

  """filter the rows which have to be updated"""
  where: PromptBoolExp!
}

"""
columns and relationships of "prompt_user"
"""
type PromptUser {
  """An object relationship"""
  prompt: Prompt!
  promptId: Int!

  """An object relationship"""
  user: User!
  userId: uuid!
}

"""
aggregated selection of "prompt_user"
"""
type PromptUserAggregate {
  aggregate: PromptUserAggregateFields
  nodes: [PromptUser!]!
}

input PromptUserAggregateBoolExp {
  count: promptUserAggregateBoolExpCount
}

"""
aggregate fields of "prompt_user"
"""
type PromptUserAggregateFields {
  avg: PromptUserAvgFields
  count(columns: [PromptUserSelectColumn!], distinct: Boolean): Int!
  max: PromptUserMaxFields
  min: PromptUserMinFields
  stddev: PromptUserStddevFields
  stddevPop: PromptUserStddevPopFields
  stddevSamp: PromptUserStddevSampFields
  sum: PromptUserSumFields
  varPop: PromptUserVarPopFields
  varSamp: PromptUserVarSampFields
  variance: PromptUserVarianceFields
}

"""
order by aggregate values of table "prompt_user"
"""
input PromptUserAggregateOrderBy {
  avg: PromptUserAvgOrderBy
  count: OrderBy
  max: PromptUserMaxOrderBy
  min: PromptUserMinOrderBy
  stddev: PromptUserStddevOrderBy
  stddevPop: PromptUserStddevPopOrderBy
  stddevSamp: PromptUserStddevSampOrderBy
  sum: PromptUserSumOrderBy
  varPop: PromptUserVarPopOrderBy
  varSamp: PromptUserVarSampOrderBy
  variance: PromptUserVarianceOrderBy
}

"""
input type for inserting array relation for remote table "prompt_user"
"""
input PromptUserArrRelInsertInput {
  data: [PromptUserInsertInput!]!

  """upsert condition"""
  onConflict: PromptUserOnConflict
}

"""aggregate avg on columns"""
type PromptUserAvgFields {
  promptId: Float
}

"""
order by avg() on columns of table "prompt_user"
"""
input PromptUserAvgOrderBy {
  promptId: OrderBy
}

"""
Boolean expression to filter rows from the table "prompt_user". All fields are combined with a logical 'AND'.
"""
input PromptUserBoolExp {
  _and: [PromptUserBoolExp!]
  _not: PromptUserBoolExp
  _or: [PromptUserBoolExp!]
  prompt: PromptBoolExp
  promptId: IntComparisonExp
  user: UserBoolExp
  userId: UuidComparisonExp
}

"""
unique or primary key constraints on table "prompt_user"
"""
enum PromptUserConstraint {
  """
  unique or primary key constraint on columns "user_id", "prompt_id"
  """
  prompt_user_pkey
}

"""
input type for incrementing numeric columns in table "prompt_user"
"""
input PromptUserIncInput {
  promptId: Int
}

"""
input type for inserting data into table "prompt_user"
"""
input PromptUserInsertInput {
  prompt: PromptObjRelInsertInput
  promptId: Int
  user: UserObjRelInsertInput
  userId: uuid
}

"""aggregate max on columns"""
type PromptUserMaxFields {
  promptId: Int
  userId: uuid
}

"""
order by max() on columns of table "prompt_user"
"""
input PromptUserMaxOrderBy {
  promptId: OrderBy
  userId: OrderBy
}

"""aggregate min on columns"""
type PromptUserMinFields {
  promptId: Int
  userId: uuid
}

"""
order by min() on columns of table "prompt_user"
"""
input PromptUserMinOrderBy {
  promptId: OrderBy
  userId: OrderBy
}

"""
response of any mutation on the table "prompt_user"
"""
type PromptUserMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [PromptUser!]!
}

"""
on_conflict condition type for table "prompt_user"
"""
input PromptUserOnConflict {
  constraint: PromptUserConstraint!
  updateColumns: [PromptUserUpdateColumn!]! = []
  where: PromptUserBoolExp
}

"""Ordering options when selecting data from "prompt_user"."""
input PromptUserOrderBy {
  prompt: PromptOrderBy
  promptId: OrderBy
  user: UserOrderBy
  userId: OrderBy
}

"""primary key columns input for table: prompt_user"""
input PromptUserPkColumnsInput {
  promptId: Int!
  userId: uuid!
}

"""
select columns of table "prompt_user"
"""
enum PromptUserSelectColumn {
  """column name"""
  promptId

  """column name"""
  userId
}

"""
input type for updating data in table "prompt_user"
"""
input PromptUserSetInput {
  promptId: Int
  userId: uuid
}

"""aggregate stddev on columns"""
type PromptUserStddevFields {
  promptId: Float
}

"""
order by stddev() on columns of table "prompt_user"
"""
input PromptUserStddevOrderBy {
  promptId: OrderBy
}

"""aggregate stddevPop on columns"""
type PromptUserStddevPopFields {
  promptId: Float
}

"""
order by stddevPop() on columns of table "prompt_user"
"""
input PromptUserStddevPopOrderBy {
  promptId: OrderBy
}

"""aggregate stddevSamp on columns"""
type PromptUserStddevSampFields {
  promptId: Float
}

"""
order by stddevSamp() on columns of table "prompt_user"
"""
input PromptUserStddevSampOrderBy {
  promptId: OrderBy
}

"""
Streaming cursor of the table "prompt_user"
"""
input PromptUserStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PromptUserStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PromptUserStreamCursorValueInput {
  promptId: Int
  userId: uuid
}

"""aggregate sum on columns"""
type PromptUserSumFields {
  promptId: Int
}

"""
order by sum() on columns of table "prompt_user"
"""
input PromptUserSumOrderBy {
  promptId: OrderBy
}

"""
update columns of table "prompt_user"
"""
enum PromptUserUpdateColumn {
  """column name"""
  promptId

  """column name"""
  userId
}

input PromptUserUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: PromptUserIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: PromptUserSetInput

  """filter the rows which have to be updated"""
  where: PromptUserBoolExp!
}

"""aggregate varPop on columns"""
type PromptUserVarPopFields {
  promptId: Float
}

"""
order by varPop() on columns of table "prompt_user"
"""
input PromptUserVarPopOrderBy {
  promptId: OrderBy
}

"""aggregate varSamp on columns"""
type PromptUserVarSampFields {
  promptId: Float
}

"""
order by varSamp() on columns of table "prompt_user"
"""
input PromptUserVarSampOrderBy {
  promptId: OrderBy
}

"""aggregate variance on columns"""
type PromptUserVarianceFields {
  promptId: Float
}

"""
order by variance() on columns of table "prompt_user"
"""
input PromptUserVarianceOrderBy {
  promptId: OrderBy
}

"""aggregate varPop on columns"""
type PromptVarPopFields {
  promptId: Float
}

"""
order by varPop() on columns of table "prompt"
"""
input PromptVarPopOrderBy {
  promptId: OrderBy
}

"""aggregate varSamp on columns"""
type PromptVarSampFields {
  promptId: Float
}

"""
order by varSamp() on columns of table "prompt"
"""
input PromptVarSampOrderBy {
  promptId: OrderBy
}

"""aggregate variance on columns"""
type PromptVarianceFields {
  promptId: Float
}

"""
order by variance() on columns of table "prompt"
"""
input PromptVarianceOrderBy {
  promptId: OrderBy
}

"""
columns and relationships of "referral"
"""
type Referral {
  referralCode: String!
  referrerId: uuid!

  """An object relationship"""
  user: User!

  """An object relationship"""
  userByUserId: User!
  userId: uuid!
}

"""
aggregated selection of "referral"
"""
type ReferralAggregate {
  aggregate: ReferralAggregateFields
  nodes: [Referral!]!
}

input ReferralAggregateBoolExp {
  count: referralAggregateBoolExpCount
}

"""
aggregate fields of "referral"
"""
type ReferralAggregateFields {
  count(columns: [ReferralSelectColumn!], distinct: Boolean): Int!
  max: ReferralMaxFields
  min: ReferralMinFields
}

"""
order by aggregate values of table "referral"
"""
input ReferralAggregateOrderBy {
  count: OrderBy
  max: ReferralMaxOrderBy
  min: ReferralMinOrderBy
}

"""
input type for inserting array relation for remote table "referral"
"""
input ReferralArrRelInsertInput {
  data: [ReferralInsertInput!]!

  """upsert condition"""
  onConflict: ReferralOnConflict
}

"""
Boolean expression to filter rows from the table "referral". All fields are combined with a logical 'AND'.
"""
input ReferralBoolExp {
  _and: [ReferralBoolExp!]
  _not: ReferralBoolExp
  _or: [ReferralBoolExp!]
  referralCode: StringComparisonExp
  referrerId: UuidComparisonExp
  user: UserBoolExp
  userByUserId: UserBoolExp
  userId: UuidComparisonExp
}

"""
unique or primary key constraints on table "referral"
"""
enum ReferralConstraint {
  """
  unique or primary key constraint on columns "referral_code"
  """
  referral_pkey
}

"""
input type for inserting data into table "referral"
"""
input ReferralInsertInput {
  referralCode: String
  referrerId: uuid
  user: UserObjRelInsertInput
  userByUserId: UserObjRelInsertInput
  userId: uuid
}

"""aggregate max on columns"""
type ReferralMaxFields {
  referralCode: String
  referrerId: uuid
  userId: uuid
}

"""
order by max() on columns of table "referral"
"""
input ReferralMaxOrderBy {
  referralCode: OrderBy
  referrerId: OrderBy
  userId: OrderBy
}

"""aggregate min on columns"""
type ReferralMinFields {
  referralCode: String
  referrerId: uuid
  userId: uuid
}

"""
order by min() on columns of table "referral"
"""
input ReferralMinOrderBy {
  referralCode: OrderBy
  referrerId: OrderBy
  userId: OrderBy
}

"""
response of any mutation on the table "referral"
"""
type ReferralMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Referral!]!
}

"""
on_conflict condition type for table "referral"
"""
input ReferralOnConflict {
  constraint: ReferralConstraint!
  updateColumns: [ReferralUpdateColumn!]! = []
  where: ReferralBoolExp
}

"""Ordering options when selecting data from "referral"."""
input ReferralOrderBy {
  referralCode: OrderBy
  referrerId: OrderBy
  user: UserOrderBy
  userByUserId: UserOrderBy
  userId: OrderBy
}

"""primary key columns input for table: referral"""
input ReferralPkColumnsInput {
  referralCode: String!
}

"""
select columns of table "referral"
"""
enum ReferralSelectColumn {
  """column name"""
  referralCode

  """column name"""
  referrerId

  """column name"""
  userId
}

"""
input type for updating data in table "referral"
"""
input ReferralSetInput {
  referralCode: String
  referrerId: uuid
  userId: uuid
}

"""
Streaming cursor of the table "referral"
"""
input ReferralStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ReferralStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ReferralStreamCursorValueInput {
  referralCode: String
  referrerId: uuid
  userId: uuid
}

"""
update columns of table "referral"
"""
enum ReferralUpdateColumn {
  """column name"""
  referralCode

  """column name"""
  referrerId

  """column name"""
  userId
}

input ReferralUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: ReferralSetInput

  """filter the rows which have to be updated"""
  where: ReferralBoolExp!
}

"""
This junction table records social following relationships between users. Each record represents a follower-followee relationship.
"""
type SocialFollowing {
  createdAt: timestamptz!
  followeeId: uuid!
  followerId: uuid!

  """An object relationship"""
  user: User!

  """An object relationship"""
  userByFollowerId: User!
}

"""
aggregated selection of "social_following"
"""
type SocialFollowingAggregate {
  aggregate: SocialFollowingAggregateFields
  nodes: [SocialFollowing!]!
}

input SocialFollowingAggregateBoolExp {
  count: socialFollowingAggregateBoolExpCount
}

"""
aggregate fields of "social_following"
"""
type SocialFollowingAggregateFields {
  count(columns: [SocialFollowingSelectColumn!], distinct: Boolean): Int!
  max: SocialFollowingMaxFields
  min: SocialFollowingMinFields
}

"""
order by aggregate values of table "social_following"
"""
input SocialFollowingAggregateOrderBy {
  count: OrderBy
  max: SocialFollowingMaxOrderBy
  min: SocialFollowingMinOrderBy
}

"""
input type for inserting array relation for remote table "social_following"
"""
input SocialFollowingArrRelInsertInput {
  data: [SocialFollowingInsertInput!]!
}

"""
Boolean expression to filter rows from the table "social_following". All fields are combined with a logical 'AND'.
"""
input SocialFollowingBoolExp {
  _and: [SocialFollowingBoolExp!]
  _not: SocialFollowingBoolExp
  _or: [SocialFollowingBoolExp!]
  createdAt: TimestamptzComparisonExp
  followeeId: UuidComparisonExp
  followerId: UuidComparisonExp
  user: UserBoolExp
  userByFollowerId: UserBoolExp
}

"""
input type for inserting data into table "social_following"
"""
input SocialFollowingInsertInput {
  createdAt: timestamptz
  followeeId: uuid
  followerId: uuid
  user: UserObjRelInsertInput
  userByFollowerId: UserObjRelInsertInput
}

"""aggregate max on columns"""
type SocialFollowingMaxFields {
  createdAt: timestamptz
  followeeId: uuid
  followerId: uuid
}

"""
order by max() on columns of table "social_following"
"""
input SocialFollowingMaxOrderBy {
  createdAt: OrderBy
  followeeId: OrderBy
  followerId: OrderBy
}

"""aggregate min on columns"""
type SocialFollowingMinFields {
  createdAt: timestamptz
  followeeId: uuid
  followerId: uuid
}

"""
order by min() on columns of table "social_following"
"""
input SocialFollowingMinOrderBy {
  createdAt: OrderBy
  followeeId: OrderBy
  followerId: OrderBy
}

"""
response of any mutation on the table "social_following"
"""
type SocialFollowingMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [SocialFollowing!]!
}

"""Ordering options when selecting data from "social_following"."""
input SocialFollowingOrderBy {
  createdAt: OrderBy
  followeeId: OrderBy
  followerId: OrderBy
  user: UserOrderBy
  userByFollowerId: UserOrderBy
}

"""
select columns of table "social_following"
"""
enum SocialFollowingSelectColumn {
  """column name"""
  createdAt

  """column name"""
  followeeId

  """column name"""
  followerId
}

"""
input type for updating data in table "social_following"
"""
input SocialFollowingSetInput {
  createdAt: timestamptz
  followeeId: uuid
  followerId: uuid
}

"""
Streaming cursor of the table "social_following"
"""
input SocialFollowingStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: SocialFollowingStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input SocialFollowingStreamCursorValueInput {
  createdAt: timestamptz
  followeeId: uuid
  followerId: uuid
}

input SocialFollowingUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: SocialFollowingSetInput

  """filter the rows which have to be updated"""
  where: SocialFollowingBoolExp!
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input StringComparisonExp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _isNull: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

"""
columns and relationships of "thread"
"""
type Thread {
  """An object relationship"""
  chatbot: Chatbot!
  chatbotId: Int!
  createdAt: timestamptz!
  isApproved: Boolean
  isBlocked: Boolean
  isPublic: Boolean

  """An array relationship"""
  messages(
    """distinct select on columns"""
    distinctOn: [MessageSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MessageOrderBy!]

    """filter the rows returned"""
    where: MessageBoolExp
  ): [Message!]!

  """An aggregate relationship"""
  messagesAggregate(
    """distinct select on columns"""
    distinctOn: [MessageSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MessageOrderBy!]

    """filter the rows returned"""
    where: MessageBoolExp
  ): MessageAggregate!
  model: ModelsEnumEnum!

  """An object relationship"""
  modelsEnum: ModelsEnum!
  threadId: uuid!
  updatedAt: timestamptz!

  """An object relationship"""
  user: User
  userId: uuid
}

"""
aggregated selection of "thread"
"""
type ThreadAggregate {
  aggregate: ThreadAggregateFields
  nodes: [Thread!]!
}

input ThreadAggregateBoolExp {
  bool_and: threadAggregateBoolExpBool_and
  bool_or: threadAggregateBoolExpBool_or
  count: threadAggregateBoolExpCount
}

"""
aggregate fields of "thread"
"""
type ThreadAggregateFields {
  avg: ThreadAvgFields
  count(columns: [ThreadSelectColumn!], distinct: Boolean): Int!
  max: ThreadMaxFields
  min: ThreadMinFields
  stddev: ThreadStddevFields
  stddevPop: ThreadStddevPopFields
  stddevSamp: ThreadStddevSampFields
  sum: ThreadSumFields
  varPop: ThreadVarPopFields
  varSamp: ThreadVarSampFields
  variance: ThreadVarianceFields
}

"""
order by aggregate values of table "thread"
"""
input ThreadAggregateOrderBy {
  avg: ThreadAvgOrderBy
  count: OrderBy
  max: ThreadMaxOrderBy
  min: ThreadMinOrderBy
  stddev: ThreadStddevOrderBy
  stddevPop: ThreadStddevPopOrderBy
  stddevSamp: ThreadStddevSampOrderBy
  sum: ThreadSumOrderBy
  varPop: ThreadVarPopOrderBy
  varSamp: ThreadVarSampOrderBy
  variance: ThreadVarianceOrderBy
}

"""
input type for inserting array relation for remote table "thread"
"""
input ThreadArrRelInsertInput {
  data: [ThreadInsertInput!]!

  """upsert condition"""
  onConflict: ThreadOnConflict
}

"""aggregate avg on columns"""
type ThreadAvgFields {
  chatbotId: Float
}

"""
order by avg() on columns of table "thread"
"""
input ThreadAvgOrderBy {
  chatbotId: OrderBy
}

"""
Boolean expression to filter rows from the table "thread". All fields are combined with a logical 'AND'.
"""
input ThreadBoolExp {
  _and: [ThreadBoolExp!]
  _not: ThreadBoolExp
  _or: [ThreadBoolExp!]
  chatbot: ChatbotBoolExp
  chatbotId: IntComparisonExp
  createdAt: TimestamptzComparisonExp
  isApproved: BooleanComparisonExp
  isBlocked: BooleanComparisonExp
  isPublic: BooleanComparisonExp
  messages: MessageBoolExp
  messagesAggregate: MessageAggregateBoolExp
  model: ModelsEnumEnumComparisonExp
  modelsEnum: ModelsEnumBoolExp
  threadId: UuidComparisonExp
  updatedAt: TimestamptzComparisonExp
  user: UserBoolExp
  userId: UuidComparisonExp
}

"""
unique or primary key constraints on table "thread"
"""
enum ThreadConstraint {
  """
  unique or primary key constraint on columns "thread_id"
  """
  thread_id_key

  """
  unique or primary key constraint on columns "thread_id"
  """
  thread_pkey
}

"""
input type for incrementing numeric columns in table "thread"
"""
input ThreadIncInput {
  chatbotId: Int
}

"""
input type for inserting data into table "thread"
"""
input ThreadInsertInput {
  chatbot: ChatbotObjRelInsertInput
  chatbotId: Int
  createdAt: timestamptz
  isApproved: Boolean
  isBlocked: Boolean
  isPublic: Boolean
  messages: MessageArrRelInsertInput
  model: ModelsEnumEnum
  modelsEnum: ModelsEnumObjRelInsertInput
  threadId: uuid
  updatedAt: timestamptz
  user: UserObjRelInsertInput
  userId: uuid
}

"""aggregate max on columns"""
type ThreadMaxFields {
  chatbotId: Int
  createdAt: timestamptz
  threadId: uuid
  updatedAt: timestamptz
  userId: uuid
}

"""
order by max() on columns of table "thread"
"""
input ThreadMaxOrderBy {
  chatbotId: OrderBy
  createdAt: OrderBy
  threadId: OrderBy
  updatedAt: OrderBy
  userId: OrderBy
}

"""aggregate min on columns"""
type ThreadMinFields {
  chatbotId: Int
  createdAt: timestamptz
  threadId: uuid
  updatedAt: timestamptz
  userId: uuid
}

"""
order by min() on columns of table "thread"
"""
input ThreadMinOrderBy {
  chatbotId: OrderBy
  createdAt: OrderBy
  threadId: OrderBy
  updatedAt: OrderBy
  userId: OrderBy
}

"""
response of any mutation on the table "thread"
"""
type ThreadMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Thread!]!
}

"""
input type for inserting object relation for remote table "thread"
"""
input ThreadObjRelInsertInput {
  data: ThreadInsertInput!

  """upsert condition"""
  onConflict: ThreadOnConflict
}

"""
on_conflict condition type for table "thread"
"""
input ThreadOnConflict {
  constraint: ThreadConstraint!
  updateColumns: [ThreadUpdateColumn!]! = []
  where: ThreadBoolExp
}

"""Ordering options when selecting data from "thread"."""
input ThreadOrderBy {
  chatbot: ChatbotOrderBy
  chatbotId: OrderBy
  createdAt: OrderBy
  isApproved: OrderBy
  isBlocked: OrderBy
  isPublic: OrderBy
  messagesAggregate: MessageAggregateOrderBy
  model: OrderBy
  modelsEnum: ModelsEnumOrderBy
  threadId: OrderBy
  updatedAt: OrderBy
  user: UserOrderBy
  userId: OrderBy
}

"""primary key columns input for table: thread"""
input ThreadPkColumnsInput {
  threadId: uuid!
}

"""
select columns of table "thread"
"""
enum ThreadSelectColumn {
  """column name"""
  chatbotId

  """column name"""
  createdAt

  """column name"""
  isApproved

  """column name"""
  isBlocked

  """column name"""
  isPublic

  """column name"""
  model

  """column name"""
  threadId

  """column name"""
  updatedAt

  """column name"""
  userId
}

"""
select "threadAggregateBoolExpBool_andArgumentsColumns" columns of table "thread"
"""
enum ThreadSelectColumnThreadAggregateBoolExpBool_andArgumentsColumns {
  """column name"""
  isApproved

  """column name"""
  isBlocked

  """column name"""
  isPublic
}

"""
select "threadAggregateBoolExpBool_orArgumentsColumns" columns of table "thread"
"""
enum ThreadSelectColumnThreadAggregateBoolExpBool_orArgumentsColumns {
  """column name"""
  isApproved

  """column name"""
  isBlocked

  """column name"""
  isPublic
}

"""
input type for updating data in table "thread"
"""
input ThreadSetInput {
  chatbotId: Int
  createdAt: timestamptz
  isApproved: Boolean
  isBlocked: Boolean
  isPublic: Boolean
  model: ModelsEnumEnum
  threadId: uuid
  updatedAt: timestamptz
  userId: uuid
}

"""aggregate stddev on columns"""
type ThreadStddevFields {
  chatbotId: Float
}

"""
order by stddev() on columns of table "thread"
"""
input ThreadStddevOrderBy {
  chatbotId: OrderBy
}

"""aggregate stddevPop on columns"""
type ThreadStddevPopFields {
  chatbotId: Float
}

"""
order by stddevPop() on columns of table "thread"
"""
input ThreadStddevPopOrderBy {
  chatbotId: OrderBy
}

"""aggregate stddevSamp on columns"""
type ThreadStddevSampFields {
  chatbotId: Float
}

"""
order by stddevSamp() on columns of table "thread"
"""
input ThreadStddevSampOrderBy {
  chatbotId: OrderBy
}

"""
Streaming cursor of the table "thread"
"""
input ThreadStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ThreadStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ThreadStreamCursorValueInput {
  chatbotId: Int
  createdAt: timestamptz
  isApproved: Boolean
  isBlocked: Boolean
  isPublic: Boolean
  model: ModelsEnumEnum
  threadId: uuid
  updatedAt: timestamptz
  userId: uuid
}

"""aggregate sum on columns"""
type ThreadSumFields {
  chatbotId: Int
}

"""
order by sum() on columns of table "thread"
"""
input ThreadSumOrderBy {
  chatbotId: OrderBy
}

"""
update columns of table "thread"
"""
enum ThreadUpdateColumn {
  """column name"""
  chatbotId

  """column name"""
  createdAt

  """column name"""
  isApproved

  """column name"""
  isBlocked

  """column name"""
  isPublic

  """column name"""
  model

  """column name"""
  threadId

  """column name"""
  updatedAt

  """column name"""
  userId
}

input ThreadUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: ThreadIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: ThreadSetInput

  """filter the rows which have to be updated"""
  where: ThreadBoolExp!
}

"""aggregate varPop on columns"""
type ThreadVarPopFields {
  chatbotId: Float
}

"""
order by varPop() on columns of table "thread"
"""
input ThreadVarPopOrderBy {
  chatbotId: OrderBy
}

"""aggregate varSamp on columns"""
type ThreadVarSampFields {
  chatbotId: Float
}

"""
order by varSamp() on columns of table "thread"
"""
input ThreadVarSampOrderBy {
  chatbotId: OrderBy
}

"""aggregate variance on columns"""
type ThreadVarianceFields {
  chatbotId: Float
}

"""
order by variance() on columns of table "thread"
"""
input ThreadVarianceOrderBy {
  chatbotId: OrderBy
}

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input TimestamptzComparisonExp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _isNull: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""Tokens OTP for reset password and activate account """
type Token {
  token: String!
  tokenExpiry: timestamptz!

  """An array relationship"""
  userTokens(
    """distinct select on columns"""
    distinctOn: [UserTokenSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [UserTokenOrderBy!]

    """filter the rows returned"""
    where: UserTokenBoolExp
  ): [UserToken!]!

  """An aggregate relationship"""
  userTokensAggregate(
    """distinct select on columns"""
    distinctOn: [UserTokenSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [UserTokenOrderBy!]

    """filter the rows returned"""
    where: UserTokenBoolExp
  ): UserTokenAggregate!
}

"""
aggregated selection of "token"
"""
type TokenAggregate {
  aggregate: TokenAggregateFields
  nodes: [Token!]!
}

"""
aggregate fields of "token"
"""
type TokenAggregateFields {
  count(columns: [TokenSelectColumn!], distinct: Boolean): Int!
  max: TokenMaxFields
  min: TokenMinFields
}

"""
Boolean expression to filter rows from the table "token". All fields are combined with a logical 'AND'.
"""
input TokenBoolExp {
  _and: [TokenBoolExp!]
  _not: TokenBoolExp
  _or: [TokenBoolExp!]
  token: StringComparisonExp
  tokenExpiry: TimestamptzComparisonExp
  userTokens: UserTokenBoolExp
  userTokensAggregate: UserTokenAggregateBoolExp
}

"""
unique or primary key constraints on table "token"
"""
enum TokenConstraint {
  """
  unique or primary key constraint on columns "token"
  """
  token_pkey
}

"""
input type for inserting data into table "token"
"""
input TokenInsertInput {
  token: String
  tokenExpiry: timestamptz
  userTokens: UserTokenArrRelInsertInput
}

"""aggregate max on columns"""
type TokenMaxFields {
  token: String
  tokenExpiry: timestamptz
}

"""aggregate min on columns"""
type TokenMinFields {
  token: String
  tokenExpiry: timestamptz
}

"""
response of any mutation on the table "token"
"""
type TokenMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Token!]!
}

"""
input type for inserting object relation for remote table "token"
"""
input TokenObjRelInsertInput {
  data: TokenInsertInput!

  """upsert condition"""
  onConflict: TokenOnConflict
}

"""
on_conflict condition type for table "token"
"""
input TokenOnConflict {
  constraint: TokenConstraint!
  updateColumns: [TokenUpdateColumn!]! = []
  where: TokenBoolExp
}

"""Ordering options when selecting data from "token"."""
input TokenOrderBy {
  token: OrderBy
  tokenExpiry: OrderBy
  userTokensAggregate: UserTokenAggregateOrderBy
}

"""primary key columns input for table: token"""
input TokenPkColumnsInput {
  token: String!
}

"""
select columns of table "token"
"""
enum TokenSelectColumn {
  """column name"""
  token

  """column name"""
  tokenExpiry
}

"""
input type for updating data in table "token"
"""
input TokenSetInput {
  token: String
  tokenExpiry: timestamptz
}

"""
Streaming cursor of the table "token"
"""
input TokenStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: TokenStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input TokenStreamCursorValueInput {
  token: String
  tokenExpiry: timestamptz
}

"""
update columns of table "token"
"""
enum TokenUpdateColumn {
  """column name"""
  token

  """column name"""
  tokenExpiry
}

input TokenUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: TokenSetInput

  """filter the rows which have to be updated"""
  where: TokenBoolExp!
}

"""
columns and relationships of "tone_enum"
"""
type ToneEnum {
  """An array relationship"""
  chatbots(
    """distinct select on columns"""
    distinctOn: [ChatbotSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotOrderBy!]

    """filter the rows returned"""
    where: ChatbotBoolExp
  ): [Chatbot!]!

  """An aggregate relationship"""
  chatbotsAggregate(
    """distinct select on columns"""
    distinctOn: [ChatbotSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotOrderBy!]

    """filter the rows returned"""
    where: ChatbotBoolExp
  ): ChatbotAggregate!

  """An array relationship"""
  preferences(
    """distinct select on columns"""
    distinctOn: [PreferenceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PreferenceOrderBy!]

    """filter the rows returned"""
    where: PreferenceBoolExp
  ): [Preference!]!

  """An aggregate relationship"""
  preferencesAggregate(
    """distinct select on columns"""
    distinctOn: [PreferenceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PreferenceOrderBy!]

    """filter the rows returned"""
    where: PreferenceBoolExp
  ): PreferenceAggregate!
  value: String!
}

"""
aggregated selection of "tone_enum"
"""
type ToneEnumAggregate {
  aggregate: ToneEnumAggregateFields
  nodes: [ToneEnum!]!
}

"""
aggregate fields of "tone_enum"
"""
type ToneEnumAggregateFields {
  count(columns: [ToneEnumSelectColumn!], distinct: Boolean): Int!
  max: ToneEnumMaxFields
  min: ToneEnumMinFields
}

"""
Boolean expression to filter rows from the table "tone_enum". All fields are combined with a logical 'AND'.
"""
input ToneEnumBoolExp {
  _and: [ToneEnumBoolExp!]
  _not: ToneEnumBoolExp
  _or: [ToneEnumBoolExp!]
  chatbots: ChatbotBoolExp
  chatbotsAggregate: ChatbotAggregateBoolExp
  preferences: PreferenceBoolExp
  preferencesAggregate: PreferenceAggregateBoolExp
  value: StringComparisonExp
}

"""
unique or primary key constraints on table "tone_enum"
"""
enum ToneEnumConstraint {
  """
  unique or primary key constraint on columns "value"
  """
  default_tone_enum_pkey
}

"""
input type for inserting data into table "tone_enum"
"""
input ToneEnumInsertInput {
  chatbots: ChatbotArrRelInsertInput
  preferences: PreferenceArrRelInsertInput
  value: String
}

"""aggregate max on columns"""
type ToneEnumMaxFields {
  value: String
}

"""aggregate min on columns"""
type ToneEnumMinFields {
  value: String
}

"""
response of any mutation on the table "tone_enum"
"""
type ToneEnumMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [ToneEnum!]!
}

"""
input type for inserting object relation for remote table "tone_enum"
"""
input ToneEnumObjRelInsertInput {
  data: ToneEnumInsertInput!

  """upsert condition"""
  onConflict: ToneEnumOnConflict
}

"""
on_conflict condition type for table "tone_enum"
"""
input ToneEnumOnConflict {
  constraint: ToneEnumConstraint!
  updateColumns: [ToneEnumUpdateColumn!]! = []
  where: ToneEnumBoolExp
}

"""Ordering options when selecting data from "tone_enum"."""
input ToneEnumOrderBy {
  chatbotsAggregate: ChatbotAggregateOrderBy
  preferencesAggregate: PreferenceAggregateOrderBy
  value: OrderBy
}

"""primary key columns input for table: tone_enum"""
input ToneEnumPkColumnsInput {
  value: String!
}

"""
select columns of table "tone_enum"
"""
enum ToneEnumSelectColumn {
  """column name"""
  value
}

"""
input type for updating data in table "tone_enum"
"""
input ToneEnumSetInput {
  value: String
}

"""
Streaming cursor of the table "tone_enum"
"""
input ToneEnumStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ToneEnumStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ToneEnumStreamCursorValueInput {
  value: String
}

"""
update columns of table "tone_enum"
"""
enum ToneEnumUpdateColumn {
  """column name"""
  value
}

input ToneEnumUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: ToneEnumSetInput

  """filter the rows which have to be updated"""
  where: ToneEnumBoolExp!
}

"""
columns and relationships of "type_enum"
"""
type TypeEnum {
  """An array relationship"""
  chatbots(
    """distinct select on columns"""
    distinctOn: [ChatbotSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotOrderBy!]

    """filter the rows returned"""
    where: ChatbotBoolExp
  ): [Chatbot!]!

  """An aggregate relationship"""
  chatbotsAggregate(
    """distinct select on columns"""
    distinctOn: [ChatbotSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotOrderBy!]

    """filter the rows returned"""
    where: ChatbotBoolExp
  ): ChatbotAggregate!

  """An array relationship"""
  preferences(
    """distinct select on columns"""
    distinctOn: [PreferenceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PreferenceOrderBy!]

    """filter the rows returned"""
    where: PreferenceBoolExp
  ): [Preference!]!

  """An aggregate relationship"""
  preferencesAggregate(
    """distinct select on columns"""
    distinctOn: [PreferenceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PreferenceOrderBy!]

    """filter the rows returned"""
    where: PreferenceBoolExp
  ): PreferenceAggregate!
  value: String!
}

"""
aggregated selection of "type_enum"
"""
type TypeEnumAggregate {
  aggregate: TypeEnumAggregateFields
  nodes: [TypeEnum!]!
}

"""
aggregate fields of "type_enum"
"""
type TypeEnumAggregateFields {
  count(columns: [TypeEnumSelectColumn!], distinct: Boolean): Int!
  max: TypeEnumMaxFields
  min: TypeEnumMinFields
}

"""
Boolean expression to filter rows from the table "type_enum". All fields are combined with a logical 'AND'.
"""
input TypeEnumBoolExp {
  _and: [TypeEnumBoolExp!]
  _not: TypeEnumBoolExp
  _or: [TypeEnumBoolExp!]
  chatbots: ChatbotBoolExp
  chatbotsAggregate: ChatbotAggregateBoolExp
  preferences: PreferenceBoolExp
  preferencesAggregate: PreferenceAggregateBoolExp
  value: StringComparisonExp
}

"""
unique or primary key constraints on table "type_enum"
"""
enum TypeEnumConstraint {
  """
  unique or primary key constraint on columns "value"
  """
  default_type_enum_pkey
}

"""
input type for inserting data into table "type_enum"
"""
input TypeEnumInsertInput {
  chatbots: ChatbotArrRelInsertInput
  preferences: PreferenceArrRelInsertInput
  value: String
}

"""aggregate max on columns"""
type TypeEnumMaxFields {
  value: String
}

"""aggregate min on columns"""
type TypeEnumMinFields {
  value: String
}

"""
response of any mutation on the table "type_enum"
"""
type TypeEnumMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [TypeEnum!]!
}

"""
input type for inserting object relation for remote table "type_enum"
"""
input TypeEnumObjRelInsertInput {
  data: TypeEnumInsertInput!

  """upsert condition"""
  onConflict: TypeEnumOnConflict
}

"""
on_conflict condition type for table "type_enum"
"""
input TypeEnumOnConflict {
  constraint: TypeEnumConstraint!
  updateColumns: [TypeEnumUpdateColumn!]! = []
  where: TypeEnumBoolExp
}

"""Ordering options when selecting data from "type_enum"."""
input TypeEnumOrderBy {
  chatbotsAggregate: ChatbotAggregateOrderBy
  preferencesAggregate: PreferenceAggregateOrderBy
  value: OrderBy
}

"""primary key columns input for table: type_enum"""
input TypeEnumPkColumnsInput {
  value: String!
}

"""
select columns of table "type_enum"
"""
enum TypeEnumSelectColumn {
  """column name"""
  value
}

"""
input type for updating data in table "type_enum"
"""
input TypeEnumSetInput {
  value: String
}

"""
Streaming cursor of the table "type_enum"
"""
input TypeEnumStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: TypeEnumStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input TypeEnumStreamCursorValueInput {
  value: String
}

"""
update columns of table "type_enum"
"""
enum TypeEnumUpdateColumn {
  """column name"""
  value
}

input TypeEnumUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: TypeEnumSetInput

  """filter the rows which have to be updated"""
  where: TypeEnumBoolExp!
}

"""Table storing information about registered users."""
type User {
  """An array relationship"""
  chats(
    """distinct select on columns"""
    distinctOn: [ChatSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatOrderBy!]

    """filter the rows returned"""
    where: ChatBoolExp
  ): [Chat!]!

  """An aggregate relationship"""
  chatsAggregate(
    """distinct select on columns"""
    distinctOn: [ChatSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatOrderBy!]

    """filter the rows returned"""
    where: ChatBoolExp
  ): ChatAggregate!
  dateJoined: timestamptz!
  email: String!

  """An array relationship"""
  followers(
    """distinct select on columns"""
    distinctOn: [SocialFollowingSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [SocialFollowingOrderBy!]

    """filter the rows returned"""
    where: SocialFollowingBoolExp
  ): [SocialFollowing!]!

  """An aggregate relationship"""
  followersAggregate(
    """distinct select on columns"""
    distinctOn: [SocialFollowingSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [SocialFollowingOrderBy!]

    """filter the rows returned"""
    where: SocialFollowingBoolExp
  ): SocialFollowingAggregate!

  """An array relationship"""
  following(
    """distinct select on columns"""
    distinctOn: [SocialFollowingSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [SocialFollowingOrderBy!]

    """filter the rows returned"""
    where: SocialFollowingBoolExp
  ): [SocialFollowing!]!

  """An aggregate relationship"""
  followingAggregate(
    """distinct select on columns"""
    distinctOn: [SocialFollowingSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [SocialFollowingOrderBy!]

    """filter the rows returned"""
    where: SocialFollowingBoolExp
  ): SocialFollowingAggregate!
  getFreeMonth: Boolean
  isBlocked: Boolean
  isVerified: Boolean
  lastLogin: timestamptz
  password: String!

  """An array relationship"""
  preferences(
    """distinct select on columns"""
    distinctOn: [PreferenceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PreferenceOrderBy!]

    """filter the rows returned"""
    where: PreferenceBoolExp
  ): [Preference!]!

  """An aggregate relationship"""
  preferencesAggregate(
    """distinct select on columns"""
    distinctOn: [PreferenceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PreferenceOrderBy!]

    """filter the rows returned"""
    where: PreferenceBoolExp
  ): PreferenceAggregate!
  proUserSubscriptionId: String!
  profilePicture: String

  """An array relationship"""
  prompts(
    """distinct select on columns"""
    distinctOn: [PromptUserSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptUserOrderBy!]

    """filter the rows returned"""
    where: PromptUserBoolExp
  ): [PromptUser!]!

  """An aggregate relationship"""
  promptsAggregate(
    """distinct select on columns"""
    distinctOn: [PromptUserSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptUserOrderBy!]

    """filter the rows returned"""
    where: PromptUserBoolExp
  ): PromptUserAggregate!

  """An array relationship"""
  referrals(
    """distinct select on columns"""
    distinctOn: [ReferralSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ReferralOrderBy!]

    """filter the rows returned"""
    where: ReferralBoolExp
  ): [Referral!]!

  """An aggregate relationship"""
  referralsAggregate(
    """distinct select on columns"""
    distinctOn: [ReferralSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ReferralOrderBy!]

    """filter the rows returned"""
    where: ReferralBoolExp
  ): ReferralAggregate!

  """An array relationship"""
  referralsByUserId(
    """distinct select on columns"""
    distinctOn: [ReferralSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ReferralOrderBy!]

    """filter the rows returned"""
    where: ReferralBoolExp
  ): [Referral!]!

  """An aggregate relationship"""
  referralsByUserIdAggregate(
    """distinct select on columns"""
    distinctOn: [ReferralSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ReferralOrderBy!]

    """filter the rows returned"""
    where: ReferralBoolExp
  ): ReferralAggregate!
  role: user_role!
  slug: String!

  """An array relationship"""
  threads(
    """distinct select on columns"""
    distinctOn: [ThreadSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ThreadOrderBy!]

    """filter the rows returned"""
    where: ThreadBoolExp
  ): [Thread!]!

  """An aggregate relationship"""
  threadsAggregate(
    """distinct select on columns"""
    distinctOn: [ThreadSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ThreadOrderBy!]

    """filter the rows returned"""
    where: ThreadBoolExp
  ): ThreadAggregate!
  userId: uuid!

  """An array relationship"""
  userTokens(
    """distinct select on columns"""
    distinctOn: [UserTokenSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [UserTokenOrderBy!]

    """filter the rows returned"""
    where: UserTokenBoolExp
  ): [UserToken!]!

  """An aggregate relationship"""
  userTokensAggregate(
    """distinct select on columns"""
    distinctOn: [UserTokenSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [UserTokenOrderBy!]

    """filter the rows returned"""
    where: UserTokenBoolExp
  ): UserTokenAggregate!
  username: String!
}

"""
aggregated selection of "user"
"""
type UserAggregate {
  aggregate: UserAggregateFields
  nodes: [User!]!
}

"""
aggregate fields of "user"
"""
type UserAggregateFields {
  count(columns: [UserSelectColumn!], distinct: Boolean): Int!
  max: UserMaxFields
  min: UserMinFields
}

"""
Boolean expression to filter rows from the table "user". All fields are combined with a logical 'AND'.
"""
input UserBoolExp {
  _and: [UserBoolExp!]
  _not: UserBoolExp
  _or: [UserBoolExp!]
  chats: ChatBoolExp
  chatsAggregate: ChatAggregateBoolExp
  dateJoined: TimestamptzComparisonExp
  email: StringComparisonExp
  followers: SocialFollowingBoolExp
  followersAggregate: SocialFollowingAggregateBoolExp
  following: SocialFollowingBoolExp
  followingAggregate: SocialFollowingAggregateBoolExp
  getFreeMonth: BooleanComparisonExp
  isBlocked: BooleanComparisonExp
  isVerified: BooleanComparisonExp
  lastLogin: TimestamptzComparisonExp
  password: StringComparisonExp
  preferences: PreferenceBoolExp
  preferencesAggregate: PreferenceAggregateBoolExp
  proUserSubscriptionId: StringComparisonExp
  profilePicture: StringComparisonExp
  prompts: PromptUserBoolExp
  promptsAggregate: PromptUserAggregateBoolExp
  referrals: ReferralBoolExp
  referralsAggregate: ReferralAggregateBoolExp
  referralsByUserId: ReferralBoolExp
  referralsByUserIdAggregate: ReferralAggregateBoolExp
  role: UserRoleComparisonExp
  slug: StringComparisonExp
  threads: ThreadBoolExp
  threadsAggregate: ThreadAggregateBoolExp
  userId: UuidComparisonExp
  userTokens: UserTokenBoolExp
  userTokensAggregate: UserTokenAggregateBoolExp
  username: StringComparisonExp
}

"""
unique or primary key constraints on table "user"
"""
enum UserConstraint {
  """
  unique or primary key constraint on columns "slug"
  """
  unique_slug

  """
  unique or primary key constraint on columns "email"
  """
  user_email_key

  """
  unique or primary key constraint on columns "user_id"
  """
  user_pkey

  """
  unique or primary key constraint on columns "username"
  """
  user_username_key
}

"""
input type for inserting data into table "user"
"""
input UserInsertInput {
  chats: ChatArrRelInsertInput
  dateJoined: timestamptz
  email: String
  followers: SocialFollowingArrRelInsertInput
  following: SocialFollowingArrRelInsertInput
  getFreeMonth: Boolean
  isBlocked: Boolean
  isVerified: Boolean
  lastLogin: timestamptz
  password: String
  preferences: PreferenceArrRelInsertInput
  proUserSubscriptionId: String
  profilePicture: String
  prompts: PromptUserArrRelInsertInput
  referrals: ReferralArrRelInsertInput
  referralsByUserId: ReferralArrRelInsertInput
  role: user_role
  slug: String
  threads: ThreadArrRelInsertInput
  userId: uuid
  userTokens: UserTokenArrRelInsertInput
  username: String
}

"""aggregate max on columns"""
type UserMaxFields {
  dateJoined: timestamptz
  email: String
  lastLogin: timestamptz
  password: String
  proUserSubscriptionId: String
  profilePicture: String
  role: user_role
  slug: String
  userId: uuid
  username: String
}

"""aggregate min on columns"""
type UserMinFields {
  dateJoined: timestamptz
  email: String
  lastLogin: timestamptz
  password: String
  proUserSubscriptionId: String
  profilePicture: String
  role: user_role
  slug: String
  userId: uuid
  username: String
}

"""
response of any mutation on the table "user"
"""
type UserMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [User!]!
}

"""
input type for inserting object relation for remote table "user"
"""
input UserObjRelInsertInput {
  data: UserInsertInput!

  """upsert condition"""
  onConflict: UserOnConflict
}

"""
on_conflict condition type for table "user"
"""
input UserOnConflict {
  constraint: UserConstraint!
  updateColumns: [UserUpdateColumn!]! = []
  where: UserBoolExp
}

"""Ordering options when selecting data from "user"."""
input UserOrderBy {
  chatsAggregate: ChatAggregateOrderBy
  dateJoined: OrderBy
  email: OrderBy
  followersAggregate: SocialFollowingAggregateOrderBy
  followingAggregate: SocialFollowingAggregateOrderBy
  getFreeMonth: OrderBy
  isBlocked: OrderBy
  isVerified: OrderBy
  lastLogin: OrderBy
  password: OrderBy
  preferencesAggregate: PreferenceAggregateOrderBy
  proUserSubscriptionId: OrderBy
  profilePicture: OrderBy
  promptsAggregate: PromptUserAggregateOrderBy
  referralsAggregate: ReferralAggregateOrderBy
  referralsByUserIdAggregate: ReferralAggregateOrderBy
  role: OrderBy
  slug: OrderBy
  threadsAggregate: ThreadAggregateOrderBy
  userId: OrderBy
  userTokensAggregate: UserTokenAggregateOrderBy
  username: OrderBy
}

"""primary key columns input for table: user"""
input UserPkColumnsInput {
  userId: uuid!
}

"""
Boolean expression to compare columns of type "user_role". All fields are combined with logical 'AND'.
"""
input UserRoleComparisonExp {
  _eq: user_role
  _gt: user_role
  _gte: user_role
  _in: [user_role!]
  _isNull: Boolean
  _lt: user_role
  _lte: user_role
  _neq: user_role
  _nin: [user_role!]
}

"""
select columns of table "user"
"""
enum UserSelectColumn {
  """column name"""
  dateJoined

  """column name"""
  email

  """column name"""
  getFreeMonth

  """column name"""
  isBlocked

  """column name"""
  isVerified

  """column name"""
  lastLogin

  """column name"""
  password

  """column name"""
  proUserSubscriptionId

  """column name"""
  profilePicture

  """column name"""
  role

  """column name"""
  slug

  """column name"""
  userId

  """column name"""
  username
}

"""
input type for updating data in table "user"
"""
input UserSetInput {
  dateJoined: timestamptz
  email: String
  getFreeMonth: Boolean
  isBlocked: Boolean
  isVerified: Boolean
  lastLogin: timestamptz
  password: String
  proUserSubscriptionId: String
  profilePicture: String
  role: user_role
  slug: String
  userId: uuid
  username: String
}

"""
Streaming cursor of the table "user"
"""
input UserStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: UserStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input UserStreamCursorValueInput {
  dateJoined: timestamptz
  email: String
  getFreeMonth: Boolean
  isBlocked: Boolean
  isVerified: Boolean
  lastLogin: timestamptz
  password: String
  proUserSubscriptionId: String
  profilePicture: String
  role: user_role
  slug: String
  userId: uuid
  username: String
}

"""user <> token relationship OTP (reset password/activate account) """
type UserToken {
  token: String!

  """An object relationship"""
  tokenByToken: Token!

  """An object relationship"""
  user: User!
  userId: uuid!
}

"""
aggregated selection of "user_token"
"""
type UserTokenAggregate {
  aggregate: UserTokenAggregateFields
  nodes: [UserToken!]!
}

input UserTokenAggregateBoolExp {
  count: userTokenAggregateBoolExpCount
}

"""
aggregate fields of "user_token"
"""
type UserTokenAggregateFields {
  count(columns: [UserTokenSelectColumn!], distinct: Boolean): Int!
  max: UserTokenMaxFields
  min: UserTokenMinFields
}

"""
order by aggregate values of table "user_token"
"""
input UserTokenAggregateOrderBy {
  count: OrderBy
  max: UserTokenMaxOrderBy
  min: UserTokenMinOrderBy
}

"""
input type for inserting array relation for remote table "user_token"
"""
input UserTokenArrRelInsertInput {
  data: [UserTokenInsertInput!]!

  """upsert condition"""
  onConflict: UserTokenOnConflict
}

"""
Boolean expression to filter rows from the table "user_token". All fields are combined with a logical 'AND'.
"""
input UserTokenBoolExp {
  _and: [UserTokenBoolExp!]
  _not: UserTokenBoolExp
  _or: [UserTokenBoolExp!]
  token: StringComparisonExp
  tokenByToken: TokenBoolExp
  user: UserBoolExp
  userId: UuidComparisonExp
}

"""
unique or primary key constraints on table "user_token"
"""
enum UserTokenConstraint {
  """
  unique or primary key constraint on columns "user_id", "token"
  """
  user_token_pkey
}

"""
input type for inserting data into table "user_token"
"""
input UserTokenInsertInput {
  token: String
  tokenByToken: TokenObjRelInsertInput
  user: UserObjRelInsertInput
  userId: uuid
}

"""aggregate max on columns"""
type UserTokenMaxFields {
  token: String
  userId: uuid
}

"""
order by max() on columns of table "user_token"
"""
input UserTokenMaxOrderBy {
  token: OrderBy
  userId: OrderBy
}

"""aggregate min on columns"""
type UserTokenMinFields {
  token: String
  userId: uuid
}

"""
order by min() on columns of table "user_token"
"""
input UserTokenMinOrderBy {
  token: OrderBy
  userId: OrderBy
}

"""
response of any mutation on the table "user_token"
"""
type UserTokenMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [UserToken!]!
}

"""
on_conflict condition type for table "user_token"
"""
input UserTokenOnConflict {
  constraint: UserTokenConstraint!
  updateColumns: [UserTokenUpdateColumn!]! = []
  where: UserTokenBoolExp
}

"""Ordering options when selecting data from "user_token"."""
input UserTokenOrderBy {
  token: OrderBy
  tokenByToken: TokenOrderBy
  user: UserOrderBy
  userId: OrderBy
}

"""primary key columns input for table: user_token"""
input UserTokenPkColumnsInput {
  token: String!
  userId: uuid!
}

"""
select columns of table "user_token"
"""
enum UserTokenSelectColumn {
  """column name"""
  token

  """column name"""
  userId
}

"""
input type for updating data in table "user_token"
"""
input UserTokenSetInput {
  token: String
  userId: uuid
}

"""
Streaming cursor of the table "user_token"
"""
input UserTokenStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: UserTokenStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input UserTokenStreamCursorValueInput {
  token: String
  userId: uuid
}

"""
update columns of table "user_token"
"""
enum UserTokenUpdateColumn {
  """column name"""
  token

  """column name"""
  userId
}

input UserTokenUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: UserTokenSetInput

  """filter the rows which have to be updated"""
  where: UserTokenBoolExp!
}

"""
update columns of table "user"
"""
enum UserUpdateColumn {
  """column name"""
  dateJoined

  """column name"""
  email

  """column name"""
  getFreeMonth

  """column name"""
  isBlocked

  """column name"""
  isVerified

  """column name"""
  lastLogin

  """column name"""
  password

  """column name"""
  proUserSubscriptionId

  """column name"""
  profilePicture

  """column name"""
  role

  """column name"""
  slug

  """column name"""
  userId

  """column name"""
  username
}

input UserUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: UserSetInput

  """filter the rows which have to be updated"""
  where: UserBoolExp!
}

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input UuidComparisonExp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _isNull: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

input chatAggregateBoolExpCount {
  arguments: [ChatSelectColumn!]
  distinct: Boolean
  filter: ChatBoolExp
  predicate: IntComparisonExp!
}

input chatbotAggregateBoolExpCount {
  arguments: [ChatbotSelectColumn!]
  distinct: Boolean
  filter: ChatbotBoolExp
  predicate: IntComparisonExp!
}

input chatbotCategoryAggregateBoolExpCount {
  arguments: [ChatbotCategorySelectColumn!]
  distinct: Boolean
  filter: ChatbotCategoryBoolExp
  predicate: IntComparisonExp!
}

input labelChatbotCategoryAggregateBoolExpCount {
  arguments: [LabelChatbotCategorySelectColumn!]
  distinct: Boolean
  filter: LabelChatbotCategoryBoolExp
  predicate: IntComparisonExp!
}

input messageAggregateBoolExpCount {
  arguments: [MessageSelectColumn!]
  distinct: Boolean
  filter: MessageBoolExp
  predicate: IntComparisonExp!
}

"""mutation root"""
type mutation_root {
  """
  delete data from the table: "category"
  """
  deleteCategory(
    """filter the rows which have to be deleted"""
    where: CategoryBoolExp!
  ): CategoryMutationResponse

  """
  delete single row from the table: "category"
  """
  deleteCategoryByPk(categoryId: Int!): Category

  """
  delete data from the table: "chat"
  """
  deleteChat(
    """filter the rows which have to be deleted"""
    where: ChatBoolExp!
  ): ChatMutationResponse

  """
  delete single row from the table: "chat"
  """
  deleteChatByPk(chatId: Int!): Chat

  """
  delete data from the table: "chatbot"
  """
  deleteChatbot(
    """filter the rows which have to be deleted"""
    where: ChatbotBoolExp!
  ): ChatbotMutationResponse

  """
  delete single row from the table: "chatbot"
  """
  deleteChatbotByPk(chatbotId: Int!): Chatbot

  """
  delete data from the table: "chatbot_category"
  """
  deleteChatbotCategory(
    """filter the rows which have to be deleted"""
    where: ChatbotCategoryBoolExp!
  ): ChatbotCategoryMutationResponse

  """
  delete single row from the table: "chatbot_category"
  """
  deleteChatbotCategoryByPk(categoryId: Int!, chatbotId: Int!): ChatbotCategory

  """
  delete data from the table: "complexity_enum"
  """
  deleteComplexityEnum(
    """filter the rows which have to be deleted"""
    where: ComplexityEnumBoolExp!
  ): ComplexityEnumMutationResponse

  """
  delete single row from the table: "complexity_enum"
  """
  deleteComplexityEnumByPk(value: String!): ComplexityEnum

  """
  delete data from the table: "label"
  """
  deleteLabel(
    """filter the rows which have to be deleted"""
    where: LabelBoolExp!
  ): LabelMutationResponse

  """
  delete single row from the table: "label"
  """
  deleteLabelByPk(labelId: Int!): Label

  """
  delete data from the table: "label_chatbot_category"
  """
  deleteLabelChatbotCategory(
    """filter the rows which have to be deleted"""
    where: LabelChatbotCategoryBoolExp!
  ): LabelChatbotCategoryMutationResponse

  """
  delete single row from the table: "label_chatbot_category"
  """
  deleteLabelChatbotCategoryByPk(categoryId: Int!, chatbotId: Int!, labelId: Int!): LabelChatbotCategory

  """
  delete data from the table: "length_enum"
  """
  deleteLengthEnum(
    """filter the rows which have to be deleted"""
    where: LengthEnumBoolExp!
  ): LengthEnumMutationResponse

  """
  delete single row from the table: "length_enum"
  """
  deleteLengthEnumByPk(value: String!): LengthEnum

  """
  delete data from the table: "message"
  """
  deleteMessage(
    """filter the rows which have to be deleted"""
    where: MessageBoolExp!
  ): MessageMutationResponse

  """
  delete single row from the table: "message"
  """
  deleteMessageByPk(messageId: uuid!): Message

  """
  delete data from the table: "message_type_enum"
  """
  deleteMessageTypeEnum(
    """filter the rows which have to be deleted"""
    where: MessageTypeEnumBoolExp!
  ): MessageTypeEnumMutationResponse

  """
  delete single row from the table: "message_type_enum"
  """
  deleteMessageTypeEnumByPk(value: String!): MessageTypeEnum

  """
  delete data from the table: "models_enum"
  """
  deleteModelsEnum(
    """filter the rows which have to be deleted"""
    where: ModelsEnumBoolExp!
  ): ModelsEnumMutationResponse

  """
  delete single row from the table: "models_enum"
  """
  deleteModelsEnumByPk(name: String!): ModelsEnum

  """
  delete data from the table: "preference"
  """
  deletePreference(
    """filter the rows which have to be deleted"""
    where: PreferenceBoolExp!
  ): PreferenceMutationResponse

  """
  delete single row from the table: "preference"
  """
  deletePreferenceByPk(preferenceId: Int!): Preference

  """
  delete data from the table: "prompt"
  """
  deletePrompt(
    """filter the rows which have to be deleted"""
    where: PromptBoolExp!
  ): PromptMutationResponse

  """
  delete single row from the table: "prompt"
  """
  deletePromptByPk(promptId: Int!): Prompt

  """
  delete data from the table: "prompt_chatbot"
  """
  deletePromptChatbot(
    """filter the rows which have to be deleted"""
    where: PromptChatbotBoolExp!
  ): PromptChatbotMutationResponse

  """
  delete single row from the table: "prompt_chatbot"
  """
  deletePromptChatbotByPk(chabotId: Int!, promptId: Int!): PromptChatbot

  """
  delete data from the table: "prompt_type_enum"
  """
  deletePromptTypeEnum(
    """filter the rows which have to be deleted"""
    where: PromptTypeEnumBoolExp!
  ): PromptTypeEnumMutationResponse

  """
  delete single row from the table: "prompt_type_enum"
  """
  deletePromptTypeEnumByPk(value: String!): PromptTypeEnum

  """
  delete data from the table: "prompt_user"
  """
  deletePromptUser(
    """filter the rows which have to be deleted"""
    where: PromptUserBoolExp!
  ): PromptUserMutationResponse

  """
  delete single row from the table: "prompt_user"
  """
  deletePromptUserByPk(promptId: Int!, userId: uuid!): PromptUser

  """
  delete data from the table: "referral"
  """
  deleteReferral(
    """filter the rows which have to be deleted"""
    where: ReferralBoolExp!
  ): ReferralMutationResponse

  """
  delete single row from the table: "referral"
  """
  deleteReferralByPk(referralCode: String!): Referral

  """
  delete data from the table: "social_following"
  """
  deleteSocialFollowing(
    """filter the rows which have to be deleted"""
    where: SocialFollowingBoolExp!
  ): SocialFollowingMutationResponse

  """
  delete data from the table: "thread"
  """
  deleteThread(
    """filter the rows which have to be deleted"""
    where: ThreadBoolExp!
  ): ThreadMutationResponse

  """
  delete single row from the table: "thread"
  """
  deleteThreadByPk(threadId: uuid!): Thread

  """
  delete data from the table: "token"
  """
  deleteToken(
    """filter the rows which have to be deleted"""
    where: TokenBoolExp!
  ): TokenMutationResponse

  """
  delete single row from the table: "token"
  """
  deleteTokenByPk(token: String!): Token

  """
  delete data from the table: "tone_enum"
  """
  deleteToneEnum(
    """filter the rows which have to be deleted"""
    where: ToneEnumBoolExp!
  ): ToneEnumMutationResponse

  """
  delete single row from the table: "tone_enum"
  """
  deleteToneEnumByPk(value: String!): ToneEnum

  """
  delete data from the table: "type_enum"
  """
  deleteTypeEnum(
    """filter the rows which have to be deleted"""
    where: TypeEnumBoolExp!
  ): TypeEnumMutationResponse

  """
  delete single row from the table: "type_enum"
  """
  deleteTypeEnumByPk(value: String!): TypeEnum

  """
  delete data from the table: "user"
  """
  deleteUser(
    """filter the rows which have to be deleted"""
    where: UserBoolExp!
  ): UserMutationResponse

  """
  delete single row from the table: "user"
  """
  deleteUserByPk(userId: uuid!): User

  """
  delete data from the table: "user_token"
  """
  deleteUserToken(
    """filter the rows which have to be deleted"""
    where: UserTokenBoolExp!
  ): UserTokenMutationResponse

  """
  delete single row from the table: "user_token"
  """
  deleteUserTokenByPk(token: String!, userId: uuid!): UserToken

  """
  insert data into the table: "category"
  """
  insertCategory(
    """the rows to be inserted"""
    objects: [CategoryInsertInput!]!

    """upsert condition"""
    onConflict: CategoryOnConflict
  ): CategoryMutationResponse

  """
  insert a single row into the table: "category"
  """
  insertCategoryOne(
    """the row to be inserted"""
    object: CategoryInsertInput!

    """upsert condition"""
    onConflict: CategoryOnConflict
  ): Category

  """
  insert data into the table: "chat"
  """
  insertChat(
    """the rows to be inserted"""
    objects: [ChatInsertInput!]!

    """upsert condition"""
    onConflict: ChatOnConflict
  ): ChatMutationResponse

  """
  insert a single row into the table: "chat"
  """
  insertChatOne(
    """the row to be inserted"""
    object: ChatInsertInput!

    """upsert condition"""
    onConflict: ChatOnConflict
  ): Chat

  """
  insert data into the table: "chatbot"
  """
  insertChatbot(
    """the rows to be inserted"""
    objects: [ChatbotInsertInput!]!

    """upsert condition"""
    onConflict: ChatbotOnConflict
  ): ChatbotMutationResponse

  """
  insert data into the table: "chatbot_category"
  """
  insertChatbotCategory(
    """the rows to be inserted"""
    objects: [ChatbotCategoryInsertInput!]!

    """upsert condition"""
    onConflict: ChatbotCategoryOnConflict
  ): ChatbotCategoryMutationResponse

  """
  insert a single row into the table: "chatbot_category"
  """
  insertChatbotCategoryOne(
    """the row to be inserted"""
    object: ChatbotCategoryInsertInput!

    """upsert condition"""
    onConflict: ChatbotCategoryOnConflict
  ): ChatbotCategory

  """
  insert a single row into the table: "chatbot"
  """
  insertChatbotOne(
    """the row to be inserted"""
    object: ChatbotInsertInput!

    """upsert condition"""
    onConflict: ChatbotOnConflict
  ): Chatbot

  """
  insert data into the table: "complexity_enum"
  """
  insertComplexityEnum(
    """the rows to be inserted"""
    objects: [ComplexityEnumInsertInput!]!

    """upsert condition"""
    onConflict: ComplexityEnumOnConflict
  ): ComplexityEnumMutationResponse

  """
  insert a single row into the table: "complexity_enum"
  """
  insertComplexityEnumOne(
    """the row to be inserted"""
    object: ComplexityEnumInsertInput!

    """upsert condition"""
    onConflict: ComplexityEnumOnConflict
  ): ComplexityEnum

  """
  insert data into the table: "label"
  """
  insertLabel(
    """the rows to be inserted"""
    objects: [LabelInsertInput!]!

    """upsert condition"""
    onConflict: LabelOnConflict
  ): LabelMutationResponse

  """
  insert data into the table: "label_chatbot_category"
  """
  insertLabelChatbotCategory(
    """the rows to be inserted"""
    objects: [LabelChatbotCategoryInsertInput!]!

    """upsert condition"""
    onConflict: LabelChatbotCategoryOnConflict
  ): LabelChatbotCategoryMutationResponse

  """
  insert a single row into the table: "label_chatbot_category"
  """
  insertLabelChatbotCategoryOne(
    """the row to be inserted"""
    object: LabelChatbotCategoryInsertInput!

    """upsert condition"""
    onConflict: LabelChatbotCategoryOnConflict
  ): LabelChatbotCategory

  """
  insert a single row into the table: "label"
  """
  insertLabelOne(
    """the row to be inserted"""
    object: LabelInsertInput!

    """upsert condition"""
    onConflict: LabelOnConflict
  ): Label

  """
  insert data into the table: "length_enum"
  """
  insertLengthEnum(
    """the rows to be inserted"""
    objects: [LengthEnumInsertInput!]!

    """upsert condition"""
    onConflict: LengthEnumOnConflict
  ): LengthEnumMutationResponse

  """
  insert a single row into the table: "length_enum"
  """
  insertLengthEnumOne(
    """the row to be inserted"""
    object: LengthEnumInsertInput!

    """upsert condition"""
    onConflict: LengthEnumOnConflict
  ): LengthEnum

  """
  insert data into the table: "message"
  """
  insertMessage(
    """the rows to be inserted"""
    objects: [MessageInsertInput!]!

    """upsert condition"""
    onConflict: MessageOnConflict
  ): MessageMutationResponse

  """
  insert a single row into the table: "message"
  """
  insertMessageOne(
    """the row to be inserted"""
    object: MessageInsertInput!

    """upsert condition"""
    onConflict: MessageOnConflict
  ): Message

  """
  insert data into the table: "message_type_enum"
  """
  insertMessageTypeEnum(
    """the rows to be inserted"""
    objects: [MessageTypeEnumInsertInput!]!

    """upsert condition"""
    onConflict: MessageTypeEnumOnConflict
  ): MessageTypeEnumMutationResponse

  """
  insert a single row into the table: "message_type_enum"
  """
  insertMessageTypeEnumOne(
    """the row to be inserted"""
    object: MessageTypeEnumInsertInput!

    """upsert condition"""
    onConflict: MessageTypeEnumOnConflict
  ): MessageTypeEnum

  """
  insert data into the table: "models_enum"
  """
  insertModelsEnum(
    """the rows to be inserted"""
    objects: [ModelsEnumInsertInput!]!

    """upsert condition"""
    onConflict: ModelsEnumOnConflict
  ): ModelsEnumMutationResponse

  """
  insert a single row into the table: "models_enum"
  """
  insertModelsEnumOne(
    """the row to be inserted"""
    object: ModelsEnumInsertInput!

    """upsert condition"""
    onConflict: ModelsEnumOnConflict
  ): ModelsEnum

  """
  insert data into the table: "preference"
  """
  insertPreference(
    """the rows to be inserted"""
    objects: [PreferenceInsertInput!]!

    """upsert condition"""
    onConflict: PreferenceOnConflict
  ): PreferenceMutationResponse

  """
  insert a single row into the table: "preference"
  """
  insertPreferenceOne(
    """the row to be inserted"""
    object: PreferenceInsertInput!

    """upsert condition"""
    onConflict: PreferenceOnConflict
  ): Preference

  """
  insert data into the table: "prompt"
  """
  insertPrompt(
    """the rows to be inserted"""
    objects: [PromptInsertInput!]!

    """upsert condition"""
    onConflict: PromptOnConflict
  ): PromptMutationResponse

  """
  insert data into the table: "prompt_chatbot"
  """
  insertPromptChatbot(
    """the rows to be inserted"""
    objects: [PromptChatbotInsertInput!]!

    """upsert condition"""
    onConflict: PromptChatbotOnConflict
  ): PromptChatbotMutationResponse

  """
  insert a single row into the table: "prompt_chatbot"
  """
  insertPromptChatbotOne(
    """the row to be inserted"""
    object: PromptChatbotInsertInput!

    """upsert condition"""
    onConflict: PromptChatbotOnConflict
  ): PromptChatbot

  """
  insert a single row into the table: "prompt"
  """
  insertPromptOne(
    """the row to be inserted"""
    object: PromptInsertInput!

    """upsert condition"""
    onConflict: PromptOnConflict
  ): Prompt

  """
  insert data into the table: "prompt_type_enum"
  """
  insertPromptTypeEnum(
    """the rows to be inserted"""
    objects: [PromptTypeEnumInsertInput!]!

    """upsert condition"""
    onConflict: PromptTypeEnumOnConflict
  ): PromptTypeEnumMutationResponse

  """
  insert a single row into the table: "prompt_type_enum"
  """
  insertPromptTypeEnumOne(
    """the row to be inserted"""
    object: PromptTypeEnumInsertInput!

    """upsert condition"""
    onConflict: PromptTypeEnumOnConflict
  ): PromptTypeEnum

  """
  insert data into the table: "prompt_user"
  """
  insertPromptUser(
    """the rows to be inserted"""
    objects: [PromptUserInsertInput!]!

    """upsert condition"""
    onConflict: PromptUserOnConflict
  ): PromptUserMutationResponse

  """
  insert a single row into the table: "prompt_user"
  """
  insertPromptUserOne(
    """the row to be inserted"""
    object: PromptUserInsertInput!

    """upsert condition"""
    onConflict: PromptUserOnConflict
  ): PromptUser

  """
  insert data into the table: "referral"
  """
  insertReferral(
    """the rows to be inserted"""
    objects: [ReferralInsertInput!]!

    """upsert condition"""
    onConflict: ReferralOnConflict
  ): ReferralMutationResponse

  """
  insert a single row into the table: "referral"
  """
  insertReferralOne(
    """the row to be inserted"""
    object: ReferralInsertInput!

    """upsert condition"""
    onConflict: ReferralOnConflict
  ): Referral

  """
  insert data into the table: "social_following"
  """
  insertSocialFollowing(
    """the rows to be inserted"""
    objects: [SocialFollowingInsertInput!]!
  ): SocialFollowingMutationResponse

  """
  insert a single row into the table: "social_following"
  """
  insertSocialFollowingOne(
    """the row to be inserted"""
    object: SocialFollowingInsertInput!
  ): SocialFollowing

  """
  insert data into the table: "thread"
  """
  insertThread(
    """the rows to be inserted"""
    objects: [ThreadInsertInput!]!

    """upsert condition"""
    onConflict: ThreadOnConflict
  ): ThreadMutationResponse

  """
  insert a single row into the table: "thread"
  """
  insertThreadOne(
    """the row to be inserted"""
    object: ThreadInsertInput!

    """upsert condition"""
    onConflict: ThreadOnConflict
  ): Thread

  """
  insert data into the table: "token"
  """
  insertToken(
    """the rows to be inserted"""
    objects: [TokenInsertInput!]!

    """upsert condition"""
    onConflict: TokenOnConflict
  ): TokenMutationResponse

  """
  insert a single row into the table: "token"
  """
  insertTokenOne(
    """the row to be inserted"""
    object: TokenInsertInput!

    """upsert condition"""
    onConflict: TokenOnConflict
  ): Token

  """
  insert data into the table: "tone_enum"
  """
  insertToneEnum(
    """the rows to be inserted"""
    objects: [ToneEnumInsertInput!]!

    """upsert condition"""
    onConflict: ToneEnumOnConflict
  ): ToneEnumMutationResponse

  """
  insert a single row into the table: "tone_enum"
  """
  insertToneEnumOne(
    """the row to be inserted"""
    object: ToneEnumInsertInput!

    """upsert condition"""
    onConflict: ToneEnumOnConflict
  ): ToneEnum

  """
  insert data into the table: "type_enum"
  """
  insertTypeEnum(
    """the rows to be inserted"""
    objects: [TypeEnumInsertInput!]!

    """upsert condition"""
    onConflict: TypeEnumOnConflict
  ): TypeEnumMutationResponse

  """
  insert a single row into the table: "type_enum"
  """
  insertTypeEnumOne(
    """the row to be inserted"""
    object: TypeEnumInsertInput!

    """upsert condition"""
    onConflict: TypeEnumOnConflict
  ): TypeEnum

  """
  insert data into the table: "user"
  """
  insertUser(
    """the rows to be inserted"""
    objects: [UserInsertInput!]!

    """upsert condition"""
    onConflict: UserOnConflict
  ): UserMutationResponse

  """
  insert a single row into the table: "user"
  """
  insertUserOne(
    """the row to be inserted"""
    object: UserInsertInput!

    """upsert condition"""
    onConflict: UserOnConflict
  ): User

  """
  insert data into the table: "user_token"
  """
  insertUserToken(
    """the rows to be inserted"""
    objects: [UserTokenInsertInput!]!

    """upsert condition"""
    onConflict: UserTokenOnConflict
  ): UserTokenMutationResponse

  """
  insert a single row into the table: "user_token"
  """
  insertUserTokenOne(
    """the row to be inserted"""
    object: UserTokenInsertInput!

    """upsert condition"""
    onConflict: UserTokenOnConflict
  ): UserToken

  """
  update data of the table: "category"
  """
  updateCategory(
    """increments the numeric columns with given value of the filtered values"""
    _inc: CategoryIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: CategorySetInput

    """filter the rows which have to be updated"""
    where: CategoryBoolExp!
  ): CategoryMutationResponse

  """
  update single row of the table: "category"
  """
  updateCategoryByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: CategoryIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: CategorySetInput
    pkColumns: CategoryPkColumnsInput!
  ): Category

  """
  update multiples rows of table: "category"
  """
  updateCategoryMany(
    """updates to execute, in order"""
    updates: [CategoryUpdates!]!
  ): [CategoryMutationResponse]

  """
  update data of the table: "chat"
  """
  updateChat(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ChatIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: ChatSetInput

    """filter the rows which have to be updated"""
    where: ChatBoolExp!
  ): ChatMutationResponse

  """
  update single row of the table: "chat"
  """
  updateChatByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ChatIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: ChatSetInput
    pkColumns: ChatPkColumnsInput!
  ): Chat

  """
  update multiples rows of table: "chat"
  """
  updateChatMany(
    """updates to execute, in order"""
    updates: [ChatUpdates!]!
  ): [ChatMutationResponse]

  """
  update data of the table: "chatbot"
  """
  updateChatbot(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ChatbotIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: ChatbotSetInput

    """filter the rows which have to be updated"""
    where: ChatbotBoolExp!
  ): ChatbotMutationResponse

  """
  update single row of the table: "chatbot"
  """
  updateChatbotByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ChatbotIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: ChatbotSetInput
    pkColumns: ChatbotPkColumnsInput!
  ): Chatbot

  """
  update data of the table: "chatbot_category"
  """
  updateChatbotCategory(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ChatbotCategoryIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: ChatbotCategorySetInput

    """filter the rows which have to be updated"""
    where: ChatbotCategoryBoolExp!
  ): ChatbotCategoryMutationResponse

  """
  update single row of the table: "chatbot_category"
  """
  updateChatbotCategoryByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ChatbotCategoryIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: ChatbotCategorySetInput
    pkColumns: ChatbotCategoryPkColumnsInput!
  ): ChatbotCategory

  """
  update multiples rows of table: "chatbot_category"
  """
  updateChatbotCategoryMany(
    """updates to execute, in order"""
    updates: [ChatbotCategoryUpdates!]!
  ): [ChatbotCategoryMutationResponse]

  """
  update multiples rows of table: "chatbot"
  """
  updateChatbotMany(
    """updates to execute, in order"""
    updates: [ChatbotUpdates!]!
  ): [ChatbotMutationResponse]

  """
  update data of the table: "complexity_enum"
  """
  updateComplexityEnum(
    """sets the columns of the filtered rows to the given values"""
    _set: ComplexityEnumSetInput

    """filter the rows which have to be updated"""
    where: ComplexityEnumBoolExp!
  ): ComplexityEnumMutationResponse

  """
  update single row of the table: "complexity_enum"
  """
  updateComplexityEnumByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: ComplexityEnumSetInput
    pkColumns: ComplexityEnumPkColumnsInput!
  ): ComplexityEnum

  """
  update multiples rows of table: "complexity_enum"
  """
  updateComplexityEnumMany(
    """updates to execute, in order"""
    updates: [ComplexityEnumUpdates!]!
  ): [ComplexityEnumMutationResponse]

  """
  update data of the table: "label"
  """
  updateLabel(
    """increments the numeric columns with given value of the filtered values"""
    _inc: LabelIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: LabelSetInput

    """filter the rows which have to be updated"""
    where: LabelBoolExp!
  ): LabelMutationResponse

  """
  update single row of the table: "label"
  """
  updateLabelByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: LabelIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: LabelSetInput
    pkColumns: LabelPkColumnsInput!
  ): Label

  """
  update data of the table: "label_chatbot_category"
  """
  updateLabelChatbotCategory(
    """increments the numeric columns with given value of the filtered values"""
    _inc: LabelChatbotCategoryIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: LabelChatbotCategorySetInput

    """filter the rows which have to be updated"""
    where: LabelChatbotCategoryBoolExp!
  ): LabelChatbotCategoryMutationResponse

  """
  update single row of the table: "label_chatbot_category"
  """
  updateLabelChatbotCategoryByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: LabelChatbotCategoryIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: LabelChatbotCategorySetInput
    pkColumns: LabelChatbotCategoryPkColumnsInput!
  ): LabelChatbotCategory

  """
  update multiples rows of table: "label_chatbot_category"
  """
  updateLabelChatbotCategoryMany(
    """updates to execute, in order"""
    updates: [LabelChatbotCategoryUpdates!]!
  ): [LabelChatbotCategoryMutationResponse]

  """
  update multiples rows of table: "label"
  """
  updateLabelMany(
    """updates to execute, in order"""
    updates: [LabelUpdates!]!
  ): [LabelMutationResponse]

  """
  update data of the table: "length_enum"
  """
  updateLengthEnum(
    """sets the columns of the filtered rows to the given values"""
    _set: LengthEnumSetInput

    """filter the rows which have to be updated"""
    where: LengthEnumBoolExp!
  ): LengthEnumMutationResponse

  """
  update single row of the table: "length_enum"
  """
  updateLengthEnumByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: LengthEnumSetInput
    pkColumns: LengthEnumPkColumnsInput!
  ): LengthEnum

  """
  update multiples rows of table: "length_enum"
  """
  updateLengthEnumMany(
    """updates to execute, in order"""
    updates: [LengthEnumUpdates!]!
  ): [LengthEnumMutationResponse]

  """
  update data of the table: "message"
  """
  updateMessage(
    """sets the columns of the filtered rows to the given values"""
    _set: MessageSetInput

    """filter the rows which have to be updated"""
    where: MessageBoolExp!
  ): MessageMutationResponse

  """
  update single row of the table: "message"
  """
  updateMessageByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: MessageSetInput
    pkColumns: MessagePkColumnsInput!
  ): Message

  """
  update multiples rows of table: "message"
  """
  updateMessageMany(
    """updates to execute, in order"""
    updates: [MessageUpdates!]!
  ): [MessageMutationResponse]

  """
  update data of the table: "message_type_enum"
  """
  updateMessageTypeEnum(
    """sets the columns of the filtered rows to the given values"""
    _set: MessageTypeEnumSetInput

    """filter the rows which have to be updated"""
    where: MessageTypeEnumBoolExp!
  ): MessageTypeEnumMutationResponse

  """
  update single row of the table: "message_type_enum"
  """
  updateMessageTypeEnumByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: MessageTypeEnumSetInput
    pkColumns: MessageTypeEnumPkColumnsInput!
  ): MessageTypeEnum

  """
  update multiples rows of table: "message_type_enum"
  """
  updateMessageTypeEnumMany(
    """updates to execute, in order"""
    updates: [MessageTypeEnumUpdates!]!
  ): [MessageTypeEnumMutationResponse]

  """
  update data of the table: "models_enum"
  """
  updateModelsEnum(
    """sets the columns of the filtered rows to the given values"""
    _set: ModelsEnumSetInput

    """filter the rows which have to be updated"""
    where: ModelsEnumBoolExp!
  ): ModelsEnumMutationResponse

  """
  update single row of the table: "models_enum"
  """
  updateModelsEnumByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: ModelsEnumSetInput
    pkColumns: ModelsEnumPkColumnsInput!
  ): ModelsEnum

  """
  update multiples rows of table: "models_enum"
  """
  updateModelsEnumMany(
    """updates to execute, in order"""
    updates: [ModelsEnumUpdates!]!
  ): [ModelsEnumMutationResponse]

  """
  update data of the table: "preference"
  """
  updatePreference(
    """increments the numeric columns with given value of the filtered values"""
    _inc: PreferenceIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: PreferenceSetInput

    """filter the rows which have to be updated"""
    where: PreferenceBoolExp!
  ): PreferenceMutationResponse

  """
  update single row of the table: "preference"
  """
  updatePreferenceByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: PreferenceIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: PreferenceSetInput
    pkColumns: PreferencePkColumnsInput!
  ): Preference

  """
  update multiples rows of table: "preference"
  """
  updatePreferenceMany(
    """updates to execute, in order"""
    updates: [PreferenceUpdates!]!
  ): [PreferenceMutationResponse]

  """
  update data of the table: "prompt"
  """
  updatePrompt(
    """increments the numeric columns with given value of the filtered values"""
    _inc: PromptIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: PromptSetInput

    """filter the rows which have to be updated"""
    where: PromptBoolExp!
  ): PromptMutationResponse

  """
  update single row of the table: "prompt"
  """
  updatePromptByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: PromptIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: PromptSetInput
    pkColumns: PromptPkColumnsInput!
  ): Prompt

  """
  update data of the table: "prompt_chatbot"
  """
  updatePromptChatbot(
    """increments the numeric columns with given value of the filtered values"""
    _inc: PromptChatbotIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: PromptChatbotSetInput

    """filter the rows which have to be updated"""
    where: PromptChatbotBoolExp!
  ): PromptChatbotMutationResponse

  """
  update single row of the table: "prompt_chatbot"
  """
  updatePromptChatbotByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: PromptChatbotIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: PromptChatbotSetInput
    pkColumns: PromptChatbotPkColumnsInput!
  ): PromptChatbot

  """
  update multiples rows of table: "prompt_chatbot"
  """
  updatePromptChatbotMany(
    """updates to execute, in order"""
    updates: [PromptChatbotUpdates!]!
  ): [PromptChatbotMutationResponse]

  """
  update multiples rows of table: "prompt"
  """
  updatePromptMany(
    """updates to execute, in order"""
    updates: [PromptUpdates!]!
  ): [PromptMutationResponse]

  """
  update data of the table: "prompt_type_enum"
  """
  updatePromptTypeEnum(
    """sets the columns of the filtered rows to the given values"""
    _set: PromptTypeEnumSetInput

    """filter the rows which have to be updated"""
    where: PromptTypeEnumBoolExp!
  ): PromptTypeEnumMutationResponse

  """
  update single row of the table: "prompt_type_enum"
  """
  updatePromptTypeEnumByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: PromptTypeEnumSetInput
    pkColumns: PromptTypeEnumPkColumnsInput!
  ): PromptTypeEnum

  """
  update multiples rows of table: "prompt_type_enum"
  """
  updatePromptTypeEnumMany(
    """updates to execute, in order"""
    updates: [PromptTypeEnumUpdates!]!
  ): [PromptTypeEnumMutationResponse]

  """
  update data of the table: "prompt_user"
  """
  updatePromptUser(
    """increments the numeric columns with given value of the filtered values"""
    _inc: PromptUserIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: PromptUserSetInput

    """filter the rows which have to be updated"""
    where: PromptUserBoolExp!
  ): PromptUserMutationResponse

  """
  update single row of the table: "prompt_user"
  """
  updatePromptUserByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: PromptUserIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: PromptUserSetInput
    pkColumns: PromptUserPkColumnsInput!
  ): PromptUser

  """
  update multiples rows of table: "prompt_user"
  """
  updatePromptUserMany(
    """updates to execute, in order"""
    updates: [PromptUserUpdates!]!
  ): [PromptUserMutationResponse]

  """
  update data of the table: "referral"
  """
  updateReferral(
    """sets the columns of the filtered rows to the given values"""
    _set: ReferralSetInput

    """filter the rows which have to be updated"""
    where: ReferralBoolExp!
  ): ReferralMutationResponse

  """
  update single row of the table: "referral"
  """
  updateReferralByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: ReferralSetInput
    pkColumns: ReferralPkColumnsInput!
  ): Referral

  """
  update multiples rows of table: "referral"
  """
  updateReferralMany(
    """updates to execute, in order"""
    updates: [ReferralUpdates!]!
  ): [ReferralMutationResponse]

  """
  update data of the table: "social_following"
  """
  updateSocialFollowing(
    """sets the columns of the filtered rows to the given values"""
    _set: SocialFollowingSetInput

    """filter the rows which have to be updated"""
    where: SocialFollowingBoolExp!
  ): SocialFollowingMutationResponse

  """
  update multiples rows of table: "social_following"
  """
  updateSocialFollowingMany(
    """updates to execute, in order"""
    updates: [SocialFollowingUpdates!]!
  ): [SocialFollowingMutationResponse]

  """
  update data of the table: "thread"
  """
  updateThread(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ThreadIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: ThreadSetInput

    """filter the rows which have to be updated"""
    where: ThreadBoolExp!
  ): ThreadMutationResponse

  """
  update single row of the table: "thread"
  """
  updateThreadByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ThreadIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: ThreadSetInput
    pkColumns: ThreadPkColumnsInput!
  ): Thread

  """
  update multiples rows of table: "thread"
  """
  updateThreadMany(
    """updates to execute, in order"""
    updates: [ThreadUpdates!]!
  ): [ThreadMutationResponse]

  """
  update data of the table: "token"
  """
  updateToken(
    """sets the columns of the filtered rows to the given values"""
    _set: TokenSetInput

    """filter the rows which have to be updated"""
    where: TokenBoolExp!
  ): TokenMutationResponse

  """
  update single row of the table: "token"
  """
  updateTokenByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: TokenSetInput
    pkColumns: TokenPkColumnsInput!
  ): Token

  """
  update multiples rows of table: "token"
  """
  updateTokenMany(
    """updates to execute, in order"""
    updates: [TokenUpdates!]!
  ): [TokenMutationResponse]

  """
  update data of the table: "tone_enum"
  """
  updateToneEnum(
    """sets the columns of the filtered rows to the given values"""
    _set: ToneEnumSetInput

    """filter the rows which have to be updated"""
    where: ToneEnumBoolExp!
  ): ToneEnumMutationResponse

  """
  update single row of the table: "tone_enum"
  """
  updateToneEnumByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: ToneEnumSetInput
    pkColumns: ToneEnumPkColumnsInput!
  ): ToneEnum

  """
  update multiples rows of table: "tone_enum"
  """
  updateToneEnumMany(
    """updates to execute, in order"""
    updates: [ToneEnumUpdates!]!
  ): [ToneEnumMutationResponse]

  """
  update data of the table: "type_enum"
  """
  updateTypeEnum(
    """sets the columns of the filtered rows to the given values"""
    _set: TypeEnumSetInput

    """filter the rows which have to be updated"""
    where: TypeEnumBoolExp!
  ): TypeEnumMutationResponse

  """
  update single row of the table: "type_enum"
  """
  updateTypeEnumByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: TypeEnumSetInput
    pkColumns: TypeEnumPkColumnsInput!
  ): TypeEnum

  """
  update multiples rows of table: "type_enum"
  """
  updateTypeEnumMany(
    """updates to execute, in order"""
    updates: [TypeEnumUpdates!]!
  ): [TypeEnumMutationResponse]

  """
  update data of the table: "user"
  """
  updateUser(
    """sets the columns of the filtered rows to the given values"""
    _set: UserSetInput

    """filter the rows which have to be updated"""
    where: UserBoolExp!
  ): UserMutationResponse

  """
  update single row of the table: "user"
  """
  updateUserByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: UserSetInput
    pkColumns: UserPkColumnsInput!
  ): User

  """
  update multiples rows of table: "user"
  """
  updateUserMany(
    """updates to execute, in order"""
    updates: [UserUpdates!]!
  ): [UserMutationResponse]

  """
  update data of the table: "user_token"
  """
  updateUserToken(
    """sets the columns of the filtered rows to the given values"""
    _set: UserTokenSetInput

    """filter the rows which have to be updated"""
    where: UserTokenBoolExp!
  ): UserTokenMutationResponse

  """
  update single row of the table: "user_token"
  """
  updateUserTokenByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: UserTokenSetInput
    pkColumns: UserTokenPkColumnsInput!
  ): UserToken

  """
  update multiples rows of table: "user_token"
  """
  updateUserTokenMany(
    """updates to execute, in order"""
    updates: [UserTokenUpdates!]!
  ): [UserTokenMutationResponse]
}

input preferenceAggregateBoolExpBool_and {
  arguments: PreferenceSelectColumnPreferenceAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: PreferenceBoolExp
  predicate: BooleanComparisonExp!
}

input preferenceAggregateBoolExpBool_or {
  arguments: PreferenceSelectColumnPreferenceAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: PreferenceBoolExp
  predicate: BooleanComparisonExp!
}

input preferenceAggregateBoolExpCount {
  arguments: [PreferenceSelectColumn!]
  distinct: Boolean
  filter: PreferenceBoolExp
  predicate: IntComparisonExp!
}

input promptAggregateBoolExpCount {
  arguments: [PromptSelectColumn!]
  distinct: Boolean
  filter: PromptBoolExp
  predicate: IntComparisonExp!
}

input promptChatbotAggregateBoolExpCount {
  arguments: [PromptChatbotSelectColumn!]
  distinct: Boolean
  filter: PromptChatbotBoolExp
  predicate: IntComparisonExp!
}

input promptUserAggregateBoolExpCount {
  arguments: [PromptUserSelectColumn!]
  distinct: Boolean
  filter: PromptUserBoolExp
  predicate: IntComparisonExp!
}

type query_root {
  """
  fetch data from the table: "category"
  """
  category(
    """distinct select on columns"""
    distinctOn: [CategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CategoryOrderBy!]

    """filter the rows returned"""
    where: CategoryBoolExp
  ): [Category!]!

  """
  fetch aggregated fields from the table: "category"
  """
  categoryAggregate(
    """distinct select on columns"""
    distinctOn: [CategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CategoryOrderBy!]

    """filter the rows returned"""
    where: CategoryBoolExp
  ): CategoryAggregate!

  """fetch data from the table: "category" using primary key columns"""
  categoryByPk(categoryId: Int!): Category

  """
  fetch data from the table: "chat"
  """
  chat(
    """distinct select on columns"""
    distinctOn: [ChatSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatOrderBy!]

    """filter the rows returned"""
    where: ChatBoolExp
  ): [Chat!]!

  """
  fetch aggregated fields from the table: "chat"
  """
  chatAggregate(
    """distinct select on columns"""
    distinctOn: [ChatSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatOrderBy!]

    """filter the rows returned"""
    where: ChatBoolExp
  ): ChatAggregate!

  """fetch data from the table: "chat" using primary key columns"""
  chatByPk(chatId: Int!): Chat

  """
  fetch data from the table: "chatbot"
  """
  chatbot(
    """distinct select on columns"""
    distinctOn: [ChatbotSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotOrderBy!]

    """filter the rows returned"""
    where: ChatbotBoolExp
  ): [Chatbot!]!

  """
  fetch aggregated fields from the table: "chatbot"
  """
  chatbotAggregate(
    """distinct select on columns"""
    distinctOn: [ChatbotSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotOrderBy!]

    """filter the rows returned"""
    where: ChatbotBoolExp
  ): ChatbotAggregate!

  """fetch data from the table: "chatbot" using primary key columns"""
  chatbotByPk(chatbotId: Int!): Chatbot

  """
  fetch data from the table: "chatbot_category"
  """
  chatbotCategory(
    """distinct select on columns"""
    distinctOn: [ChatbotCategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotCategoryOrderBy!]

    """filter the rows returned"""
    where: ChatbotCategoryBoolExp
  ): [ChatbotCategory!]!

  """
  fetch aggregated fields from the table: "chatbot_category"
  """
  chatbotCategoryAggregate(
    """distinct select on columns"""
    distinctOn: [ChatbotCategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotCategoryOrderBy!]

    """filter the rows returned"""
    where: ChatbotCategoryBoolExp
  ): ChatbotCategoryAggregate!

  """
  fetch data from the table: "chatbot_category" using primary key columns
  """
  chatbotCategoryByPk(categoryId: Int!, chatbotId: Int!): ChatbotCategory

  """
  fetch data from the table: "complexity_enum"
  """
  complexityEnum(
    """distinct select on columns"""
    distinctOn: [ComplexityEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ComplexityEnumOrderBy!]

    """filter the rows returned"""
    where: ComplexityEnumBoolExp
  ): [ComplexityEnum!]!

  """
  fetch aggregated fields from the table: "complexity_enum"
  """
  complexityEnumAggregate(
    """distinct select on columns"""
    distinctOn: [ComplexityEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ComplexityEnumOrderBy!]

    """filter the rows returned"""
    where: ComplexityEnumBoolExp
  ): ComplexityEnumAggregate!

  """fetch data from the table: "complexity_enum" using primary key columns"""
  complexityEnumByPk(value: String!): ComplexityEnum

  """
  fetch data from the table: "label"
  """
  label(
    """distinct select on columns"""
    distinctOn: [LabelSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [LabelOrderBy!]

    """filter the rows returned"""
    where: LabelBoolExp
  ): [Label!]!

  """
  fetch aggregated fields from the table: "label"
  """
  labelAggregate(
    """distinct select on columns"""
    distinctOn: [LabelSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [LabelOrderBy!]

    """filter the rows returned"""
    where: LabelBoolExp
  ): LabelAggregate!

  """fetch data from the table: "label" using primary key columns"""
  labelByPk(labelId: Int!): Label

  """
  fetch data from the table: "label_chatbot_category"
  """
  labelChatbotCategory(
    """distinct select on columns"""
    distinctOn: [LabelChatbotCategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [LabelChatbotCategoryOrderBy!]

    """filter the rows returned"""
    where: LabelChatbotCategoryBoolExp
  ): [LabelChatbotCategory!]!

  """
  fetch aggregated fields from the table: "label_chatbot_category"
  """
  labelChatbotCategoryAggregate(
    """distinct select on columns"""
    distinctOn: [LabelChatbotCategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [LabelChatbotCategoryOrderBy!]

    """filter the rows returned"""
    where: LabelChatbotCategoryBoolExp
  ): LabelChatbotCategoryAggregate!

  """
  fetch data from the table: "label_chatbot_category" using primary key columns
  """
  labelChatbotCategoryByPk(categoryId: Int!, chatbotId: Int!, labelId: Int!): LabelChatbotCategory

  """
  fetch data from the table: "length_enum"
  """
  lengthEnum(
    """distinct select on columns"""
    distinctOn: [LengthEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [LengthEnumOrderBy!]

    """filter the rows returned"""
    where: LengthEnumBoolExp
  ): [LengthEnum!]!

  """
  fetch aggregated fields from the table: "length_enum"
  """
  lengthEnumAggregate(
    """distinct select on columns"""
    distinctOn: [LengthEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [LengthEnumOrderBy!]

    """filter the rows returned"""
    where: LengthEnumBoolExp
  ): LengthEnumAggregate!

  """fetch data from the table: "length_enum" using primary key columns"""
  lengthEnumByPk(value: String!): LengthEnum

  """
  fetch data from the table: "message"
  """
  message(
    """distinct select on columns"""
    distinctOn: [MessageSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MessageOrderBy!]

    """filter the rows returned"""
    where: MessageBoolExp
  ): [Message!]!

  """
  fetch aggregated fields from the table: "message"
  """
  messageAggregate(
    """distinct select on columns"""
    distinctOn: [MessageSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MessageOrderBy!]

    """filter the rows returned"""
    where: MessageBoolExp
  ): MessageAggregate!

  """fetch data from the table: "message" using primary key columns"""
  messageByPk(messageId: uuid!): Message

  """
  fetch data from the table: "message_type_enum"
  """
  messageTypeEnum(
    """distinct select on columns"""
    distinctOn: [MessageTypeEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MessageTypeEnumOrderBy!]

    """filter the rows returned"""
    where: MessageTypeEnumBoolExp
  ): [MessageTypeEnum!]!

  """
  fetch aggregated fields from the table: "message_type_enum"
  """
  messageTypeEnumAggregate(
    """distinct select on columns"""
    distinctOn: [MessageTypeEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MessageTypeEnumOrderBy!]

    """filter the rows returned"""
    where: MessageTypeEnumBoolExp
  ): MessageTypeEnumAggregate!

  """
  fetch data from the table: "message_type_enum" using primary key columns
  """
  messageTypeEnumByPk(value: String!): MessageTypeEnum

  """
  fetch data from the table: "models_enum"
  """
  modelsEnum(
    """distinct select on columns"""
    distinctOn: [ModelsEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ModelsEnumOrderBy!]

    """filter the rows returned"""
    where: ModelsEnumBoolExp
  ): [ModelsEnum!]!

  """
  fetch aggregated fields from the table: "models_enum"
  """
  modelsEnumAggregate(
    """distinct select on columns"""
    distinctOn: [ModelsEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ModelsEnumOrderBy!]

    """filter the rows returned"""
    where: ModelsEnumBoolExp
  ): ModelsEnumAggregate!

  """fetch data from the table: "models_enum" using primary key columns"""
  modelsEnumByPk(name: String!): ModelsEnum

  """
  fetch data from the table: "preference"
  """
  preference(
    """distinct select on columns"""
    distinctOn: [PreferenceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PreferenceOrderBy!]

    """filter the rows returned"""
    where: PreferenceBoolExp
  ): [Preference!]!

  """
  fetch aggregated fields from the table: "preference"
  """
  preferenceAggregate(
    """distinct select on columns"""
    distinctOn: [PreferenceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PreferenceOrderBy!]

    """filter the rows returned"""
    where: PreferenceBoolExp
  ): PreferenceAggregate!

  """fetch data from the table: "preference" using primary key columns"""
  preferenceByPk(preferenceId: Int!): Preference

  """
  fetch data from the table: "prompt"
  """
  prompt(
    """distinct select on columns"""
    distinctOn: [PromptSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptOrderBy!]

    """filter the rows returned"""
    where: PromptBoolExp
  ): [Prompt!]!

  """
  fetch aggregated fields from the table: "prompt"
  """
  promptAggregate(
    """distinct select on columns"""
    distinctOn: [PromptSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptOrderBy!]

    """filter the rows returned"""
    where: PromptBoolExp
  ): PromptAggregate!

  """fetch data from the table: "prompt" using primary key columns"""
  promptByPk(promptId: Int!): Prompt

  """
  fetch data from the table: "prompt_chatbot"
  """
  promptChatbot(
    """distinct select on columns"""
    distinctOn: [PromptChatbotSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptChatbotOrderBy!]

    """filter the rows returned"""
    where: PromptChatbotBoolExp
  ): [PromptChatbot!]!

  """
  fetch aggregated fields from the table: "prompt_chatbot"
  """
  promptChatbotAggregate(
    """distinct select on columns"""
    distinctOn: [PromptChatbotSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptChatbotOrderBy!]

    """filter the rows returned"""
    where: PromptChatbotBoolExp
  ): PromptChatbotAggregate!

  """fetch data from the table: "prompt_chatbot" using primary key columns"""
  promptChatbotByPk(chabotId: Int!, promptId: Int!): PromptChatbot

  """
  fetch data from the table: "prompt_type_enum"
  """
  promptTypeEnum(
    """distinct select on columns"""
    distinctOn: [PromptTypeEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptTypeEnumOrderBy!]

    """filter the rows returned"""
    where: PromptTypeEnumBoolExp
  ): [PromptTypeEnum!]!

  """
  fetch aggregated fields from the table: "prompt_type_enum"
  """
  promptTypeEnumAggregate(
    """distinct select on columns"""
    distinctOn: [PromptTypeEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptTypeEnumOrderBy!]

    """filter the rows returned"""
    where: PromptTypeEnumBoolExp
  ): PromptTypeEnumAggregate!

  """
  fetch data from the table: "prompt_type_enum" using primary key columns
  """
  promptTypeEnumByPk(value: String!): PromptTypeEnum

  """
  fetch data from the table: "prompt_user"
  """
  promptUser(
    """distinct select on columns"""
    distinctOn: [PromptUserSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptUserOrderBy!]

    """filter the rows returned"""
    where: PromptUserBoolExp
  ): [PromptUser!]!

  """
  fetch aggregated fields from the table: "prompt_user"
  """
  promptUserAggregate(
    """distinct select on columns"""
    distinctOn: [PromptUserSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptUserOrderBy!]

    """filter the rows returned"""
    where: PromptUserBoolExp
  ): PromptUserAggregate!

  """fetch data from the table: "prompt_user" using primary key columns"""
  promptUserByPk(promptId: Int!, userId: uuid!): PromptUser

  """
  fetch data from the table: "referral"
  """
  referral(
    """distinct select on columns"""
    distinctOn: [ReferralSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ReferralOrderBy!]

    """filter the rows returned"""
    where: ReferralBoolExp
  ): [Referral!]!

  """
  fetch aggregated fields from the table: "referral"
  """
  referralAggregate(
    """distinct select on columns"""
    distinctOn: [ReferralSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ReferralOrderBy!]

    """filter the rows returned"""
    where: ReferralBoolExp
  ): ReferralAggregate!

  """fetch data from the table: "referral" using primary key columns"""
  referralByPk(referralCode: String!): Referral

  """
  fetch data from the table: "social_following"
  """
  socialFollowing(
    """distinct select on columns"""
    distinctOn: [SocialFollowingSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [SocialFollowingOrderBy!]

    """filter the rows returned"""
    where: SocialFollowingBoolExp
  ): [SocialFollowing!]!

  """
  fetch aggregated fields from the table: "social_following"
  """
  socialFollowingAggregate(
    """distinct select on columns"""
    distinctOn: [SocialFollowingSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [SocialFollowingOrderBy!]

    """filter the rows returned"""
    where: SocialFollowingBoolExp
  ): SocialFollowingAggregate!

  """
  fetch data from the table: "thread"
  """
  thread(
    """distinct select on columns"""
    distinctOn: [ThreadSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ThreadOrderBy!]

    """filter the rows returned"""
    where: ThreadBoolExp
  ): [Thread!]!

  """
  fetch aggregated fields from the table: "thread"
  """
  threadAggregate(
    """distinct select on columns"""
    distinctOn: [ThreadSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ThreadOrderBy!]

    """filter the rows returned"""
    where: ThreadBoolExp
  ): ThreadAggregate!

  """fetch data from the table: "thread" using primary key columns"""
  threadByPk(threadId: uuid!): Thread

  """
  fetch data from the table: "token"
  """
  token(
    """distinct select on columns"""
    distinctOn: [TokenSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TokenOrderBy!]

    """filter the rows returned"""
    where: TokenBoolExp
  ): [Token!]!

  """
  fetch aggregated fields from the table: "token"
  """
  tokenAggregate(
    """distinct select on columns"""
    distinctOn: [TokenSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TokenOrderBy!]

    """filter the rows returned"""
    where: TokenBoolExp
  ): TokenAggregate!

  """fetch data from the table: "token" using primary key columns"""
  tokenByPk(token: String!): Token

  """
  fetch data from the table: "tone_enum"
  """
  toneEnum(
    """distinct select on columns"""
    distinctOn: [ToneEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ToneEnumOrderBy!]

    """filter the rows returned"""
    where: ToneEnumBoolExp
  ): [ToneEnum!]!

  """
  fetch aggregated fields from the table: "tone_enum"
  """
  toneEnumAggregate(
    """distinct select on columns"""
    distinctOn: [ToneEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ToneEnumOrderBy!]

    """filter the rows returned"""
    where: ToneEnumBoolExp
  ): ToneEnumAggregate!

  """fetch data from the table: "tone_enum" using primary key columns"""
  toneEnumByPk(value: String!): ToneEnum

  """
  fetch data from the table: "type_enum"
  """
  typeEnum(
    """distinct select on columns"""
    distinctOn: [TypeEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TypeEnumOrderBy!]

    """filter the rows returned"""
    where: TypeEnumBoolExp
  ): [TypeEnum!]!

  """
  fetch aggregated fields from the table: "type_enum"
  """
  typeEnumAggregate(
    """distinct select on columns"""
    distinctOn: [TypeEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TypeEnumOrderBy!]

    """filter the rows returned"""
    where: TypeEnumBoolExp
  ): TypeEnumAggregate!

  """fetch data from the table: "type_enum" using primary key columns"""
  typeEnumByPk(value: String!): TypeEnum

  """
  fetch data from the table: "user"
  """
  user(
    """distinct select on columns"""
    distinctOn: [UserSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [UserOrderBy!]

    """filter the rows returned"""
    where: UserBoolExp
  ): [User!]!

  """
  fetch aggregated fields from the table: "user"
  """
  userAggregate(
    """distinct select on columns"""
    distinctOn: [UserSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [UserOrderBy!]

    """filter the rows returned"""
    where: UserBoolExp
  ): UserAggregate!

  """fetch data from the table: "user" using primary key columns"""
  userByPk(userId: uuid!): User

  """
  fetch data from the table: "user_token"
  """
  userToken(
    """distinct select on columns"""
    distinctOn: [UserTokenSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [UserTokenOrderBy!]

    """filter the rows returned"""
    where: UserTokenBoolExp
  ): [UserToken!]!

  """
  fetch aggregated fields from the table: "user_token"
  """
  userTokenAggregate(
    """distinct select on columns"""
    distinctOn: [UserTokenSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [UserTokenOrderBy!]

    """filter the rows returned"""
    where: UserTokenBoolExp
  ): UserTokenAggregate!

  """fetch data from the table: "user_token" using primary key columns"""
  userTokenByPk(token: String!, userId: uuid!): UserToken
}

input referralAggregateBoolExpCount {
  arguments: [ReferralSelectColumn!]
  distinct: Boolean
  filter: ReferralBoolExp
  predicate: IntComparisonExp!
}

input socialFollowingAggregateBoolExpCount {
  arguments: [SocialFollowingSelectColumn!]
  distinct: Boolean
  filter: SocialFollowingBoolExp
  predicate: IntComparisonExp!
}

type subscription_root {
  """
  fetch data from the table: "category"
  """
  category(
    """distinct select on columns"""
    distinctOn: [CategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CategoryOrderBy!]

    """filter the rows returned"""
    where: CategoryBoolExp
  ): [Category!]!

  """
  fetch aggregated fields from the table: "category"
  """
  categoryAggregate(
    """distinct select on columns"""
    distinctOn: [CategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CategoryOrderBy!]

    """filter the rows returned"""
    where: CategoryBoolExp
  ): CategoryAggregate!

  """fetch data from the table: "category" using primary key columns"""
  categoryByPk(categoryId: Int!): Category

  """
  fetch data from the table in a streaming manner: "category"
  """
  categoryStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [CategoryStreamCursorInput]!

    """filter the rows returned"""
    where: CategoryBoolExp
  ): [Category!]!

  """
  fetch data from the table: "chat"
  """
  chat(
    """distinct select on columns"""
    distinctOn: [ChatSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatOrderBy!]

    """filter the rows returned"""
    where: ChatBoolExp
  ): [Chat!]!

  """
  fetch aggregated fields from the table: "chat"
  """
  chatAggregate(
    """distinct select on columns"""
    distinctOn: [ChatSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatOrderBy!]

    """filter the rows returned"""
    where: ChatBoolExp
  ): ChatAggregate!

  """fetch data from the table: "chat" using primary key columns"""
  chatByPk(chatId: Int!): Chat

  """
  fetch data from the table in a streaming manner: "chat"
  """
  chatStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ChatStreamCursorInput]!

    """filter the rows returned"""
    where: ChatBoolExp
  ): [Chat!]!

  """
  fetch data from the table: "chatbot"
  """
  chatbot(
    """distinct select on columns"""
    distinctOn: [ChatbotSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotOrderBy!]

    """filter the rows returned"""
    where: ChatbotBoolExp
  ): [Chatbot!]!

  """
  fetch aggregated fields from the table: "chatbot"
  """
  chatbotAggregate(
    """distinct select on columns"""
    distinctOn: [ChatbotSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotOrderBy!]

    """filter the rows returned"""
    where: ChatbotBoolExp
  ): ChatbotAggregate!

  """fetch data from the table: "chatbot" using primary key columns"""
  chatbotByPk(chatbotId: Int!): Chatbot

  """
  fetch data from the table: "chatbot_category"
  """
  chatbotCategory(
    """distinct select on columns"""
    distinctOn: [ChatbotCategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotCategoryOrderBy!]

    """filter the rows returned"""
    where: ChatbotCategoryBoolExp
  ): [ChatbotCategory!]!

  """
  fetch aggregated fields from the table: "chatbot_category"
  """
  chatbotCategoryAggregate(
    """distinct select on columns"""
    distinctOn: [ChatbotCategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatbotCategoryOrderBy!]

    """filter the rows returned"""
    where: ChatbotCategoryBoolExp
  ): ChatbotCategoryAggregate!

  """
  fetch data from the table: "chatbot_category" using primary key columns
  """
  chatbotCategoryByPk(categoryId: Int!, chatbotId: Int!): ChatbotCategory

  """
  fetch data from the table in a streaming manner: "chatbot_category"
  """
  chatbotCategoryStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ChatbotCategoryStreamCursorInput]!

    """filter the rows returned"""
    where: ChatbotCategoryBoolExp
  ): [ChatbotCategory!]!

  """
  fetch data from the table in a streaming manner: "chatbot"
  """
  chatbotStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ChatbotStreamCursorInput]!

    """filter the rows returned"""
    where: ChatbotBoolExp
  ): [Chatbot!]!

  """
  fetch data from the table: "complexity_enum"
  """
  complexityEnum(
    """distinct select on columns"""
    distinctOn: [ComplexityEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ComplexityEnumOrderBy!]

    """filter the rows returned"""
    where: ComplexityEnumBoolExp
  ): [ComplexityEnum!]!

  """
  fetch aggregated fields from the table: "complexity_enum"
  """
  complexityEnumAggregate(
    """distinct select on columns"""
    distinctOn: [ComplexityEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ComplexityEnumOrderBy!]

    """filter the rows returned"""
    where: ComplexityEnumBoolExp
  ): ComplexityEnumAggregate!

  """fetch data from the table: "complexity_enum" using primary key columns"""
  complexityEnumByPk(value: String!): ComplexityEnum

  """
  fetch data from the table in a streaming manner: "complexity_enum"
  """
  complexityEnumStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ComplexityEnumStreamCursorInput]!

    """filter the rows returned"""
    where: ComplexityEnumBoolExp
  ): [ComplexityEnum!]!

  """
  fetch data from the table: "label"
  """
  label(
    """distinct select on columns"""
    distinctOn: [LabelSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [LabelOrderBy!]

    """filter the rows returned"""
    where: LabelBoolExp
  ): [Label!]!

  """
  fetch aggregated fields from the table: "label"
  """
  labelAggregate(
    """distinct select on columns"""
    distinctOn: [LabelSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [LabelOrderBy!]

    """filter the rows returned"""
    where: LabelBoolExp
  ): LabelAggregate!

  """fetch data from the table: "label" using primary key columns"""
  labelByPk(labelId: Int!): Label

  """
  fetch data from the table: "label_chatbot_category"
  """
  labelChatbotCategory(
    """distinct select on columns"""
    distinctOn: [LabelChatbotCategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [LabelChatbotCategoryOrderBy!]

    """filter the rows returned"""
    where: LabelChatbotCategoryBoolExp
  ): [LabelChatbotCategory!]!

  """
  fetch aggregated fields from the table: "label_chatbot_category"
  """
  labelChatbotCategoryAggregate(
    """distinct select on columns"""
    distinctOn: [LabelChatbotCategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [LabelChatbotCategoryOrderBy!]

    """filter the rows returned"""
    where: LabelChatbotCategoryBoolExp
  ): LabelChatbotCategoryAggregate!

  """
  fetch data from the table: "label_chatbot_category" using primary key columns
  """
  labelChatbotCategoryByPk(categoryId: Int!, chatbotId: Int!, labelId: Int!): LabelChatbotCategory

  """
  fetch data from the table in a streaming manner: "label_chatbot_category"
  """
  labelChatbotCategoryStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [LabelChatbotCategoryStreamCursorInput]!

    """filter the rows returned"""
    where: LabelChatbotCategoryBoolExp
  ): [LabelChatbotCategory!]!

  """
  fetch data from the table in a streaming manner: "label"
  """
  labelStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [LabelStreamCursorInput]!

    """filter the rows returned"""
    where: LabelBoolExp
  ): [Label!]!

  """
  fetch data from the table: "length_enum"
  """
  lengthEnum(
    """distinct select on columns"""
    distinctOn: [LengthEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [LengthEnumOrderBy!]

    """filter the rows returned"""
    where: LengthEnumBoolExp
  ): [LengthEnum!]!

  """
  fetch aggregated fields from the table: "length_enum"
  """
  lengthEnumAggregate(
    """distinct select on columns"""
    distinctOn: [LengthEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [LengthEnumOrderBy!]

    """filter the rows returned"""
    where: LengthEnumBoolExp
  ): LengthEnumAggregate!

  """fetch data from the table: "length_enum" using primary key columns"""
  lengthEnumByPk(value: String!): LengthEnum

  """
  fetch data from the table in a streaming manner: "length_enum"
  """
  lengthEnumStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [LengthEnumStreamCursorInput]!

    """filter the rows returned"""
    where: LengthEnumBoolExp
  ): [LengthEnum!]!

  """
  fetch data from the table: "message"
  """
  message(
    """distinct select on columns"""
    distinctOn: [MessageSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MessageOrderBy!]

    """filter the rows returned"""
    where: MessageBoolExp
  ): [Message!]!

  """
  fetch aggregated fields from the table: "message"
  """
  messageAggregate(
    """distinct select on columns"""
    distinctOn: [MessageSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MessageOrderBy!]

    """filter the rows returned"""
    where: MessageBoolExp
  ): MessageAggregate!

  """fetch data from the table: "message" using primary key columns"""
  messageByPk(messageId: uuid!): Message

  """
  fetch data from the table in a streaming manner: "message"
  """
  messageStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [MessageStreamCursorInput]!

    """filter the rows returned"""
    where: MessageBoolExp
  ): [Message!]!

  """
  fetch data from the table: "message_type_enum"
  """
  messageTypeEnum(
    """distinct select on columns"""
    distinctOn: [MessageTypeEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MessageTypeEnumOrderBy!]

    """filter the rows returned"""
    where: MessageTypeEnumBoolExp
  ): [MessageTypeEnum!]!

  """
  fetch aggregated fields from the table: "message_type_enum"
  """
  messageTypeEnumAggregate(
    """distinct select on columns"""
    distinctOn: [MessageTypeEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MessageTypeEnumOrderBy!]

    """filter the rows returned"""
    where: MessageTypeEnumBoolExp
  ): MessageTypeEnumAggregate!

  """
  fetch data from the table: "message_type_enum" using primary key columns
  """
  messageTypeEnumByPk(value: String!): MessageTypeEnum

  """
  fetch data from the table in a streaming manner: "message_type_enum"
  """
  messageTypeEnumStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [MessageTypeEnumStreamCursorInput]!

    """filter the rows returned"""
    where: MessageTypeEnumBoolExp
  ): [MessageTypeEnum!]!

  """
  fetch data from the table: "models_enum"
  """
  modelsEnum(
    """distinct select on columns"""
    distinctOn: [ModelsEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ModelsEnumOrderBy!]

    """filter the rows returned"""
    where: ModelsEnumBoolExp
  ): [ModelsEnum!]!

  """
  fetch aggregated fields from the table: "models_enum"
  """
  modelsEnumAggregate(
    """distinct select on columns"""
    distinctOn: [ModelsEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ModelsEnumOrderBy!]

    """filter the rows returned"""
    where: ModelsEnumBoolExp
  ): ModelsEnumAggregate!

  """fetch data from the table: "models_enum" using primary key columns"""
  modelsEnumByPk(name: String!): ModelsEnum

  """
  fetch data from the table in a streaming manner: "models_enum"
  """
  modelsEnumStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ModelsEnumStreamCursorInput]!

    """filter the rows returned"""
    where: ModelsEnumBoolExp
  ): [ModelsEnum!]!

  """
  fetch data from the table: "preference"
  """
  preference(
    """distinct select on columns"""
    distinctOn: [PreferenceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PreferenceOrderBy!]

    """filter the rows returned"""
    where: PreferenceBoolExp
  ): [Preference!]!

  """
  fetch aggregated fields from the table: "preference"
  """
  preferenceAggregate(
    """distinct select on columns"""
    distinctOn: [PreferenceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PreferenceOrderBy!]

    """filter the rows returned"""
    where: PreferenceBoolExp
  ): PreferenceAggregate!

  """fetch data from the table: "preference" using primary key columns"""
  preferenceByPk(preferenceId: Int!): Preference

  """
  fetch data from the table in a streaming manner: "preference"
  """
  preferenceStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [PreferenceStreamCursorInput]!

    """filter the rows returned"""
    where: PreferenceBoolExp
  ): [Preference!]!

  """
  fetch data from the table: "prompt"
  """
  prompt(
    """distinct select on columns"""
    distinctOn: [PromptSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptOrderBy!]

    """filter the rows returned"""
    where: PromptBoolExp
  ): [Prompt!]!

  """
  fetch aggregated fields from the table: "prompt"
  """
  promptAggregate(
    """distinct select on columns"""
    distinctOn: [PromptSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptOrderBy!]

    """filter the rows returned"""
    where: PromptBoolExp
  ): PromptAggregate!

  """fetch data from the table: "prompt" using primary key columns"""
  promptByPk(promptId: Int!): Prompt

  """
  fetch data from the table: "prompt_chatbot"
  """
  promptChatbot(
    """distinct select on columns"""
    distinctOn: [PromptChatbotSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptChatbotOrderBy!]

    """filter the rows returned"""
    where: PromptChatbotBoolExp
  ): [PromptChatbot!]!

  """
  fetch aggregated fields from the table: "prompt_chatbot"
  """
  promptChatbotAggregate(
    """distinct select on columns"""
    distinctOn: [PromptChatbotSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptChatbotOrderBy!]

    """filter the rows returned"""
    where: PromptChatbotBoolExp
  ): PromptChatbotAggregate!

  """fetch data from the table: "prompt_chatbot" using primary key columns"""
  promptChatbotByPk(chabotId: Int!, promptId: Int!): PromptChatbot

  """
  fetch data from the table in a streaming manner: "prompt_chatbot"
  """
  promptChatbotStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [PromptChatbotStreamCursorInput]!

    """filter the rows returned"""
    where: PromptChatbotBoolExp
  ): [PromptChatbot!]!

  """
  fetch data from the table in a streaming manner: "prompt"
  """
  promptStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [PromptStreamCursorInput]!

    """filter the rows returned"""
    where: PromptBoolExp
  ): [Prompt!]!

  """
  fetch data from the table: "prompt_type_enum"
  """
  promptTypeEnum(
    """distinct select on columns"""
    distinctOn: [PromptTypeEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptTypeEnumOrderBy!]

    """filter the rows returned"""
    where: PromptTypeEnumBoolExp
  ): [PromptTypeEnum!]!

  """
  fetch aggregated fields from the table: "prompt_type_enum"
  """
  promptTypeEnumAggregate(
    """distinct select on columns"""
    distinctOn: [PromptTypeEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptTypeEnumOrderBy!]

    """filter the rows returned"""
    where: PromptTypeEnumBoolExp
  ): PromptTypeEnumAggregate!

  """
  fetch data from the table: "prompt_type_enum" using primary key columns
  """
  promptTypeEnumByPk(value: String!): PromptTypeEnum

  """
  fetch data from the table in a streaming manner: "prompt_type_enum"
  """
  promptTypeEnumStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [PromptTypeEnumStreamCursorInput]!

    """filter the rows returned"""
    where: PromptTypeEnumBoolExp
  ): [PromptTypeEnum!]!

  """
  fetch data from the table: "prompt_user"
  """
  promptUser(
    """distinct select on columns"""
    distinctOn: [PromptUserSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptUserOrderBy!]

    """filter the rows returned"""
    where: PromptUserBoolExp
  ): [PromptUser!]!

  """
  fetch aggregated fields from the table: "prompt_user"
  """
  promptUserAggregate(
    """distinct select on columns"""
    distinctOn: [PromptUserSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PromptUserOrderBy!]

    """filter the rows returned"""
    where: PromptUserBoolExp
  ): PromptUserAggregate!

  """fetch data from the table: "prompt_user" using primary key columns"""
  promptUserByPk(promptId: Int!, userId: uuid!): PromptUser

  """
  fetch data from the table in a streaming manner: "prompt_user"
  """
  promptUserStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [PromptUserStreamCursorInput]!

    """filter the rows returned"""
    where: PromptUserBoolExp
  ): [PromptUser!]!

  """
  fetch data from the table: "referral"
  """
  referral(
    """distinct select on columns"""
    distinctOn: [ReferralSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ReferralOrderBy!]

    """filter the rows returned"""
    where: ReferralBoolExp
  ): [Referral!]!

  """
  fetch aggregated fields from the table: "referral"
  """
  referralAggregate(
    """distinct select on columns"""
    distinctOn: [ReferralSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ReferralOrderBy!]

    """filter the rows returned"""
    where: ReferralBoolExp
  ): ReferralAggregate!

  """fetch data from the table: "referral" using primary key columns"""
  referralByPk(referralCode: String!): Referral

  """
  fetch data from the table in a streaming manner: "referral"
  """
  referralStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ReferralStreamCursorInput]!

    """filter the rows returned"""
    where: ReferralBoolExp
  ): [Referral!]!

  """
  fetch data from the table: "social_following"
  """
  socialFollowing(
    """distinct select on columns"""
    distinctOn: [SocialFollowingSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [SocialFollowingOrderBy!]

    """filter the rows returned"""
    where: SocialFollowingBoolExp
  ): [SocialFollowing!]!

  """
  fetch aggregated fields from the table: "social_following"
  """
  socialFollowingAggregate(
    """distinct select on columns"""
    distinctOn: [SocialFollowingSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [SocialFollowingOrderBy!]

    """filter the rows returned"""
    where: SocialFollowingBoolExp
  ): SocialFollowingAggregate!

  """
  fetch data from the table in a streaming manner: "social_following"
  """
  socialFollowingStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [SocialFollowingStreamCursorInput]!

    """filter the rows returned"""
    where: SocialFollowingBoolExp
  ): [SocialFollowing!]!

  """
  fetch data from the table: "thread"
  """
  thread(
    """distinct select on columns"""
    distinctOn: [ThreadSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ThreadOrderBy!]

    """filter the rows returned"""
    where: ThreadBoolExp
  ): [Thread!]!

  """
  fetch aggregated fields from the table: "thread"
  """
  threadAggregate(
    """distinct select on columns"""
    distinctOn: [ThreadSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ThreadOrderBy!]

    """filter the rows returned"""
    where: ThreadBoolExp
  ): ThreadAggregate!

  """fetch data from the table: "thread" using primary key columns"""
  threadByPk(threadId: uuid!): Thread

  """
  fetch data from the table in a streaming manner: "thread"
  """
  threadStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ThreadStreamCursorInput]!

    """filter the rows returned"""
    where: ThreadBoolExp
  ): [Thread!]!

  """
  fetch data from the table: "token"
  """
  token(
    """distinct select on columns"""
    distinctOn: [TokenSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TokenOrderBy!]

    """filter the rows returned"""
    where: TokenBoolExp
  ): [Token!]!

  """
  fetch aggregated fields from the table: "token"
  """
  tokenAggregate(
    """distinct select on columns"""
    distinctOn: [TokenSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TokenOrderBy!]

    """filter the rows returned"""
    where: TokenBoolExp
  ): TokenAggregate!

  """fetch data from the table: "token" using primary key columns"""
  tokenByPk(token: String!): Token

  """
  fetch data from the table in a streaming manner: "token"
  """
  tokenStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [TokenStreamCursorInput]!

    """filter the rows returned"""
    where: TokenBoolExp
  ): [Token!]!

  """
  fetch data from the table: "tone_enum"
  """
  toneEnum(
    """distinct select on columns"""
    distinctOn: [ToneEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ToneEnumOrderBy!]

    """filter the rows returned"""
    where: ToneEnumBoolExp
  ): [ToneEnum!]!

  """
  fetch aggregated fields from the table: "tone_enum"
  """
  toneEnumAggregate(
    """distinct select on columns"""
    distinctOn: [ToneEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ToneEnumOrderBy!]

    """filter the rows returned"""
    where: ToneEnumBoolExp
  ): ToneEnumAggregate!

  """fetch data from the table: "tone_enum" using primary key columns"""
  toneEnumByPk(value: String!): ToneEnum

  """
  fetch data from the table in a streaming manner: "tone_enum"
  """
  toneEnumStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ToneEnumStreamCursorInput]!

    """filter the rows returned"""
    where: ToneEnumBoolExp
  ): [ToneEnum!]!

  """
  fetch data from the table: "type_enum"
  """
  typeEnum(
    """distinct select on columns"""
    distinctOn: [TypeEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TypeEnumOrderBy!]

    """filter the rows returned"""
    where: TypeEnumBoolExp
  ): [TypeEnum!]!

  """
  fetch aggregated fields from the table: "type_enum"
  """
  typeEnumAggregate(
    """distinct select on columns"""
    distinctOn: [TypeEnumSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TypeEnumOrderBy!]

    """filter the rows returned"""
    where: TypeEnumBoolExp
  ): TypeEnumAggregate!

  """fetch data from the table: "type_enum" using primary key columns"""
  typeEnumByPk(value: String!): TypeEnum

  """
  fetch data from the table in a streaming manner: "type_enum"
  """
  typeEnumStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [TypeEnumStreamCursorInput]!

    """filter the rows returned"""
    where: TypeEnumBoolExp
  ): [TypeEnum!]!

  """
  fetch data from the table: "user"
  """
  user(
    """distinct select on columns"""
    distinctOn: [UserSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [UserOrderBy!]

    """filter the rows returned"""
    where: UserBoolExp
  ): [User!]!

  """
  fetch aggregated fields from the table: "user"
  """
  userAggregate(
    """distinct select on columns"""
    distinctOn: [UserSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [UserOrderBy!]

    """filter the rows returned"""
    where: UserBoolExp
  ): UserAggregate!

  """fetch data from the table: "user" using primary key columns"""
  userByPk(userId: uuid!): User

  """
  fetch data from the table in a streaming manner: "user"
  """
  userStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [UserStreamCursorInput]!

    """filter the rows returned"""
    where: UserBoolExp
  ): [User!]!

  """
  fetch data from the table: "user_token"
  """
  userToken(
    """distinct select on columns"""
    distinctOn: [UserTokenSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [UserTokenOrderBy!]

    """filter the rows returned"""
    where: UserTokenBoolExp
  ): [UserToken!]!

  """
  fetch aggregated fields from the table: "user_token"
  """
  userTokenAggregate(
    """distinct select on columns"""
    distinctOn: [UserTokenSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [UserTokenOrderBy!]

    """filter the rows returned"""
    where: UserTokenBoolExp
  ): UserTokenAggregate!

  """fetch data from the table: "user_token" using primary key columns"""
  userTokenByPk(token: String!, userId: uuid!): UserToken

  """
  fetch data from the table in a streaming manner: "user_token"
  """
  userTokenStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [UserTokenStreamCursorInput]!

    """filter the rows returned"""
    where: UserTokenBoolExp
  ): [UserToken!]!
}

input threadAggregateBoolExpBool_and {
  arguments: ThreadSelectColumnThreadAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: ThreadBoolExp
  predicate: BooleanComparisonExp!
}

input threadAggregateBoolExpBool_or {
  arguments: ThreadSelectColumnThreadAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: ThreadBoolExp
  predicate: BooleanComparisonExp!
}

input threadAggregateBoolExpCount {
  arguments: [ThreadSelectColumn!]
  distinct: Boolean
  filter: ThreadBoolExp
  predicate: IntComparisonExp!
}

scalar timestamptz

input userTokenAggregateBoolExpCount {
  arguments: [UserTokenSelectColumn!]
  distinct: Boolean
  filter: UserTokenBoolExp
  predicate: IntComparisonExp!
}

scalar user_role

scalar uuid