schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """measured in seconds"""
  ttl: Int! = 60

  """refresh the cache entry"""
  refresh: Boolean! = false
) on QUERY

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

"""Additional information for account restoration and for kyc"""
type accounts_information {
  account: String!
  email: String!
  id: uuid!
  newsletter_subscription: Boolean
  phone: String!
  recovery_partners(
    """JSON select path"""
    path: String
  ): jsonb

  """An object relationship"""
  reg_account: reg_accounts!
}

"""
aggregated selection of "accounts_information"
"""
type accounts_information_aggregate {
  aggregate: accounts_information_aggregate_fields
  nodes: [accounts_information!]!
}

input accounts_information_aggregate_bool_exp {
  bool_and: accounts_information_aggregate_bool_exp_bool_and
  bool_or: accounts_information_aggregate_bool_exp_bool_or
  count: accounts_information_aggregate_bool_exp_count
}

input accounts_information_aggregate_bool_exp_bool_and {
  arguments: accounts_information_select_column_accounts_information_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: accounts_information_bool_exp
  predicate: Boolean_comparison_exp!
}

input accounts_information_aggregate_bool_exp_bool_or {
  arguments: accounts_information_select_column_accounts_information_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: accounts_information_bool_exp
  predicate: Boolean_comparison_exp!
}

input accounts_information_aggregate_bool_exp_count {
  arguments: [accounts_information_select_column!]
  distinct: Boolean
  filter: accounts_information_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "accounts_information"
"""
type accounts_information_aggregate_fields {
  count(columns: [accounts_information_select_column!], distinct: Boolean): Int!
  max: accounts_information_max_fields
  min: accounts_information_min_fields
}

"""
order by aggregate values of table "accounts_information"
"""
input accounts_information_aggregate_order_by {
  count: order_by
  max: accounts_information_max_order_by
  min: accounts_information_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input accounts_information_append_input {
  recovery_partners: jsonb
}

"""
input type for inserting array relation for remote table "accounts_information"
"""
input accounts_information_arr_rel_insert_input {
  data: [accounts_information_insert_input!]!

  """upsert condition"""
  on_conflict: accounts_information_on_conflict
}

"""
Boolean expression to filter rows from the table "accounts_information". All fields are combined with a logical 'AND'.
"""
input accounts_information_bool_exp {
  _and: [accounts_information_bool_exp!]
  _not: accounts_information_bool_exp
  _or: [accounts_information_bool_exp!]
  account: String_comparison_exp
  email: String_comparison_exp
  id: uuid_comparison_exp
  newsletter_subscription: Boolean_comparison_exp
  phone: String_comparison_exp
  recovery_partners: jsonb_comparison_exp
  reg_account: reg_accounts_bool_exp
}

"""
unique or primary key constraints on table "accounts_information"
"""
enum accounts_information_constraint {
  """
  unique or primary key constraint on columns "account"
  """
  accounts_information_account_key

  """
  unique or primary key constraint on columns "id"
  """
  accounts_information_id_key

  """
  unique or primary key constraint on columns "account", "id"
  """
  accounts_information_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input accounts_information_delete_at_path_input {
  recovery_partners: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input accounts_information_delete_elem_input {
  recovery_partners: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input accounts_information_delete_key_input {
  recovery_partners: String
}

"""
input type for inserting data into table "accounts_information"
"""
input accounts_information_insert_input {
  account: String
  email: String
  id: uuid
  newsletter_subscription: Boolean
  phone: String
  recovery_partners: jsonb
  reg_account: reg_accounts_obj_rel_insert_input
}

"""aggregate max on columns"""
type accounts_information_max_fields {
  account: String
  email: String
  id: uuid
  phone: String
}

"""
order by max() on columns of table "accounts_information"
"""
input accounts_information_max_order_by {
  account: order_by
  email: order_by
  id: order_by
  phone: order_by
}

"""aggregate min on columns"""
type accounts_information_min_fields {
  account: String
  email: String
  id: uuid
  phone: String
}

"""
order by min() on columns of table "accounts_information"
"""
input accounts_information_min_order_by {
  account: order_by
  email: order_by
  id: order_by
  phone: order_by
}

"""
response of any mutation on the table "accounts_information"
"""
type accounts_information_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [accounts_information!]!
}

"""
input type for inserting object relation for remote table "accounts_information"
"""
input accounts_information_obj_rel_insert_input {
  data: accounts_information_insert_input!

  """upsert condition"""
  on_conflict: accounts_information_on_conflict
}

"""
on_conflict condition type for table "accounts_information"
"""
input accounts_information_on_conflict {
  constraint: accounts_information_constraint!
  update_columns: [accounts_information_update_column!]! = []
  where: accounts_information_bool_exp
}

"""Ordering options when selecting data from "accounts_information"."""
input accounts_information_order_by {
  account: order_by
  email: order_by
  id: order_by
  newsletter_subscription: order_by
  phone: order_by
  recovery_partners: order_by
  reg_account: reg_accounts_order_by
}

"""primary key columns input for table: accounts_information"""
input accounts_information_pk_columns_input {
  account: String!
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input accounts_information_prepend_input {
  recovery_partners: jsonb
}

"""
select columns of table "accounts_information"
"""
enum accounts_information_select_column {
  """column name"""
  account

  """column name"""
  email

  """column name"""
  id

  """column name"""
  newsletter_subscription

  """column name"""
  phone

  """column name"""
  recovery_partners
}

"""
select "accounts_information_aggregate_bool_exp_bool_and_arguments_columns" columns of table "accounts_information"
"""
enum accounts_information_select_column_accounts_information_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  newsletter_subscription
}

"""
select "accounts_information_aggregate_bool_exp_bool_or_arguments_columns" columns of table "accounts_information"
"""
enum accounts_information_select_column_accounts_information_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  newsletter_subscription
}

"""
input type for updating data in table "accounts_information"
"""
input accounts_information_set_input {
  account: String
  email: String
  id: uuid
  newsletter_subscription: Boolean
  phone: String
  recovery_partners: jsonb
}

"""
Streaming cursor of the table "accounts_information"
"""
input accounts_information_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: accounts_information_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input accounts_information_stream_cursor_value_input {
  account: String
  email: String
  id: uuid
  newsletter_subscription: Boolean
  phone: String
  recovery_partners: jsonb
}

"""
update columns of table "accounts_information"
"""
enum accounts_information_update_column {
  """column name"""
  account

  """column name"""
  email

  """column name"""
  id

  """column name"""
  newsletter_subscription

  """column name"""
  phone

  """column name"""
  recovery_partners
}

input accounts_information_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: accounts_information_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: accounts_information_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: accounts_information_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: accounts_information_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: accounts_information_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: accounts_information_set_input

  """filter the rows which have to be updated"""
  where: accounts_information_bool_exp!
}

input cancel_p2p_offer_input {
  cancelled_by: String!
  id: String!
}

input confirm_p2p_offer_input {
  buyer: String
  completed: Boolean
  id: String!
  seller: String
}

"""ordering argument of a cursor"""
enum cursor_ordering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

"""
columns and relationships of "devices"
"""
type devices {
  account: String!
  created_at: timestamptz
  cred_id: String!
  device_name: String!
  public_key: String!

  """An object relationship"""
  reg_account: reg_accounts!
}

"""
aggregated selection of "devices"
"""
type devices_aggregate {
  aggregate: devices_aggregate_fields
  nodes: [devices!]!
}

input devices_aggregate_bool_exp {
  count: devices_aggregate_bool_exp_count
}

input devices_aggregate_bool_exp_count {
  arguments: [devices_select_column!]
  distinct: Boolean
  filter: devices_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "devices"
"""
type devices_aggregate_fields {
  count(columns: [devices_select_column!], distinct: Boolean): Int!
  max: devices_max_fields
  min: devices_min_fields
}

"""
order by aggregate values of table "devices"
"""
input devices_aggregate_order_by {
  count: order_by
  max: devices_max_order_by
  min: devices_min_order_by
}

"""
input type for inserting array relation for remote table "devices"
"""
input devices_arr_rel_insert_input {
  data: [devices_insert_input!]!

  """upsert condition"""
  on_conflict: devices_on_conflict
}

"""
Boolean expression to filter rows from the table "devices". All fields are combined with a logical 'AND'.
"""
input devices_bool_exp {
  _and: [devices_bool_exp!]
  _not: devices_bool_exp
  _or: [devices_bool_exp!]
  account: String_comparison_exp
  created_at: timestamptz_comparison_exp
  cred_id: String_comparison_exp
  device_name: String_comparison_exp
  public_key: String_comparison_exp
  reg_account: reg_accounts_bool_exp
}

"""
unique or primary key constraints on table "devices"
"""
enum devices_constraint {
  """
  unique or primary key constraint on columns "cred_id"
  """
  devices_pkey
}

"""
input type for inserting data into table "devices"
"""
input devices_insert_input {
  account: String
  created_at: timestamptz
  cred_id: String
  device_name: String
  public_key: String
  reg_account: reg_accounts_obj_rel_insert_input
}

"""aggregate max on columns"""
type devices_max_fields {
  account: String
  created_at: timestamptz
  cred_id: String
  device_name: String
  public_key: String
}

"""
order by max() on columns of table "devices"
"""
input devices_max_order_by {
  account: order_by
  created_at: order_by
  cred_id: order_by
  device_name: order_by
  public_key: order_by
}

"""aggregate min on columns"""
type devices_min_fields {
  account: String
  created_at: timestamptz
  cred_id: String
  device_name: String
  public_key: String
}

"""
order by min() on columns of table "devices"
"""
input devices_min_order_by {
  account: order_by
  created_at: order_by
  cred_id: order_by
  device_name: order_by
  public_key: order_by
}

"""
response of any mutation on the table "devices"
"""
type devices_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [devices!]!
}

"""
on_conflict condition type for table "devices"
"""
input devices_on_conflict {
  constraint: devices_constraint!
  update_columns: [devices_update_column!]! = []
  where: devices_bool_exp
}

"""Ordering options when selecting data from "devices"."""
input devices_order_by {
  account: order_by
  created_at: order_by
  cred_id: order_by
  device_name: order_by
  public_key: order_by
  reg_account: reg_accounts_order_by
}

"""primary key columns input for table: devices"""
input devices_pk_columns_input {
  cred_id: String!
}

"""
select columns of table "devices"
"""
enum devices_select_column {
  """column name"""
  account

  """column name"""
  created_at

  """column name"""
  cred_id

  """column name"""
  device_name

  """column name"""
  public_key
}

"""
input type for updating data in table "devices"
"""
input devices_set_input {
  account: String
  created_at: timestamptz
  cred_id: String
  device_name: String
  public_key: String
}

"""
Streaming cursor of the table "devices"
"""
input devices_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: devices_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input devices_stream_cursor_value_input {
  account: String
  created_at: timestamptz
  cred_id: String
  device_name: String
  public_key: String
}

"""
update columns of table "devices"
"""
enum devices_update_column {
  """column name"""
  account

  """column name"""
  created_at

  """column name"""
  cred_id

  """column name"""
  device_name

  """column name"""
  public_key
}

input devices_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: devices_set_input

  """filter the rows which have to be updated"""
  where: devices_bool_exp!
}

scalar float8

"""
Boolean expression to compare columns of type "float8". All fields are combined with logical 'AND'.
"""
input float8_comparison_exp {
  _eq: float8
  _gt: float8
  _gte: float8
  _in: [float8!]
  _is_null: Boolean
  _lt: float8
  _lte: float8
  _neq: float8
  _nin: [float8!]
}

scalar jsonb

input jsonb_cast_exp {
  String: String_comparison_exp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  _cast: jsonb_cast_exp

  """is the column contained in the given json value"""
  _contained_in: jsonb

  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """does the string exist as a top-level key in the column"""
  _has_key: String

  """do all of these strings exist as top-level keys in the column"""
  _has_keys_all: [String!]

  """do any of these strings exist as top-level keys in the column"""
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

input make_p2p_buy_offer_input {
  amount: String!
  buyer: String!
  buyer_method_details: String
  method: String!
  region: String!
}

input make_p2p_sell_offer_input {
  amount: String!
  masterbotsbank_id: String!
  method: String!
  region: String!
  seller: String!
  seller_method_details: String
}

"""
columns and relationships of "messages"
"""
type messages {
  from: String!
  id: uuid!
  message: String!
  p2p_id: uuid

  """An object relationship"""
  p2p_offer: p2p_offers

  """An object relationship"""
  regAccountByTo: reg_accounts!

  """An object relationship"""
  reg_account: reg_accounts!
  support_id: uuid
  timestamp: timestamptz!
  to: String!
}

"""
aggregated selection of "messages"
"""
type messages_aggregate {
  aggregate: messages_aggregate_fields
  nodes: [messages!]!
}

input messages_aggregate_bool_exp {
  count: messages_aggregate_bool_exp_count
}

input messages_aggregate_bool_exp_count {
  arguments: [messages_select_column!]
  distinct: Boolean
  filter: messages_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "messages"
"""
type messages_aggregate_fields {
  count(columns: [messages_select_column!], distinct: Boolean): Int!
  max: messages_max_fields
  min: messages_min_fields
}

"""
order by aggregate values of table "messages"
"""
input messages_aggregate_order_by {
  count: order_by
  max: messages_max_order_by
  min: messages_min_order_by
}

"""
input type for inserting array relation for remote table "messages"
"""
input messages_arr_rel_insert_input {
  data: [messages_insert_input!]!

  """upsert condition"""
  on_conflict: messages_on_conflict
}

"""
Boolean expression to filter rows from the table "messages". All fields are combined with a logical 'AND'.
"""
input messages_bool_exp {
  _and: [messages_bool_exp!]
  _not: messages_bool_exp
  _or: [messages_bool_exp!]
  from: String_comparison_exp
  id: uuid_comparison_exp
  message: String_comparison_exp
  p2p_id: uuid_comparison_exp
  p2p_offer: p2p_offers_bool_exp
  regAccountByTo: reg_accounts_bool_exp
  reg_account: reg_accounts_bool_exp
  support_id: uuid_comparison_exp
  timestamp: timestamptz_comparison_exp
  to: String_comparison_exp
}

"""
unique or primary key constraints on table "messages"
"""
enum messages_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  messages_pkey
}

"""
input type for inserting data into table "messages"
"""
input messages_insert_input {
  from: String
  id: uuid
  message: String
  p2p_id: uuid
  p2p_offer: p2p_offers_obj_rel_insert_input
  regAccountByTo: reg_accounts_obj_rel_insert_input
  reg_account: reg_accounts_obj_rel_insert_input
  support_id: uuid
  timestamp: timestamptz
  to: String
}

"""aggregate max on columns"""
type messages_max_fields {
  from: String
  id: uuid
  message: String
  p2p_id: uuid
  support_id: uuid
  timestamp: timestamptz
  to: String
}

"""
order by max() on columns of table "messages"
"""
input messages_max_order_by {
  from: order_by
  id: order_by
  message: order_by
  p2p_id: order_by
  support_id: order_by
  timestamp: order_by
  to: order_by
}

"""aggregate min on columns"""
type messages_min_fields {
  from: String
  id: uuid
  message: String
  p2p_id: uuid
  support_id: uuid
  timestamp: timestamptz
  to: String
}

"""
order by min() on columns of table "messages"
"""
input messages_min_order_by {
  from: order_by
  id: order_by
  message: order_by
  p2p_id: order_by
  support_id: order_by
  timestamp: order_by
  to: order_by
}

"""
response of any mutation on the table "messages"
"""
type messages_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [messages!]!
}

"""
on_conflict condition type for table "messages"
"""
input messages_on_conflict {
  constraint: messages_constraint!
  update_columns: [messages_update_column!]! = []
  where: messages_bool_exp
}

"""Ordering options when selecting data from "messages"."""
input messages_order_by {
  from: order_by
  id: order_by
  message: order_by
  p2p_id: order_by
  p2p_offer: p2p_offers_order_by
  regAccountByTo: reg_accounts_order_by
  reg_account: reg_accounts_order_by
  support_id: order_by
  timestamp: order_by
  to: order_by
}

"""primary key columns input for table: messages"""
input messages_pk_columns_input {
  id: uuid!
}

"""
select columns of table "messages"
"""
enum messages_select_column {
  """column name"""
  from

  """column name"""
  id

  """column name"""
  message

  """column name"""
  p2p_id

  """column name"""
  support_id

  """column name"""
  timestamp

  """column name"""
  to
}

"""
input type for updating data in table "messages"
"""
input messages_set_input {
  from: String
  id: uuid
  message: String
  p2p_id: uuid
  support_id: uuid
  timestamp: timestamptz
  to: String
}

"""
Streaming cursor of the table "messages"
"""
input messages_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: messages_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input messages_stream_cursor_value_input {
  from: String
  id: uuid
  message: String
  p2p_id: uuid
  support_id: uuid
  timestamp: timestamptz
  to: String
}

"""
update columns of table "messages"
"""
enum messages_update_column {
  """column name"""
  from

  """column name"""
  id

  """column name"""
  message

  """column name"""
  p2p_id

  """column name"""
  support_id

  """column name"""
  timestamp

  """column name"""
  to
}

input messages_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: messages_set_input

  """filter the rows which have to be updated"""
  where: messages_bool_exp!
}

"""
columns and relationships of "migrate_device"
"""
type migrate_device {
  account: String!
  created_at: timestamptz
  cred_id: String!
  device_name: String!
  public_key: String!
}

"""
aggregated selection of "migrate_device"
"""
type migrate_device_aggregate {
  aggregate: migrate_device_aggregate_fields
  nodes: [migrate_device!]!
}

"""
aggregate fields of "migrate_device"
"""
type migrate_device_aggregate_fields {
  count(columns: [migrate_device_select_column!], distinct: Boolean): Int!
  max: migrate_device_max_fields
  min: migrate_device_min_fields
}

"""
Boolean expression to filter rows from the table "migrate_device". All fields are combined with a logical 'AND'.
"""
input migrate_device_bool_exp {
  _and: [migrate_device_bool_exp!]
  _not: migrate_device_bool_exp
  _or: [migrate_device_bool_exp!]
  account: String_comparison_exp
  created_at: timestamptz_comparison_exp
  cred_id: String_comparison_exp
  device_name: String_comparison_exp
  public_key: String_comparison_exp
}

"""
unique or primary key constraints on table "migrate_device"
"""
enum migrate_device_constraint {
  """
  unique or primary key constraint on columns "cred_id"
  """
  migrate_device_pkey
}

"""
input type for inserting data into table "migrate_device"
"""
input migrate_device_insert_input {
  account: String
  created_at: timestamptz
  cred_id: String
  device_name: String
  public_key: String
}

"""aggregate max on columns"""
type migrate_device_max_fields {
  account: String
  created_at: timestamptz
  cred_id: String
  device_name: String
  public_key: String
}

"""aggregate min on columns"""
type migrate_device_min_fields {
  account: String
  created_at: timestamptz
  cred_id: String
  device_name: String
  public_key: String
}

"""
response of any mutation on the table "migrate_device"
"""
type migrate_device_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [migrate_device!]!
}

"""
on_conflict condition type for table "migrate_device"
"""
input migrate_device_on_conflict {
  constraint: migrate_device_constraint!
  update_columns: [migrate_device_update_column!]! = []
  where: migrate_device_bool_exp
}

"""Ordering options when selecting data from "migrate_device"."""
input migrate_device_order_by {
  account: order_by
  created_at: order_by
  cred_id: order_by
  device_name: order_by
  public_key: order_by
}

"""primary key columns input for table: migrate_device"""
input migrate_device_pk_columns_input {
  cred_id: String!
}

"""
select columns of table "migrate_device"
"""
enum migrate_device_select_column {
  """column name"""
  account

  """column name"""
  created_at

  """column name"""
  cred_id

  """column name"""
  device_name

  """column name"""
  public_key
}

"""
input type for updating data in table "migrate_device"
"""
input migrate_device_set_input {
  account: String
  created_at: timestamptz
  cred_id: String
  device_name: String
  public_key: String
}

"""
Streaming cursor of the table "migrate_device"
"""
input migrate_device_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: migrate_device_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input migrate_device_stream_cursor_value_input {
  account: String
  created_at: timestamptz
  cred_id: String
  device_name: String
  public_key: String
}

"""
update columns of table "migrate_device"
"""
enum migrate_device_update_column {
  """column name"""
  account

  """column name"""
  created_at

  """column name"""
  cred_id

  """column name"""
  device_name

  """column name"""
  public_key
}

input migrate_device_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: migrate_device_set_input

  """filter the rows which have to be updated"""
  where: migrate_device_bool_exp!
}

"""mutation root"""
type mutation_root {
  approve_new_account(request_id: String): String
  cancel_p2p_offer(p2p_data: cancel_p2p_offer_input): p2p_offer_output
  confirm_p2p_payment(p2p_data: confirm_p2p_offer_input): p2p_offer_output

  """
  delete data from the table: "accounts_information"
  """
  delete_accounts_information(
    """filter the rows which have to be deleted"""
    where: accounts_information_bool_exp!
  ): accounts_information_mutation_response

  """
  delete single row from the table: "accounts_information"
  """
  delete_accounts_information_by_pk(account: String!, id: uuid!): accounts_information

  """
  delete data from the table: "devices"
  """
  delete_devices(
    """filter the rows which have to be deleted"""
    where: devices_bool_exp!
  ): devices_mutation_response

  """
  delete single row from the table: "devices"
  """
  delete_devices_by_pk(cred_id: String!): devices

  """
  delete data from the table: "messages"
  """
  delete_messages(
    """filter the rows which have to be deleted"""
    where: messages_bool_exp!
  ): messages_mutation_response

  """
  delete single row from the table: "messages"
  """
  delete_messages_by_pk(id: uuid!): messages

  """
  delete data from the table: "migrate_device"
  """
  delete_migrate_device(
    """filter the rows which have to be deleted"""
    where: migrate_device_bool_exp!
  ): migrate_device_mutation_response

  """
  delete single row from the table: "migrate_device"
  """
  delete_migrate_device_by_pk(cred_id: String!): migrate_device

  """
  delete data from the table: "notifications"
  """
  delete_notifications(
    """filter the rows which have to be deleted"""
    where: notifications_bool_exp!
  ): notifications_mutation_response

  """
  delete single row from the table: "notifications"
  """
  delete_notifications_by_pk(id: uuid!): notifications

  """
  delete data from the table: "p2p_offers"
  """
  delete_p2p_offers(
    """filter the rows which have to be deleted"""
    where: p2p_offers_bool_exp!
  ): p2p_offers_mutation_response

  """
  delete single row from the table: "p2p_offers"
  """
  delete_p2p_offers_by_pk(id: uuid!): p2p_offers

  """
  delete data from the table: "preferences"
  """
  delete_preferences(
    """filter the rows which have to be deleted"""
    where: preferences_bool_exp!
  ): preferences_mutation_response

  """
  delete single row from the table: "preferences"
  """
  delete_preferences_by_pk(account: String!): preferences

  """
  delete data from the table: "reg_accounts"
  """
  delete_reg_accounts(
    """filter the rows which have to be deleted"""
    where: reg_accounts_bool_exp!
  ): reg_accounts_mutation_response

  """
  delete single row from the table: "reg_accounts"
  """
  delete_reg_accounts_by_pk(id: uuid!): reg_accounts

  """
  delete data from the table: "signing_requests"
  """
  delete_signing_requests(
    """filter the rows which have to be deleted"""
    where: signing_requests_bool_exp!
  ): signing_requests_mutation_response

  """
  delete single row from the table: "signing_requests"
  """
  delete_signing_requests_by_pk(id: uuid!): signing_requests

  """
  delete data from the table: "swap_assets"
  """
  delete_swap_assets(
    """filter the rows which have to be deleted"""
    where: swap_assets_bool_exp!
  ): swap_assets_mutation_response

  """
  delete single row from the table: "swap_assets"
  """
  delete_swap_assets_by_pk(asset: String!, chain: String!): swap_assets

  """
  delete data from the table: "swap_orders"
  """
  delete_swap_orders(
    """filter the rows which have to be deleted"""
    where: swap_orders_bool_exp!
  ): swap_orders_mutation_response

  """
  delete single row from the table: "swap_orders"
  """
  delete_swap_orders_by_pk(id: uuid!): swap_orders

  """
  delete data from the table: "trust_network"
  """
  delete_trust_network(
    """filter the rows which have to be deleted"""
    where: trust_network_bool_exp!
  ): trust_network_mutation_response

  """
  delete single row from the table: "trust_network"
  """
  delete_trust_network_by_pk(account: String!, trust: String!): trust_network

  """
  delete data from the table: "trust_network_notification"
  """
  delete_trust_network_notification(
    """filter the rows which have to be deleted"""
    where: trust_network_notification_bool_exp!
  ): trust_network_notification_mutation_response

  """
  delete single row from the table: "trust_network_notification"
  """
  delete_trust_network_notification_by_pk(account: String!, trust: String!): trust_network_notification

  """
  delete data from the table: "trust_network_status"
  """
  delete_trust_network_status(
    """filter the rows which have to be deleted"""
    where: trust_network_status_bool_exp!
  ): trust_network_status_mutation_response

  """
  delete single row from the table: "trust_network_status"
  """
  delete_trust_network_status_by_pk(status: String!): trust_network_status

  """
  insert data into the table: "accounts_information"
  """
  insert_accounts_information(
    """the rows to be inserted"""
    objects: [accounts_information_insert_input!]!

    """upsert condition"""
    on_conflict: accounts_information_on_conflict
  ): accounts_information_mutation_response

  """
  insert a single row into the table: "accounts_information"
  """
  insert_accounts_information_one(
    """the row to be inserted"""
    object: accounts_information_insert_input!

    """upsert condition"""
    on_conflict: accounts_information_on_conflict
  ): accounts_information

  """
  insert data into the table: "devices"
  """
  insert_devices(
    """the rows to be inserted"""
    objects: [devices_insert_input!]!

    """upsert condition"""
    on_conflict: devices_on_conflict
  ): devices_mutation_response

  """
  insert a single row into the table: "devices"
  """
  insert_devices_one(
    """the row to be inserted"""
    object: devices_insert_input!

    """upsert condition"""
    on_conflict: devices_on_conflict
  ): devices

  """
  insert data into the table: "messages"
  """
  insert_messages(
    """the rows to be inserted"""
    objects: [messages_insert_input!]!

    """upsert condition"""
    on_conflict: messages_on_conflict
  ): messages_mutation_response

  """
  insert a single row into the table: "messages"
  """
  insert_messages_one(
    """the row to be inserted"""
    object: messages_insert_input!

    """upsert condition"""
    on_conflict: messages_on_conflict
  ): messages

  """
  insert data into the table: "migrate_device"
  """
  insert_migrate_device(
    """the rows to be inserted"""
    objects: [migrate_device_insert_input!]!

    """upsert condition"""
    on_conflict: migrate_device_on_conflict
  ): migrate_device_mutation_response

  """
  insert a single row into the table: "migrate_device"
  """
  insert_migrate_device_one(
    """the row to be inserted"""
    object: migrate_device_insert_input!

    """upsert condition"""
    on_conflict: migrate_device_on_conflict
  ): migrate_device

  """
  insert data into the table: "notifications"
  """
  insert_notifications(
    """the rows to be inserted"""
    objects: [notifications_insert_input!]!

    """upsert condition"""
    on_conflict: notifications_on_conflict
  ): notifications_mutation_response

  """
  insert a single row into the table: "notifications"
  """
  insert_notifications_one(
    """the row to be inserted"""
    object: notifications_insert_input!

    """upsert condition"""
    on_conflict: notifications_on_conflict
  ): notifications

  """
  insert data into the table: "p2p_offers"
  """
  insert_p2p_offers(
    """the rows to be inserted"""
    objects: [p2p_offers_insert_input!]!

    """upsert condition"""
    on_conflict: p2p_offers_on_conflict
  ): p2p_offers_mutation_response

  """
  insert a single row into the table: "p2p_offers"
  """
  insert_p2p_offers_one(
    """the row to be inserted"""
    object: p2p_offers_insert_input!

    """upsert condition"""
    on_conflict: p2p_offers_on_conflict
  ): p2p_offers

  """
  insert data into the table: "preferences"
  """
  insert_preferences(
    """the rows to be inserted"""
    objects: [preferences_insert_input!]!

    """upsert condition"""
    on_conflict: preferences_on_conflict
  ): preferences_mutation_response

  """
  insert a single row into the table: "preferences"
  """
  insert_preferences_one(
    """the row to be inserted"""
    object: preferences_insert_input!

    """upsert condition"""
    on_conflict: preferences_on_conflict
  ): preferences

  """
  insert data into the table: "reg_accounts"
  """
  insert_reg_accounts(
    """the rows to be inserted"""
    objects: [reg_accounts_insert_input!]!

    """upsert condition"""
    on_conflict: reg_accounts_on_conflict
  ): reg_accounts_mutation_response

  """
  insert a single row into the table: "reg_accounts"
  """
  insert_reg_accounts_one(
    """the row to be inserted"""
    object: reg_accounts_insert_input!

    """upsert condition"""
    on_conflict: reg_accounts_on_conflict
  ): reg_accounts

  """
  insert data into the table: "signing_requests"
  """
  insert_signing_requests(
    """the rows to be inserted"""
    objects: [signing_requests_insert_input!]!

    """upsert condition"""
    on_conflict: signing_requests_on_conflict
  ): signing_requests_mutation_response

  """
  insert a single row into the table: "signing_requests"
  """
  insert_signing_requests_one(
    """the row to be inserted"""
    object: signing_requests_insert_input!

    """upsert condition"""
    on_conflict: signing_requests_on_conflict
  ): signing_requests

  """
  insert data into the table: "swap_assets"
  """
  insert_swap_assets(
    """the rows to be inserted"""
    objects: [swap_assets_insert_input!]!

    """upsert condition"""
    on_conflict: swap_assets_on_conflict
  ): swap_assets_mutation_response

  """
  insert a single row into the table: "swap_assets"
  """
  insert_swap_assets_one(
    """the row to be inserted"""
    object: swap_assets_insert_input!

    """upsert condition"""
    on_conflict: swap_assets_on_conflict
  ): swap_assets

  """
  insert data into the table: "swap_orders"
  """
  insert_swap_orders(
    """the rows to be inserted"""
    objects: [swap_orders_insert_input!]!

    """upsert condition"""
    on_conflict: swap_orders_on_conflict
  ): swap_orders_mutation_response

  """
  insert a single row into the table: "swap_orders"
  """
  insert_swap_orders_one(
    """the row to be inserted"""
    object: swap_orders_insert_input!

    """upsert condition"""
    on_conflict: swap_orders_on_conflict
  ): swap_orders

  """
  insert data into the table: "trust_network"
  """
  insert_trust_network(
    """the rows to be inserted"""
    objects: [trust_network_insert_input!]!

    """upsert condition"""
    on_conflict: trust_network_on_conflict
  ): trust_network_mutation_response

  """
  insert data into the table: "trust_network_notification"
  """
  insert_trust_network_notification(
    """the rows to be inserted"""
    objects: [trust_network_notification_insert_input!]!

    """upsert condition"""
    on_conflict: trust_network_notification_on_conflict
  ): trust_network_notification_mutation_response

  """
  insert a single row into the table: "trust_network_notification"
  """
  insert_trust_network_notification_one(
    """the row to be inserted"""
    object: trust_network_notification_insert_input!

    """upsert condition"""
    on_conflict: trust_network_notification_on_conflict
  ): trust_network_notification

  """
  insert a single row into the table: "trust_network"
  """
  insert_trust_network_one(
    """the row to be inserted"""
    object: trust_network_insert_input!

    """upsert condition"""
    on_conflict: trust_network_on_conflict
  ): trust_network

  """
  insert data into the table: "trust_network_status"
  """
  insert_trust_network_status(
    """the rows to be inserted"""
    objects: [trust_network_status_insert_input!]!

    """upsert condition"""
    on_conflict: trust_network_status_on_conflict
  ): trust_network_status_mutation_response

  """
  insert a single row into the table: "trust_network_status"
  """
  insert_trust_network_status_one(
    """the row to be inserted"""
    object: trust_network_status_insert_input!

    """upsert condition"""
    on_conflict: trust_network_status_on_conflict
  ): trust_network_status
  make_p2p_buy_offer(offer: make_p2p_buy_offer_input): p2p_offer_output
  make_p2p_sell_offer(offer: make_p2p_sell_offer_input): p2p_offer_output
  reject_new_account(request_id: String): String
  request_new_account(account_data: request_new_account_input): request_new_account_output
  toggle_trust_network(input: toggle_trust_network_input): toggle_trust_network_output

  """
  update data of the table: "accounts_information"
  """
  update_accounts_information(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: accounts_information_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: accounts_information_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: accounts_information_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: accounts_information_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: accounts_information_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: accounts_information_set_input

    """filter the rows which have to be updated"""
    where: accounts_information_bool_exp!
  ): accounts_information_mutation_response

  """
  update single row of the table: "accounts_information"
  """
  update_accounts_information_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: accounts_information_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: accounts_information_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: accounts_information_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: accounts_information_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: accounts_information_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: accounts_information_set_input
    pk_columns: accounts_information_pk_columns_input!
  ): accounts_information

  """
  update multiples rows of table: "accounts_information"
  """
  update_accounts_information_many(
    """updates to execute, in order"""
    updates: [accounts_information_updates!]!
  ): [accounts_information_mutation_response]

  """
  update data of the table: "devices"
  """
  update_devices(
    """sets the columns of the filtered rows to the given values"""
    _set: devices_set_input

    """filter the rows which have to be updated"""
    where: devices_bool_exp!
  ): devices_mutation_response

  """
  update single row of the table: "devices"
  """
  update_devices_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: devices_set_input
    pk_columns: devices_pk_columns_input!
  ): devices

  """
  update multiples rows of table: "devices"
  """
  update_devices_many(
    """updates to execute, in order"""
    updates: [devices_updates!]!
  ): [devices_mutation_response]

  """
  update data of the table: "messages"
  """
  update_messages(
    """sets the columns of the filtered rows to the given values"""
    _set: messages_set_input

    """filter the rows which have to be updated"""
    where: messages_bool_exp!
  ): messages_mutation_response

  """
  update single row of the table: "messages"
  """
  update_messages_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: messages_set_input
    pk_columns: messages_pk_columns_input!
  ): messages

  """
  update multiples rows of table: "messages"
  """
  update_messages_many(
    """updates to execute, in order"""
    updates: [messages_updates!]!
  ): [messages_mutation_response]

  """
  update data of the table: "migrate_device"
  """
  update_migrate_device(
    """sets the columns of the filtered rows to the given values"""
    _set: migrate_device_set_input

    """filter the rows which have to be updated"""
    where: migrate_device_bool_exp!
  ): migrate_device_mutation_response

  """
  update single row of the table: "migrate_device"
  """
  update_migrate_device_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: migrate_device_set_input
    pk_columns: migrate_device_pk_columns_input!
  ): migrate_device

  """
  update multiples rows of table: "migrate_device"
  """
  update_migrate_device_many(
    """updates to execute, in order"""
    updates: [migrate_device_updates!]!
  ): [migrate_device_mutation_response]

  """
  update data of the table: "notifications"
  """
  update_notifications(
    """sets the columns of the filtered rows to the given values"""
    _set: notifications_set_input

    """filter the rows which have to be updated"""
    where: notifications_bool_exp!
  ): notifications_mutation_response

  """
  update single row of the table: "notifications"
  """
  update_notifications_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: notifications_set_input
    pk_columns: notifications_pk_columns_input!
  ): notifications

  """
  update multiples rows of table: "notifications"
  """
  update_notifications_many(
    """updates to execute, in order"""
    updates: [notifications_updates!]!
  ): [notifications_mutation_response]

  """
  update data of the table: "p2p_offers"
  """
  update_p2p_offers(
    """sets the columns of the filtered rows to the given values"""
    _set: p2p_offers_set_input

    """filter the rows which have to be updated"""
    where: p2p_offers_bool_exp!
  ): p2p_offers_mutation_response

  """
  update single row of the table: "p2p_offers"
  """
  update_p2p_offers_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: p2p_offers_set_input
    pk_columns: p2p_offers_pk_columns_input!
  ): p2p_offers

  """
  update multiples rows of table: "p2p_offers"
  """
  update_p2p_offers_many(
    """updates to execute, in order"""
    updates: [p2p_offers_updates!]!
  ): [p2p_offers_mutation_response]

  """
  update data of the table: "preferences"
  """
  update_preferences(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: preferences_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: preferences_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: preferences_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: preferences_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: preferences_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: preferences_set_input

    """filter the rows which have to be updated"""
    where: preferences_bool_exp!
  ): preferences_mutation_response

  """
  update single row of the table: "preferences"
  """
  update_preferences_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: preferences_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: preferences_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: preferences_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: preferences_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: preferences_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: preferences_set_input
    pk_columns: preferences_pk_columns_input!
  ): preferences

  """
  update multiples rows of table: "preferences"
  """
  update_preferences_many(
    """updates to execute, in order"""
    updates: [preferences_updates!]!
  ): [preferences_mutation_response]

  """
  update data of the table: "reg_accounts"
  """
  update_reg_accounts(
    """sets the columns of the filtered rows to the given values"""
    _set: reg_accounts_set_input

    """filter the rows which have to be updated"""
    where: reg_accounts_bool_exp!
  ): reg_accounts_mutation_response

  """
  update single row of the table: "reg_accounts"
  """
  update_reg_accounts_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: reg_accounts_set_input
    pk_columns: reg_accounts_pk_columns_input!
  ): reg_accounts

  """
  update multiples rows of table: "reg_accounts"
  """
  update_reg_accounts_many(
    """updates to execute, in order"""
    updates: [reg_accounts_updates!]!
  ): [reg_accounts_mutation_response]

  """
  update data of the table: "signing_requests"
  """
  update_signing_requests(
    """sets the columns of the filtered rows to the given values"""
    _set: signing_requests_set_input

    """filter the rows which have to be updated"""
    where: signing_requests_bool_exp!
  ): signing_requests_mutation_response

  """
  update single row of the table: "signing_requests"
  """
  update_signing_requests_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: signing_requests_set_input
    pk_columns: signing_requests_pk_columns_input!
  ): signing_requests

  """
  update multiples rows of table: "signing_requests"
  """
  update_signing_requests_many(
    """updates to execute, in order"""
    updates: [signing_requests_updates!]!
  ): [signing_requests_mutation_response]

  """
  update data of the table: "swap_assets"
  """
  update_swap_assets(
    """sets the columns of the filtered rows to the given values"""
    _set: swap_assets_set_input

    """filter the rows which have to be updated"""
    where: swap_assets_bool_exp!
  ): swap_assets_mutation_response

  """
  update single row of the table: "swap_assets"
  """
  update_swap_assets_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: swap_assets_set_input
    pk_columns: swap_assets_pk_columns_input!
  ): swap_assets

  """
  update multiples rows of table: "swap_assets"
  """
  update_swap_assets_many(
    """updates to execute, in order"""
    updates: [swap_assets_updates!]!
  ): [swap_assets_mutation_response]

  """
  update data of the table: "swap_orders"
  """
  update_swap_orders(
    """increments the numeric columns with given value of the filtered values"""
    _inc: swap_orders_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: swap_orders_set_input

    """filter the rows which have to be updated"""
    where: swap_orders_bool_exp!
  ): swap_orders_mutation_response

  """
  update single row of the table: "swap_orders"
  """
  update_swap_orders_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: swap_orders_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: swap_orders_set_input
    pk_columns: swap_orders_pk_columns_input!
  ): swap_orders

  """
  update multiples rows of table: "swap_orders"
  """
  update_swap_orders_many(
    """updates to execute, in order"""
    updates: [swap_orders_updates!]!
  ): [swap_orders_mutation_response]

  """
  update data of the table: "trust_network"
  """
  update_trust_network(
    """sets the columns of the filtered rows to the given values"""
    _set: trust_network_set_input

    """filter the rows which have to be updated"""
    where: trust_network_bool_exp!
  ): trust_network_mutation_response

  """
  update single row of the table: "trust_network"
  """
  update_trust_network_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: trust_network_set_input
    pk_columns: trust_network_pk_columns_input!
  ): trust_network

  """
  update multiples rows of table: "trust_network"
  """
  update_trust_network_many(
    """updates to execute, in order"""
    updates: [trust_network_updates!]!
  ): [trust_network_mutation_response]

  """
  update data of the table: "trust_network_notification"
  """
  update_trust_network_notification(
    """sets the columns of the filtered rows to the given values"""
    _set: trust_network_notification_set_input

    """filter the rows which have to be updated"""
    where: trust_network_notification_bool_exp!
  ): trust_network_notification_mutation_response

  """
  update single row of the table: "trust_network_notification"
  """
  update_trust_network_notification_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: trust_network_notification_set_input
    pk_columns: trust_network_notification_pk_columns_input!
  ): trust_network_notification

  """
  update multiples rows of table: "trust_network_notification"
  """
  update_trust_network_notification_many(
    """updates to execute, in order"""
    updates: [trust_network_notification_updates!]!
  ): [trust_network_notification_mutation_response]

  """
  update data of the table: "trust_network_status"
  """
  update_trust_network_status(
    """sets the columns of the filtered rows to the given values"""
    _set: trust_network_status_set_input

    """filter the rows which have to be updated"""
    where: trust_network_status_bool_exp!
  ): trust_network_status_mutation_response

  """
  update single row of the table: "trust_network_status"
  """
  update_trust_network_status_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: trust_network_status_set_input
    pk_columns: trust_network_status_pk_columns_input!
  ): trust_network_status

  """
  update multiples rows of table: "trust_network_status"
  """
  update_trust_network_status_many(
    """updates to execute, in order"""
    updates: [trust_network_status_updates!]!
  ): [trust_network_status_mutation_response]
}

"""
columns and relationships of "notifications"
"""
type notifications {
  content_id: uuid
  created_at: timestamptz!
  from: String!
  id: uuid!
  read: Boolean!

  """An object relationship"""
  reg_account_by_from: reg_accounts!

  """An object relationship"""
  reg_account_by_to: reg_accounts!
  to: String!
  type: String!
}

"""
aggregated selection of "notifications"
"""
type notifications_aggregate {
  aggregate: notifications_aggregate_fields
  nodes: [notifications!]!
}

input notifications_aggregate_bool_exp {
  bool_and: notifications_aggregate_bool_exp_bool_and
  bool_or: notifications_aggregate_bool_exp_bool_or
  count: notifications_aggregate_bool_exp_count
}

input notifications_aggregate_bool_exp_bool_and {
  arguments: notifications_select_column_notifications_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: notifications_bool_exp
  predicate: Boolean_comparison_exp!
}

input notifications_aggregate_bool_exp_bool_or {
  arguments: notifications_select_column_notifications_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: notifications_bool_exp
  predicate: Boolean_comparison_exp!
}

input notifications_aggregate_bool_exp_count {
  arguments: [notifications_select_column!]
  distinct: Boolean
  filter: notifications_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "notifications"
"""
type notifications_aggregate_fields {
  count(columns: [notifications_select_column!], distinct: Boolean): Int!
  max: notifications_max_fields
  min: notifications_min_fields
}

"""
order by aggregate values of table "notifications"
"""
input notifications_aggregate_order_by {
  count: order_by
  max: notifications_max_order_by
  min: notifications_min_order_by
}

"""
input type for inserting array relation for remote table "notifications"
"""
input notifications_arr_rel_insert_input {
  data: [notifications_insert_input!]!

  """upsert condition"""
  on_conflict: notifications_on_conflict
}

"""
Boolean expression to filter rows from the table "notifications". All fields are combined with a logical 'AND'.
"""
input notifications_bool_exp {
  _and: [notifications_bool_exp!]
  _not: notifications_bool_exp
  _or: [notifications_bool_exp!]
  content_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  from: String_comparison_exp
  id: uuid_comparison_exp
  read: Boolean_comparison_exp
  reg_account_by_from: reg_accounts_bool_exp
  reg_account_by_to: reg_accounts_bool_exp
  to: String_comparison_exp
  type: String_comparison_exp
}

"""
unique or primary key constraints on table "notifications"
"""
enum notifications_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  notifications_pkey
}

"""
input type for inserting data into table "notifications"
"""
input notifications_insert_input {
  content_id: uuid
  created_at: timestamptz
  from: String
  id: uuid
  read: Boolean
  reg_account_by_from: reg_accounts_obj_rel_insert_input
  reg_account_by_to: reg_accounts_obj_rel_insert_input
  to: String
  type: String
}

"""aggregate max on columns"""
type notifications_max_fields {
  content_id: uuid
  created_at: timestamptz
  from: String
  id: uuid
  to: String
  type: String
}

"""
order by max() on columns of table "notifications"
"""
input notifications_max_order_by {
  content_id: order_by
  created_at: order_by
  from: order_by
  id: order_by
  to: order_by
  type: order_by
}

"""aggregate min on columns"""
type notifications_min_fields {
  content_id: uuid
  created_at: timestamptz
  from: String
  id: uuid
  to: String
  type: String
}

"""
order by min() on columns of table "notifications"
"""
input notifications_min_order_by {
  content_id: order_by
  created_at: order_by
  from: order_by
  id: order_by
  to: order_by
  type: order_by
}

"""
response of any mutation on the table "notifications"
"""
type notifications_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [notifications!]!
}

"""
on_conflict condition type for table "notifications"
"""
input notifications_on_conflict {
  constraint: notifications_constraint!
  update_columns: [notifications_update_column!]! = []
  where: notifications_bool_exp
}

"""Ordering options when selecting data from "notifications"."""
input notifications_order_by {
  content_id: order_by
  created_at: order_by
  from: order_by
  id: order_by
  read: order_by
  reg_account_by_from: reg_accounts_order_by
  reg_account_by_to: reg_accounts_order_by
  to: order_by
  type: order_by
}

"""primary key columns input for table: notifications"""
input notifications_pk_columns_input {
  id: uuid!
}

"""
select columns of table "notifications"
"""
enum notifications_select_column {
  """column name"""
  content_id

  """column name"""
  created_at

  """column name"""
  from

  """column name"""
  id

  """column name"""
  read

  """column name"""
  to

  """column name"""
  type
}

"""
select "notifications_aggregate_bool_exp_bool_and_arguments_columns" columns of table "notifications"
"""
enum notifications_select_column_notifications_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  read
}

"""
select "notifications_aggregate_bool_exp_bool_or_arguments_columns" columns of table "notifications"
"""
enum notifications_select_column_notifications_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  read
}

"""
input type for updating data in table "notifications"
"""
input notifications_set_input {
  content_id: uuid
  created_at: timestamptz
  from: String
  id: uuid
  read: Boolean
  to: String
  type: String
}

"""
Streaming cursor of the table "notifications"
"""
input notifications_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: notifications_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input notifications_stream_cursor_value_input {
  content_id: uuid
  created_at: timestamptz
  from: String
  id: uuid
  read: Boolean
  to: String
  type: String
}

"""
update columns of table "notifications"
"""
enum notifications_update_column {
  """column name"""
  content_id

  """column name"""
  created_at

  """column name"""
  from

  """column name"""
  id

  """column name"""
  read

  """column name"""
  to

  """column name"""
  type
}

input notifications_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: notifications_set_input

  """filter the rows which have to be updated"""
  where: notifications_bool_exp!
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

type p2p_offer_output {
  amount: String
  masterbotsbank_id: String
  buyer: String
  buyer_confirmed_payment: Boolean
  buyer_method_details: String
  cancelled: Boolean
  cancelled_by: String
  completed: Boolean
  created_at: String
  id: String
  initiator: String
  matched: Boolean
  method: String
  region: String
  seller: String
  seller_confirmed_payment: Boolean
  seller_method_details: String
  type: String
  updated_at: String
}

"""
columns and relationships of "p2p_offers"
"""
type p2p_offers {
  amount: String!
  masterbotsbank_id: String
  buyer: String
  buyer_confirmed_payment: Boolean!
  buyer_method_details: String
  cancelled: Boolean!
  cancelled_by: String
  completed: Boolean!
  created_at: timestamptz!
  id: uuid!
  initiator: String!
  matched: Boolean!

  """An array relationship"""
  messages(
    """distinct select on columns"""
    distinct_on: [messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [messages_order_by!]

    """filter the rows returned"""
    where: messages_bool_exp
  ): [messages!]!

  """An aggregate relationship"""
  messages_aggregate(
    """distinct select on columns"""
    distinct_on: [messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [messages_order_by!]

    """filter the rows returned"""
    where: messages_bool_exp
  ): messages_aggregate!
  method: String!

  """An object relationship"""
  reg_account_by_buyer: reg_accounts

  """An object relationship"""
  reg_account_by_initiator: reg_accounts!

  """An object relationship"""
  reg_account_by_seller: reg_accounts
  region: String
  seller: String
  seller_confirmed_payment: Boolean!
  seller_method_details: String
  type: String!
  updated_at: timestamptz!
}

"""
aggregated selection of "p2p_offers"
"""
type p2p_offers_aggregate {
  aggregate: p2p_offers_aggregate_fields
  nodes: [p2p_offers!]!
}

input p2p_offers_aggregate_bool_exp {
  bool_and: p2p_offers_aggregate_bool_exp_bool_and
  bool_or: p2p_offers_aggregate_bool_exp_bool_or
  count: p2p_offers_aggregate_bool_exp_count
}

input p2p_offers_aggregate_bool_exp_bool_and {
  arguments: p2p_offers_select_column_p2p_offers_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: p2p_offers_bool_exp
  predicate: Boolean_comparison_exp!
}

input p2p_offers_aggregate_bool_exp_bool_or {
  arguments: p2p_offers_select_column_p2p_offers_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: p2p_offers_bool_exp
  predicate: Boolean_comparison_exp!
}

input p2p_offers_aggregate_bool_exp_count {
  arguments: [p2p_offers_select_column!]
  distinct: Boolean
  filter: p2p_offers_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "p2p_offers"
"""
type p2p_offers_aggregate_fields {
  count(columns: [p2p_offers_select_column!], distinct: Boolean): Int!
  max: p2p_offers_max_fields
  min: p2p_offers_min_fields
}

"""
order by aggregate values of table "p2p_offers"
"""
input p2p_offers_aggregate_order_by {
  count: order_by
  max: p2p_offers_max_order_by
  min: p2p_offers_min_order_by
}

"""
input type for inserting array relation for remote table "p2p_offers"
"""
input p2p_offers_arr_rel_insert_input {
  data: [p2p_offers_insert_input!]!

  """upsert condition"""
  on_conflict: p2p_offers_on_conflict
}

"""
Boolean expression to filter rows from the table "p2p_offers". All fields are combined with a logical 'AND'.
"""
input p2p_offers_bool_exp {
  _and: [p2p_offers_bool_exp!]
  _not: p2p_offers_bool_exp
  _or: [p2p_offers_bool_exp!]
  amount: String_comparison_exp
  masterbotsbank_id: String_comparison_exp
  buyer: String_comparison_exp
  buyer_confirmed_payment: Boolean_comparison_exp
  buyer_method_details: String_comparison_exp
  cancelled: Boolean_comparison_exp
  cancelled_by: String_comparison_exp
  completed: Boolean_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  initiator: String_comparison_exp
  matched: Boolean_comparison_exp
  messages: messages_bool_exp
  messages_aggregate: messages_aggregate_bool_exp
  method: String_comparison_exp
  reg_account_by_buyer: reg_accounts_bool_exp
  reg_account_by_initiator: reg_accounts_bool_exp
  reg_account_by_seller: reg_accounts_bool_exp
  region: String_comparison_exp
  seller: String_comparison_exp
  seller_confirmed_payment: Boolean_comparison_exp
  seller_method_details: String_comparison_exp
  type: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "p2p_offers"
"""
enum p2p_offers_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  p2p_offers_id_key

  """
  unique or primary key constraint on columns "id"
  """
  p2p_offers_pkey
}

"""
input type for inserting data into table "p2p_offers"
"""
input p2p_offers_insert_input {
  amount: String
  masterbotsbank_id: String
  buyer: String
  buyer_confirmed_payment: Boolean
  buyer_method_details: String
  cancelled: Boolean
  cancelled_by: String
  completed: Boolean
  created_at: timestamptz
  id: uuid
  initiator: String
  matched: Boolean
  messages: messages_arr_rel_insert_input
  method: String
  reg_account_by_buyer: reg_accounts_obj_rel_insert_input
  reg_account_by_initiator: reg_accounts_obj_rel_insert_input
  reg_account_by_seller: reg_accounts_obj_rel_insert_input
  region: String
  seller: String
  seller_confirmed_payment: Boolean
  seller_method_details: String
  type: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type p2p_offers_max_fields {
  amount: String
  masterbotsbank_id: String
  buyer: String
  buyer_method_details: String
  cancelled_by: String
  created_at: timestamptz
  id: uuid
  initiator: String
  method: String
  region: String
  seller: String
  seller_method_details: String
  type: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "p2p_offers"
"""
input p2p_offers_max_order_by {
  amount: order_by
  masterbotsbank_id: order_by
  buyer: order_by
  buyer_method_details: order_by
  cancelled_by: order_by
  created_at: order_by
  id: order_by
  initiator: order_by
  method: order_by
  region: order_by
  seller: order_by
  seller_method_details: order_by
  type: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type p2p_offers_min_fields {
  amount: String
  masterbotsbank_id: String
  buyer: String
  buyer_method_details: String
  cancelled_by: String
  created_at: timestamptz
  id: uuid
  initiator: String
  method: String
  region: String
  seller: String
  seller_method_details: String
  type: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "p2p_offers"
"""
input p2p_offers_min_order_by {
  amount: order_by
  masterbotsbank_id: order_by
  buyer: order_by
  buyer_method_details: order_by
  cancelled_by: order_by
  created_at: order_by
  id: order_by
  initiator: order_by
  method: order_by
  region: order_by
  seller: order_by
  seller_method_details: order_by
  type: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "p2p_offers"
"""
type p2p_offers_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [p2p_offers!]!
}

"""
input type for inserting object relation for remote table "p2p_offers"
"""
input p2p_offers_obj_rel_insert_input {
  data: p2p_offers_insert_input!

  """upsert condition"""
  on_conflict: p2p_offers_on_conflict
}

"""
on_conflict condition type for table "p2p_offers"
"""
input p2p_offers_on_conflict {
  constraint: p2p_offers_constraint!
  update_columns: [p2p_offers_update_column!]! = []
  where: p2p_offers_bool_exp
}

"""Ordering options when selecting data from "p2p_offers"."""
input p2p_offers_order_by {
  amount: order_by
  masterbotsbank_id: order_by
  buyer: order_by
  buyer_confirmed_payment: order_by
  buyer_method_details: order_by
  cancelled: order_by
  cancelled_by: order_by
  completed: order_by
  created_at: order_by
  id: order_by
  initiator: order_by
  matched: order_by
  messages_aggregate: messages_aggregate_order_by
  method: order_by
  reg_account_by_buyer: reg_accounts_order_by
  reg_account_by_initiator: reg_accounts_order_by
  reg_account_by_seller: reg_accounts_order_by
  region: order_by
  seller: order_by
  seller_confirmed_payment: order_by
  seller_method_details: order_by
  type: order_by
  updated_at: order_by
}

"""primary key columns input for table: p2p_offers"""
input p2p_offers_pk_columns_input {
  id: uuid!
}

"""
select columns of table "p2p_offers"
"""
enum p2p_offers_select_column {
  """column name"""
  amount

  """column name"""
  masterbotsbank_id

  """column name"""
  buyer

  """column name"""
  buyer_confirmed_payment

  """column name"""
  buyer_method_details

  """column name"""
  cancelled

  """column name"""
  cancelled_by

  """column name"""
  completed

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  initiator

  """column name"""
  matched

  """column name"""
  method

  """column name"""
  region

  """column name"""
  seller

  """column name"""
  seller_confirmed_payment

  """column name"""
  seller_method_details

  """column name"""
  type

  """column name"""
  updated_at
}

"""
select "p2p_offers_aggregate_bool_exp_bool_and_arguments_columns" columns of table "p2p_offers"
"""
enum p2p_offers_select_column_p2p_offers_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  buyer_confirmed_payment

  """column name"""
  cancelled

  """column name"""
  completed

  """column name"""
  matched

  """column name"""
  seller_confirmed_payment
}

"""
select "p2p_offers_aggregate_bool_exp_bool_or_arguments_columns" columns of table "p2p_offers"
"""
enum p2p_offers_select_column_p2p_offers_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  buyer_confirmed_payment

  """column name"""
  cancelled

  """column name"""
  completed

  """column name"""
  matched

  """column name"""
  seller_confirmed_payment
}

"""
input type for updating data in table "p2p_offers"
"""
input p2p_offers_set_input {
  amount: String
  masterbotsbank_id: String
  buyer: String
  buyer_confirmed_payment: Boolean
  buyer_method_details: String
  cancelled: Boolean
  cancelled_by: String
  completed: Boolean
  created_at: timestamptz
  id: uuid
  initiator: String
  matched: Boolean
  method: String
  region: String
  seller: String
  seller_confirmed_payment: Boolean
  seller_method_details: String
  type: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "p2p_offers"
"""
input p2p_offers_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: p2p_offers_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input p2p_offers_stream_cursor_value_input {
  amount: String
  masterbotsbank_id: String
  buyer: String
  buyer_confirmed_payment: Boolean
  buyer_method_details: String
  cancelled: Boolean
  cancelled_by: String
  completed: Boolean
  created_at: timestamptz
  id: uuid
  initiator: String
  matched: Boolean
  method: String
  region: String
  seller: String
  seller_confirmed_payment: Boolean
  seller_method_details: String
  type: String
  updated_at: timestamptz
}

"""
update columns of table "p2p_offers"
"""
enum p2p_offers_update_column {
  """column name"""
  amount

  """column name"""
  masterbotsbank_id

  """column name"""
  buyer

  """column name"""
  buyer_confirmed_payment

  """column name"""
  buyer_method_details

  """column name"""
  cancelled

  """column name"""
  cancelled_by

  """column name"""
  completed

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  initiator

  """column name"""
  matched

  """column name"""
  method

  """column name"""
  region

  """column name"""
  seller

  """column name"""
  seller_confirmed_payment

  """column name"""
  seller_method_details

  """column name"""
  type

  """column name"""
  updated_at
}

input p2p_offers_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: p2p_offers_set_input

  """filter the rows which have to be updated"""
  where: p2p_offers_bool_exp!
}

"""
columns and relationships of "preferences"
"""
type preferences {
  account: String!
  currency: String!
  language: String!
  notifications: Boolean!
  personalized: Boolean!
  region: String!
  secondary_currency(
    """JSON select path"""
    path: String
  ): jsonb
  theme: String!
}

"""
aggregated selection of "preferences"
"""
type preferences_aggregate {
  aggregate: preferences_aggregate_fields
  nodes: [preferences!]!
}

"""
aggregate fields of "preferences"
"""
type preferences_aggregate_fields {
  count(columns: [preferences_select_column!], distinct: Boolean): Int!
  max: preferences_max_fields
  min: preferences_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input preferences_append_input {
  secondary_currency: jsonb
}

"""
Boolean expression to filter rows from the table "preferences". All fields are combined with a logical 'AND'.
"""
input preferences_bool_exp {
  _and: [preferences_bool_exp!]
  _not: preferences_bool_exp
  _or: [preferences_bool_exp!]
  account: String_comparison_exp
  currency: String_comparison_exp
  language: String_comparison_exp
  notifications: Boolean_comparison_exp
  personalized: Boolean_comparison_exp
  region: String_comparison_exp
  secondary_currency: jsonb_comparison_exp
  theme: String_comparison_exp
}

"""
unique or primary key constraints on table "preferences"
"""
enum preferences_constraint {
  """
  unique or primary key constraint on columns "account"
  """
  preferences_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input preferences_delete_at_path_input {
  secondary_currency: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input preferences_delete_elem_input {
  secondary_currency: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input preferences_delete_key_input {
  secondary_currency: String
}

"""
input type for inserting data into table "preferences"
"""
input preferences_insert_input {
  account: String
  currency: String
  language: String
  notifications: Boolean
  personalized: Boolean
  region: String
  secondary_currency: jsonb
  theme: String
}

"""aggregate max on columns"""
type preferences_max_fields {
  account: String
  currency: String
  language: String
  region: String
  theme: String
}

"""aggregate min on columns"""
type preferences_min_fields {
  account: String
  currency: String
  language: String
  region: String
  theme: String
}

"""
response of any mutation on the table "preferences"
"""
type preferences_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [preferences!]!
}

"""
on_conflict condition type for table "preferences"
"""
input preferences_on_conflict {
  constraint: preferences_constraint!
  update_columns: [preferences_update_column!]! = []
  where: preferences_bool_exp
}

"""Ordering options when selecting data from "preferences"."""
input preferences_order_by {
  account: order_by
  currency: order_by
  language: order_by
  notifications: order_by
  personalized: order_by
  region: order_by
  secondary_currency: order_by
  theme: order_by
}

"""primary key columns input for table: preferences"""
input preferences_pk_columns_input {
  account: String!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input preferences_prepend_input {
  secondary_currency: jsonb
}

"""
select columns of table "preferences"
"""
enum preferences_select_column {
  """column name"""
  account

  """column name"""
  currency

  """column name"""
  language

  """column name"""
  notifications

  """column name"""
  personalized

  """column name"""
  region

  """column name"""
  secondary_currency

  """column name"""
  theme
}

"""
input type for updating data in table "preferences"
"""
input preferences_set_input {
  account: String
  currency: String
  language: String
  notifications: Boolean
  personalized: Boolean
  region: String
  secondary_currency: jsonb
  theme: String
}

"""
Streaming cursor of the table "preferences"
"""
input preferences_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: preferences_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input preferences_stream_cursor_value_input {
  account: String
  currency: String
  language: String
  notifications: Boolean
  personalized: Boolean
  region: String
  secondary_currency: jsonb
  theme: String
}

"""
update columns of table "preferences"
"""
enum preferences_update_column {
  """column name"""
  account

  """column name"""
  currency

  """column name"""
  language

  """column name"""
  notifications

  """column name"""
  personalized

  """column name"""
  region

  """column name"""
  secondary_currency

  """column name"""
  theme
}

input preferences_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: preferences_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: preferences_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: preferences_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: preferences_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: preferences_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: preferences_set_input

  """filter the rows which have to be updated"""
  where: preferences_bool_exp!
}

type query_root {
  """
  fetch data from the table: "accounts_information"
  """
  accounts_information(
    """distinct select on columns"""
    distinct_on: [accounts_information_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_information_order_by!]

    """filter the rows returned"""
    where: accounts_information_bool_exp
  ): [accounts_information!]!

  """
  fetch aggregated fields from the table: "accounts_information"
  """
  accounts_information_aggregate(
    """distinct select on columns"""
    distinct_on: [accounts_information_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_information_order_by!]

    """filter the rows returned"""
    where: accounts_information_bool_exp
  ): accounts_information_aggregate!

  """
  fetch data from the table: "accounts_information" using primary key columns
  """
  accounts_information_by_pk(account: String!, id: uuid!): accounts_information
  apollo_auth_health_check: String
  apollo_health_check: Boolean

  """An array relationship"""
  devices(
    """distinct select on columns"""
    distinct_on: [devices_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [devices_order_by!]

    """filter the rows returned"""
    where: devices_bool_exp
  ): [devices!]!

  """An aggregate relationship"""
  devices_aggregate(
    """distinct select on columns"""
    distinct_on: [devices_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [devices_order_by!]

    """filter the rows returned"""
    where: devices_bool_exp
  ): devices_aggregate!

  """fetch data from the table: "devices" using primary key columns"""
  devices_by_pk(cred_id: String!): devices
  get_trust_network(account: String): trust_network_output

  """An array relationship"""
  messages(
    """distinct select on columns"""
    distinct_on: [messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [messages_order_by!]

    """filter the rows returned"""
    where: messages_bool_exp
  ): [messages!]!

  """An aggregate relationship"""
  messages_aggregate(
    """distinct select on columns"""
    distinct_on: [messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [messages_order_by!]

    """filter the rows returned"""
    where: messages_bool_exp
  ): messages_aggregate!

  """fetch data from the table: "messages" using primary key columns"""
  messages_by_pk(id: uuid!): messages

  """
  fetch data from the table: "migrate_device"
  """
  migrate_device(
    """distinct select on columns"""
    distinct_on: [migrate_device_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [migrate_device_order_by!]

    """filter the rows returned"""
    where: migrate_device_bool_exp
  ): [migrate_device!]!

  """
  fetch aggregated fields from the table: "migrate_device"
  """
  migrate_device_aggregate(
    """distinct select on columns"""
    distinct_on: [migrate_device_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [migrate_device_order_by!]

    """filter the rows returned"""
    where: migrate_device_bool_exp
  ): migrate_device_aggregate!

  """fetch data from the table: "migrate_device" using primary key columns"""
  migrate_device_by_pk(cred_id: String!): migrate_device

  """
  fetch data from the table: "notifications"
  """
  notifications(
    """distinct select on columns"""
    distinct_on: [notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notifications_order_by!]

    """filter the rows returned"""
    where: notifications_bool_exp
  ): [notifications!]!

  """
  fetch aggregated fields from the table: "notifications"
  """
  notifications_aggregate(
    """distinct select on columns"""
    distinct_on: [notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notifications_order_by!]

    """filter the rows returned"""
    where: notifications_bool_exp
  ): notifications_aggregate!

  """fetch data from the table: "notifications" using primary key columns"""
  notifications_by_pk(id: uuid!): notifications

  """
  fetch data from the table: "p2p_offers"
  """
  p2p_offers(
    """distinct select on columns"""
    distinct_on: [p2p_offers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [p2p_offers_order_by!]

    """filter the rows returned"""
    where: p2p_offers_bool_exp
  ): [p2p_offers!]!

  """
  fetch aggregated fields from the table: "p2p_offers"
  """
  p2p_offers_aggregate(
    """distinct select on columns"""
    distinct_on: [p2p_offers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [p2p_offers_order_by!]

    """filter the rows returned"""
    where: p2p_offers_bool_exp
  ): p2p_offers_aggregate!

  """fetch data from the table: "p2p_offers" using primary key columns"""
  p2p_offers_by_pk(id: uuid!): p2p_offers

  """
  fetch data from the table: "preferences"
  """
  preferences(
    """distinct select on columns"""
    distinct_on: [preferences_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [preferences_order_by!]

    """filter the rows returned"""
    where: preferences_bool_exp
  ): [preferences!]!

  """
  fetch aggregated fields from the table: "preferences"
  """
  preferences_aggregate(
    """distinct select on columns"""
    distinct_on: [preferences_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [preferences_order_by!]

    """filter the rows returned"""
    where: preferences_bool_exp
  ): preferences_aggregate!

  """fetch data from the table: "preferences" using primary key columns"""
  preferences_by_pk(account: String!): preferences

  """
  fetch data from the table: "reg_accounts"
  """
  reg_accounts(
    """distinct select on columns"""
    distinct_on: [reg_accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [reg_accounts_order_by!]

    """filter the rows returned"""
    where: reg_accounts_bool_exp
  ): [reg_accounts!]!

  """
  fetch aggregated fields from the table: "reg_accounts"
  """
  reg_accounts_aggregate(
    """distinct select on columns"""
    distinct_on: [reg_accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [reg_accounts_order_by!]

    """filter the rows returned"""
    where: reg_accounts_bool_exp
  ): reg_accounts_aggregate!

  """fetch data from the table: "reg_accounts" using primary key columns"""
  reg_accounts_by_pk(id: uuid!): reg_accounts

  """
  fetch data from the table: "signing_requests"
  """
  signing_requests(
    """distinct select on columns"""
    distinct_on: [signing_requests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [signing_requests_order_by!]

    """filter the rows returned"""
    where: signing_requests_bool_exp
  ): [signing_requests!]!

  """
  fetch aggregated fields from the table: "signing_requests"
  """
  signing_requests_aggregate(
    """distinct select on columns"""
    distinct_on: [signing_requests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [signing_requests_order_by!]

    """filter the rows returned"""
    where: signing_requests_bool_exp
  ): signing_requests_aggregate!

  """
  fetch data from the table: "signing_requests" using primary key columns
  """
  signing_requests_by_pk(id: uuid!): signing_requests

  """
  fetch data from the table: "swap_assets"
  """
  swap_assets(
    """distinct select on columns"""
    distinct_on: [swap_assets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [swap_assets_order_by!]

    """filter the rows returned"""
    where: swap_assets_bool_exp
  ): [swap_assets!]!

  """
  fetch aggregated fields from the table: "swap_assets"
  """
  swap_assets_aggregate(
    """distinct select on columns"""
    distinct_on: [swap_assets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [swap_assets_order_by!]

    """filter the rows returned"""
    where: swap_assets_bool_exp
  ): swap_assets_aggregate!

  """fetch data from the table: "swap_assets" using primary key columns"""
  swap_assets_by_pk(asset: String!, chain: String!): swap_assets

  """An array relationship"""
  swap_orders(
    """distinct select on columns"""
    distinct_on: [swap_orders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [swap_orders_order_by!]

    """filter the rows returned"""
    where: swap_orders_bool_exp
  ): [swap_orders!]!

  """An aggregate relationship"""
  swap_orders_aggregate(
    """distinct select on columns"""
    distinct_on: [swap_orders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [swap_orders_order_by!]

    """filter the rows returned"""
    where: swap_orders_bool_exp
  ): swap_orders_aggregate!

  """fetch data from the table: "swap_orders" using primary key columns"""
  swap_orders_by_pk(id: uuid!): swap_orders

  """
  fetch data from the table: "trust_network"
  """
  trust_network(
    """distinct select on columns"""
    distinct_on: [trust_network_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [trust_network_order_by!]

    """filter the rows returned"""
    where: trust_network_bool_exp
  ): [trust_network!]!

  """
  fetch aggregated fields from the table: "trust_network"
  """
  trust_network_aggregate(
    """distinct select on columns"""
    distinct_on: [trust_network_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [trust_network_order_by!]

    """filter the rows returned"""
    where: trust_network_bool_exp
  ): trust_network_aggregate!

  """fetch data from the table: "trust_network" using primary key columns"""
  trust_network_by_pk(account: String!, trust: String!): trust_network

  """
  fetch data from the table: "trust_network_notification"
  """
  trust_network_notification(
    """distinct select on columns"""
    distinct_on: [trust_network_notification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [trust_network_notification_order_by!]

    """filter the rows returned"""
    where: trust_network_notification_bool_exp
  ): [trust_network_notification!]!

  """
  fetch aggregated fields from the table: "trust_network_notification"
  """
  trust_network_notification_aggregate(
    """distinct select on columns"""
    distinct_on: [trust_network_notification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [trust_network_notification_order_by!]

    """filter the rows returned"""
    where: trust_network_notification_bool_exp
  ): trust_network_notification_aggregate!

  """
  fetch data from the table: "trust_network_notification" using primary key columns
  """
  trust_network_notification_by_pk(account: String!, trust: String!): trust_network_notification

  """
  fetch data from the table: "trust_network_status"
  """
  trust_network_status(
    """distinct select on columns"""
    distinct_on: [trust_network_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [trust_network_status_order_by!]

    """filter the rows returned"""
    where: trust_network_status_bool_exp
  ): [trust_network_status!]!

  """
  fetch aggregated fields from the table: "trust_network_status"
  """
  trust_network_status_aggregate(
    """distinct select on columns"""
    distinct_on: [trust_network_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [trust_network_status_order_by!]

    """filter the rows returned"""
    where: trust_network_status_bool_exp
  ): trust_network_status_aggregate!

  """
  fetch data from the table: "trust_network_status" using primary key columns
  """
  trust_network_status_by_pk(status: String!): trust_network_status
}

"""
columns and relationships of "reg_accounts"
"""
type reg_accounts {
  account: String!

  """An object relationship"""
  accounts_information: accounts_information
  create_account: Boolean
  created: timestamptz
  created_at: timestamp
  cred_id: String
  device_name: String

  """An array relationship"""
  devices(
    """distinct select on columns"""
    distinct_on: [devices_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [devices_order_by!]

    """filter the rows returned"""
    where: devices_bool_exp
  ): [devices!]!

  """An aggregate relationship"""
  devices_aggregate(
    """distinct select on columns"""
    distinct_on: [devices_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [devices_order_by!]

    """filter the rows returned"""
    where: devices_bool_exp
  ): devices_aggregate!
  id: uuid!

  """An array relationship"""
  messages_from(
    """distinct select on columns"""
    distinct_on: [messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [messages_order_by!]

    """filter the rows returned"""
    where: messages_bool_exp
  ): [messages!]!

  """An aggregate relationship"""
  messages_from_aggregate(
    """distinct select on columns"""
    distinct_on: [messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [messages_order_by!]

    """filter the rows returned"""
    where: messages_bool_exp
  ): messages_aggregate!

  """An array relationship"""
  messages_to(
    """distinct select on columns"""
    distinct_on: [messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [messages_order_by!]

    """filter the rows returned"""
    where: messages_bool_exp
  ): [messages!]!

  """An aggregate relationship"""
  messages_to_aggregate(
    """distinct select on columns"""
    distinct_on: [messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [messages_order_by!]

    """filter the rows returned"""
    where: messages_bool_exp
  ): messages_aggregate!

  """An array relationship"""
  notifications_from(
    """distinct select on columns"""
    distinct_on: [notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notifications_order_by!]

    """filter the rows returned"""
    where: notifications_bool_exp
  ): [notifications!]!

  """An aggregate relationship"""
  notifications_from_aggregate(
    """distinct select on columns"""
    distinct_on: [notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notifications_order_by!]

    """filter the rows returned"""
    where: notifications_bool_exp
  ): notifications_aggregate!

  """An array relationship"""
  notifications_to(
    """distinct select on columns"""
    distinct_on: [notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notifications_order_by!]

    """filter the rows returned"""
    where: notifications_bool_exp
  ): [notifications!]!

  """An aggregate relationship"""
  notifications_to_aggregate(
    """distinct select on columns"""
    distinct_on: [notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notifications_order_by!]

    """filter the rows returned"""
    where: notifications_bool_exp
  ): notifications_aggregate!
  onboarded: Boolean

  """An array relationship"""
  p2p_offers_buyer(
    """distinct select on columns"""
    distinct_on: [p2p_offers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [p2p_offers_order_by!]

    """filter the rows returned"""
    where: p2p_offers_bool_exp
  ): [p2p_offers!]!

  """An aggregate relationship"""
  p2p_offers_buyer_aggregate(
    """distinct select on columns"""
    distinct_on: [p2p_offers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [p2p_offers_order_by!]

    """filter the rows returned"""
    where: p2p_offers_bool_exp
  ): p2p_offers_aggregate!

  """An array relationship"""
  p2p_offers_initiator(
    """distinct select on columns"""
    distinct_on: [p2p_offers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [p2p_offers_order_by!]

    """filter the rows returned"""
    where: p2p_offers_bool_exp
  ): [p2p_offers!]!

  """An aggregate relationship"""
  p2p_offers_initiator_aggregate(
    """distinct select on columns"""
    distinct_on: [p2p_offers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [p2p_offers_order_by!]

    """filter the rows returned"""
    where: p2p_offers_bool_exp
  ): p2p_offers_aggregate!

  """An array relationship"""
  p2p_offers_seller(
    """distinct select on columns"""
    distinct_on: [p2p_offers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [p2p_offers_order_by!]

    """filter the rows returned"""
    where: p2p_offers_bool_exp
  ): [p2p_offers!]!

  """An aggregate relationship"""
  p2p_offers_seller_aggregate(
    """distinct select on columns"""
    distinct_on: [p2p_offers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [p2p_offers_order_by!]

    """filter the rows returned"""
    where: p2p_offers_bool_exp
  ): p2p_offers_aggregate!
  public_key: String
  referrer: String!

  """An array relationship"""
  reg_accounts_accounts_information(
    """distinct select on columns"""
    distinct_on: [accounts_information_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_information_order_by!]

    """filter the rows returned"""
    where: accounts_information_bool_exp
  ): [accounts_information!]!

  """An aggregate relationship"""
  reg_accounts_accounts_information_aggregate(
    """distinct select on columns"""
    distinct_on: [accounts_information_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_information_order_by!]

    """filter the rows returned"""
    where: accounts_information_bool_exp
  ): accounts_information_aggregate!

  """An array relationship"""
  swap_orders(
    """distinct select on columns"""
    distinct_on: [swap_orders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [swap_orders_order_by!]

    """filter the rows returned"""
    where: swap_orders_bool_exp
  ): [swap_orders!]!

  """An aggregate relationship"""
  swap_orders_aggregate(
    """distinct select on columns"""
    distinct_on: [swap_orders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [swap_orders_order_by!]

    """filter the rows returned"""
    where: swap_orders_bool_exp
  ): swap_orders_aggregate!

  """An array relationship"""
  trustNetworkNotificationsByTrust(
    """distinct select on columns"""
    distinct_on: [trust_network_notification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [trust_network_notification_order_by!]

    """filter the rows returned"""
    where: trust_network_notification_bool_exp
  ): [trust_network_notification!]!

  """An aggregate relationship"""
  trustNetworkNotificationsByTrust_aggregate(
    """distinct select on columns"""
    distinct_on: [trust_network_notification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [trust_network_notification_order_by!]

    """filter the rows returned"""
    where: trust_network_notification_bool_exp
  ): trust_network_notification_aggregate!

  """An array relationship"""
  trust_network_notifications(
    """distinct select on columns"""
    distinct_on: [trust_network_notification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [trust_network_notification_order_by!]

    """filter the rows returned"""
    where: trust_network_notification_bool_exp
  ): [trust_network_notification!]!

  """An aggregate relationship"""
  trust_network_notifications_aggregate(
    """distinct select on columns"""
    distinct_on: [trust_network_notification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [trust_network_notification_order_by!]

    """filter the rows returned"""
    where: trust_network_notification_bool_exp
  ): trust_network_notification_aggregate!

  """An array relationship"""
  trust_networks_by_account(
    """distinct select on columns"""
    distinct_on: [trust_network_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [trust_network_order_by!]

    """filter the rows returned"""
    where: trust_network_bool_exp
  ): [trust_network!]!

  """An aggregate relationship"""
  trust_networks_by_account_aggregate(
    """distinct select on columns"""
    distinct_on: [trust_network_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [trust_network_order_by!]

    """filter the rows returned"""
    where: trust_network_bool_exp
  ): trust_network_aggregate!

  """An array relationship"""
  trust_networks_by_trust(
    """distinct select on columns"""
    distinct_on: [trust_network_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [trust_network_order_by!]

    """filter the rows returned"""
    where: trust_network_bool_exp
  ): [trust_network!]!

  """An aggregate relationship"""
  trust_networks_by_trust_aggregate(
    """distinct select on columns"""
    distinct_on: [trust_network_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [trust_network_order_by!]

    """filter the rows returned"""
    where: trust_network_bool_exp
  ): trust_network_aggregate!
  txid: String
}

"""
aggregated selection of "reg_accounts"
"""
type reg_accounts_aggregate {
  aggregate: reg_accounts_aggregate_fields
  nodes: [reg_accounts!]!
}

"""
aggregate fields of "reg_accounts"
"""
type reg_accounts_aggregate_fields {
  count(columns: [reg_accounts_select_column!], distinct: Boolean): Int!
  max: reg_accounts_max_fields
  min: reg_accounts_min_fields
}

"""
Boolean expression to filter rows from the table "reg_accounts". All fields are combined with a logical 'AND'.
"""
input reg_accounts_bool_exp {
  _and: [reg_accounts_bool_exp!]
  _not: reg_accounts_bool_exp
  _or: [reg_accounts_bool_exp!]
  account: String_comparison_exp
  accounts_information: accounts_information_bool_exp
  create_account: Boolean_comparison_exp
  created: timestamptz_comparison_exp
  created_at: timestamp_comparison_exp
  cred_id: String_comparison_exp
  device_name: String_comparison_exp
  devices: devices_bool_exp
  devices_aggregate: devices_aggregate_bool_exp
  id: uuid_comparison_exp
  messages_from: messages_bool_exp
  messages_from_aggregate: messages_aggregate_bool_exp
  messages_to: messages_bool_exp
  messages_to_aggregate: messages_aggregate_bool_exp
  notifications_from: notifications_bool_exp
  notifications_from_aggregate: notifications_aggregate_bool_exp
  notifications_to: notifications_bool_exp
  notifications_to_aggregate: notifications_aggregate_bool_exp
  onboarded: Boolean_comparison_exp
  p2p_offers_buyer: p2p_offers_bool_exp
  p2p_offers_buyer_aggregate: p2p_offers_aggregate_bool_exp
  p2p_offers_initiator: p2p_offers_bool_exp
  p2p_offers_initiator_aggregate: p2p_offers_aggregate_bool_exp
  p2p_offers_seller: p2p_offers_bool_exp
  p2p_offers_seller_aggregate: p2p_offers_aggregate_bool_exp
  public_key: String_comparison_exp
  referrer: String_comparison_exp
  reg_accounts_accounts_information: accounts_information_bool_exp
  reg_accounts_accounts_information_aggregate: accounts_information_aggregate_bool_exp
  swap_orders: swap_orders_bool_exp
  swap_orders_aggregate: swap_orders_aggregate_bool_exp
  trustNetworkNotificationsByTrust: trust_network_notification_bool_exp
  trustNetworkNotificationsByTrust_aggregate: trust_network_notification_aggregate_bool_exp
  trust_network_notifications: trust_network_notification_bool_exp
  trust_network_notifications_aggregate: trust_network_notification_aggregate_bool_exp
  trust_networks_by_account: trust_network_bool_exp
  trust_networks_by_account_aggregate: trust_network_aggregate_bool_exp
  trust_networks_by_trust: trust_network_bool_exp
  trust_networks_by_trust_aggregate: trust_network_aggregate_bool_exp
  txid: String_comparison_exp
}

"""
unique or primary key constraints on table "reg_accounts"
"""
enum reg_accounts_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  accounts_pkey

  """
  unique or primary key constraint on columns "account"
  """
  reg_accounts_account_key
}

"""
input type for inserting data into table "reg_accounts"
"""
input reg_accounts_insert_input {
  account: String
  accounts_information: accounts_information_obj_rel_insert_input
  create_account: Boolean
  created: timestamptz
  created_at: timestamp
  cred_id: String
  device_name: String
  devices: devices_arr_rel_insert_input
  id: uuid
  messages_from: messages_arr_rel_insert_input
  messages_to: messages_arr_rel_insert_input
  notifications_from: notifications_arr_rel_insert_input
  notifications_to: notifications_arr_rel_insert_input
  onboarded: Boolean
  p2p_offers_buyer: p2p_offers_arr_rel_insert_input
  p2p_offers_initiator: p2p_offers_arr_rel_insert_input
  p2p_offers_seller: p2p_offers_arr_rel_insert_input
  public_key: String
  referrer: String
  reg_accounts_accounts_information: accounts_information_arr_rel_insert_input
  swap_orders: swap_orders_arr_rel_insert_input
  trustNetworkNotificationsByTrust: trust_network_notification_arr_rel_insert_input
  trust_network_notifications: trust_network_notification_arr_rel_insert_input
  trust_networks_by_account: trust_network_arr_rel_insert_input
  trust_networks_by_trust: trust_network_arr_rel_insert_input
  txid: String
}

"""aggregate max on columns"""
type reg_accounts_max_fields {
  account: String
  created: timestamptz
  created_at: timestamp
  cred_id: String
  device_name: String
  id: uuid
  public_key: String
  referrer: String
  txid: String
}

"""aggregate min on columns"""
type reg_accounts_min_fields {
  account: String
  created: timestamptz
  created_at: timestamp
  cred_id: String
  device_name: String
  id: uuid
  public_key: String
  referrer: String
  txid: String
}

"""
response of any mutation on the table "reg_accounts"
"""
type reg_accounts_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [reg_accounts!]!
}

"""
input type for inserting object relation for remote table "reg_accounts"
"""
input reg_accounts_obj_rel_insert_input {
  data: reg_accounts_insert_input!

  """upsert condition"""
  on_conflict: reg_accounts_on_conflict
}

"""
on_conflict condition type for table "reg_accounts"
"""
input reg_accounts_on_conflict {
  constraint: reg_accounts_constraint!
  update_columns: [reg_accounts_update_column!]! = []
  where: reg_accounts_bool_exp
}

"""Ordering options when selecting data from "reg_accounts"."""
input reg_accounts_order_by {
  account: order_by
  accounts_information: accounts_information_order_by
  create_account: order_by
  created: order_by
  created_at: order_by
  cred_id: order_by
  device_name: order_by
  devices_aggregate: devices_aggregate_order_by
  id: order_by
  messages_from_aggregate: messages_aggregate_order_by
  messages_to_aggregate: messages_aggregate_order_by
  notifications_from_aggregate: notifications_aggregate_order_by
  notifications_to_aggregate: notifications_aggregate_order_by
  onboarded: order_by
  p2p_offers_buyer_aggregate: p2p_offers_aggregate_order_by
  p2p_offers_initiator_aggregate: p2p_offers_aggregate_order_by
  p2p_offers_seller_aggregate: p2p_offers_aggregate_order_by
  public_key: order_by
  referrer: order_by
  reg_accounts_accounts_information_aggregate: accounts_information_aggregate_order_by
  swap_orders_aggregate: swap_orders_aggregate_order_by
  trustNetworkNotificationsByTrust_aggregate: trust_network_notification_aggregate_order_by
  trust_network_notifications_aggregate: trust_network_notification_aggregate_order_by
  trust_networks_by_account_aggregate: trust_network_aggregate_order_by
  trust_networks_by_trust_aggregate: trust_network_aggregate_order_by
  txid: order_by
}

"""primary key columns input for table: reg_accounts"""
input reg_accounts_pk_columns_input {
  id: uuid!
}

"""
select columns of table "reg_accounts"
"""
enum reg_accounts_select_column {
  """column name"""
  account

  """column name"""
  create_account

  """column name"""
  created

  """column name"""
  created_at

  """column name"""
  cred_id

  """column name"""
  device_name

  """column name"""
  id

  """column name"""
  onboarded

  """column name"""
  public_key

  """column name"""
  referrer

  """column name"""
  txid
}

"""
input type for updating data in table "reg_accounts"
"""
input reg_accounts_set_input {
  account: String
  create_account: Boolean
  created: timestamptz
  created_at: timestamp
  cred_id: String
  device_name: String
  id: uuid
  onboarded: Boolean
  public_key: String
  referrer: String
  txid: String
}

"""
Streaming cursor of the table "reg_accounts"
"""
input reg_accounts_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: reg_accounts_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input reg_accounts_stream_cursor_value_input {
  account: String
  create_account: Boolean
  created: timestamptz
  created_at: timestamp
  cred_id: String
  device_name: String
  id: uuid
  onboarded: Boolean
  public_key: String
  referrer: String
  txid: String
}

"""
update columns of table "reg_accounts"
"""
enum reg_accounts_update_column {
  """column name"""
  account

  """column name"""
  create_account

  """column name"""
  created

  """column name"""
  created_at

  """column name"""
  cred_id

  """column name"""
  device_name

  """column name"""
  id

  """column name"""
  onboarded

  """column name"""
  public_key

  """column name"""
  referrer

  """column name"""
  txid
}

input reg_accounts_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: reg_accounts_set_input

  """filter the rows which have to be updated"""
  where: reg_accounts_bool_exp!
}

input request_new_account_input {
  account: String!
  create_account: Boolean
  cred_id: String!
  device_name: String!
  email_address: String!
  newsletter_subscription: Boolean!
  phone_number: String!
  public_key: String!
  referrer: String!
}

type request_new_account_output {
  id: String!
}

"""
columns and relationships of "signing_requests"
"""
type signing_requests {
  createdAt: timestamptz!
  esr: String!
  id: uuid!
  signature: String
  signer: String!
  status: String!
  transactionId: String
  updatedAt: timestamptz!
}

"""
aggregated selection of "signing_requests"
"""
type signing_requests_aggregate {
  aggregate: signing_requests_aggregate_fields
  nodes: [signing_requests!]!
}

"""
aggregate fields of "signing_requests"
"""
type signing_requests_aggregate_fields {
  count(columns: [signing_requests_select_column!], distinct: Boolean): Int!
  max: signing_requests_max_fields
  min: signing_requests_min_fields
}

"""
Boolean expression to filter rows from the table "signing_requests". All fields are combined with a logical 'AND'.
"""
input signing_requests_bool_exp {
  _and: [signing_requests_bool_exp!]
  _not: signing_requests_bool_exp
  _or: [signing_requests_bool_exp!]
  createdAt: timestamptz_comparison_exp
  esr: String_comparison_exp
  id: uuid_comparison_exp
  signature: String_comparison_exp
  signer: String_comparison_exp
  status: String_comparison_exp
  transactionId: String_comparison_exp
  updatedAt: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "signing_requests"
"""
enum signing_requests_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  signing_requests_pkey
}

"""
input type for inserting data into table "signing_requests"
"""
input signing_requests_insert_input {
  createdAt: timestamptz
  esr: String
  id: uuid
  signature: String
  signer: String
  status: String
  transactionId: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type signing_requests_max_fields {
  createdAt: timestamptz
  esr: String
  id: uuid
  signature: String
  signer: String
  status: String
  transactionId: String
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type signing_requests_min_fields {
  createdAt: timestamptz
  esr: String
  id: uuid
  signature: String
  signer: String
  status: String
  transactionId: String
  updatedAt: timestamptz
}

"""
response of any mutation on the table "signing_requests"
"""
type signing_requests_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [signing_requests!]!
}

"""
on_conflict condition type for table "signing_requests"
"""
input signing_requests_on_conflict {
  constraint: signing_requests_constraint!
  update_columns: [signing_requests_update_column!]! = []
  where: signing_requests_bool_exp
}

"""Ordering options when selecting data from "signing_requests"."""
input signing_requests_order_by {
  createdAt: order_by
  esr: order_by
  id: order_by
  signature: order_by
  signer: order_by
  status: order_by
  transactionId: order_by
  updatedAt: order_by
}

"""primary key columns input for table: signing_requests"""
input signing_requests_pk_columns_input {
  id: uuid!
}

"""
select columns of table "signing_requests"
"""
enum signing_requests_select_column {
  """column name"""
  createdAt

  """column name"""
  esr

  """column name"""
  id

  """column name"""
  signature

  """column name"""
  signer

  """column name"""
  status

  """column name"""
  transactionId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "signing_requests"
"""
input signing_requests_set_input {
  createdAt: timestamptz
  esr: String
  id: uuid
  signature: String
  signer: String
  status: String
  transactionId: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "signing_requests"
"""
input signing_requests_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: signing_requests_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input signing_requests_stream_cursor_value_input {
  createdAt: timestamptz
  esr: String
  id: uuid
  signature: String
  signer: String
  status: String
  transactionId: String
  updatedAt: timestamptz
}

"""
update columns of table "signing_requests"
"""
enum signing_requests_update_column {
  """column name"""
  createdAt

  """column name"""
  esr

  """column name"""
  id

  """column name"""
  signature

  """column name"""
  signer

  """column name"""
  status

  """column name"""
  transactionId

  """column name"""
  updatedAt
}

input signing_requests_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: signing_requests_set_input

  """filter the rows which have to be updated"""
  where: signing_requests_bool_exp!
}

type subscription_root {
  """
  fetch data from the table: "accounts_information"
  """
  accounts_information(
    """distinct select on columns"""
    distinct_on: [accounts_information_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_information_order_by!]

    """filter the rows returned"""
    where: accounts_information_bool_exp
  ): [accounts_information!]!

  """
  fetch aggregated fields from the table: "accounts_information"
  """
  accounts_information_aggregate(
    """distinct select on columns"""
    distinct_on: [accounts_information_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_information_order_by!]

    """filter the rows returned"""
    where: accounts_information_bool_exp
  ): accounts_information_aggregate!

  """
  fetch data from the table: "accounts_information" using primary key columns
  """
  accounts_information_by_pk(account: String!, id: uuid!): accounts_information

  """
  fetch data from the table in a streaming manner: "accounts_information"
  """
  accounts_information_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [accounts_information_stream_cursor_input]!

    """filter the rows returned"""
    where: accounts_information_bool_exp
  ): [accounts_information!]!

  """An array relationship"""
  devices(
    """distinct select on columns"""
    distinct_on: [devices_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [devices_order_by!]

    """filter the rows returned"""
    where: devices_bool_exp
  ): [devices!]!

  """An aggregate relationship"""
  devices_aggregate(
    """distinct select on columns"""
    distinct_on: [devices_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [devices_order_by!]

    """filter the rows returned"""
    where: devices_bool_exp
  ): devices_aggregate!

  """fetch data from the table: "devices" using primary key columns"""
  devices_by_pk(cred_id: String!): devices

  """
  fetch data from the table in a streaming manner: "devices"
  """
  devices_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [devices_stream_cursor_input]!

    """filter the rows returned"""
    where: devices_bool_exp
  ): [devices!]!

  """An array relationship"""
  messages(
    """distinct select on columns"""
    distinct_on: [messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [messages_order_by!]

    """filter the rows returned"""
    where: messages_bool_exp
  ): [messages!]!

  """An aggregate relationship"""
  messages_aggregate(
    """distinct select on columns"""
    distinct_on: [messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [messages_order_by!]

    """filter the rows returned"""
    where: messages_bool_exp
  ): messages_aggregate!

  """fetch data from the table: "messages" using primary key columns"""
  messages_by_pk(id: uuid!): messages

  """
  fetch data from the table in a streaming manner: "messages"
  """
  messages_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [messages_stream_cursor_input]!

    """filter the rows returned"""
    where: messages_bool_exp
  ): [messages!]!

  """
  fetch data from the table: "migrate_device"
  """
  migrate_device(
    """distinct select on columns"""
    distinct_on: [migrate_device_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [migrate_device_order_by!]

    """filter the rows returned"""
    where: migrate_device_bool_exp
  ): [migrate_device!]!

  """
  fetch aggregated fields from the table: "migrate_device"
  """
  migrate_device_aggregate(
    """distinct select on columns"""
    distinct_on: [migrate_device_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [migrate_device_order_by!]

    """filter the rows returned"""
    where: migrate_device_bool_exp
  ): migrate_device_aggregate!

  """fetch data from the table: "migrate_device" using primary key columns"""
  migrate_device_by_pk(cred_id: String!): migrate_device

  """
  fetch data from the table in a streaming manner: "migrate_device"
  """
  migrate_device_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [migrate_device_stream_cursor_input]!

    """filter the rows returned"""
    where: migrate_device_bool_exp
  ): [migrate_device!]!

  """
  fetch data from the table: "notifications"
  """
  notifications(
    """distinct select on columns"""
    distinct_on: [notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notifications_order_by!]

    """filter the rows returned"""
    where: notifications_bool_exp
  ): [notifications!]!

  """
  fetch aggregated fields from the table: "notifications"
  """
  notifications_aggregate(
    """distinct select on columns"""
    distinct_on: [notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notifications_order_by!]

    """filter the rows returned"""
    where: notifications_bool_exp
  ): notifications_aggregate!

  """fetch data from the table: "notifications" using primary key columns"""
  notifications_by_pk(id: uuid!): notifications

  """
  fetch data from the table in a streaming manner: "notifications"
  """
  notifications_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [notifications_stream_cursor_input]!

    """filter the rows returned"""
    where: notifications_bool_exp
  ): [notifications!]!

  """
  fetch data from the table: "p2p_offers"
  """
  p2p_offers(
    """distinct select on columns"""
    distinct_on: [p2p_offers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [p2p_offers_order_by!]

    """filter the rows returned"""
    where: p2p_offers_bool_exp
  ): [p2p_offers!]!

  """
  fetch aggregated fields from the table: "p2p_offers"
  """
  p2p_offers_aggregate(
    """distinct select on columns"""
    distinct_on: [p2p_offers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [p2p_offers_order_by!]

    """filter the rows returned"""
    where: p2p_offers_bool_exp
  ): p2p_offers_aggregate!

  """fetch data from the table: "p2p_offers" using primary key columns"""
  p2p_offers_by_pk(id: uuid!): p2p_offers

  """
  fetch data from the table in a streaming manner: "p2p_offers"
  """
  p2p_offers_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [p2p_offers_stream_cursor_input]!

    """filter the rows returned"""
    where: p2p_offers_bool_exp
  ): [p2p_offers!]!

  """
  fetch data from the table: "preferences"
  """
  preferences(
    """distinct select on columns"""
    distinct_on: [preferences_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [preferences_order_by!]

    """filter the rows returned"""
    where: preferences_bool_exp
  ): [preferences!]!

  """
  fetch aggregated fields from the table: "preferences"
  """
  preferences_aggregate(
    """distinct select on columns"""
    distinct_on: [preferences_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [preferences_order_by!]

    """filter the rows returned"""
    where: preferences_bool_exp
  ): preferences_aggregate!

  """fetch data from the table: "preferences" using primary key columns"""
  preferences_by_pk(account: String!): preferences

  """
  fetch data from the table in a streaming manner: "preferences"
  """
  preferences_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [preferences_stream_cursor_input]!

    """filter the rows returned"""
    where: preferences_bool_exp
  ): [preferences!]!

  """
  fetch data from the table: "reg_accounts"
  """
  reg_accounts(
    """distinct select on columns"""
    distinct_on: [reg_accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [reg_accounts_order_by!]

    """filter the rows returned"""
    where: reg_accounts_bool_exp
  ): [reg_accounts!]!

  """
  fetch aggregated fields from the table: "reg_accounts"
  """
  reg_accounts_aggregate(
    """distinct select on columns"""
    distinct_on: [reg_accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [reg_accounts_order_by!]

    """filter the rows returned"""
    where: reg_accounts_bool_exp
  ): reg_accounts_aggregate!

  """fetch data from the table: "reg_accounts" using primary key columns"""
  reg_accounts_by_pk(id: uuid!): reg_accounts

  """
  fetch data from the table in a streaming manner: "reg_accounts"
  """
  reg_accounts_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [reg_accounts_stream_cursor_input]!

    """filter the rows returned"""
    where: reg_accounts_bool_exp
  ): [reg_accounts!]!

  """
  fetch data from the table: "signing_requests"
  """
  signing_requests(
    """distinct select on columns"""
    distinct_on: [signing_requests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [signing_requests_order_by!]

    """filter the rows returned"""
    where: signing_requests_bool_exp
  ): [signing_requests!]!

  """
  fetch aggregated fields from the table: "signing_requests"
  """
  signing_requests_aggregate(
    """distinct select on columns"""
    distinct_on: [signing_requests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [signing_requests_order_by!]

    """filter the rows returned"""
    where: signing_requests_bool_exp
  ): signing_requests_aggregate!

  """
  fetch data from the table: "signing_requests" using primary key columns
  """
  signing_requests_by_pk(id: uuid!): signing_requests

  """
  fetch data from the table in a streaming manner: "signing_requests"
  """
  signing_requests_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [signing_requests_stream_cursor_input]!

    """filter the rows returned"""
    where: signing_requests_bool_exp
  ): [signing_requests!]!

  """
  fetch data from the table: "swap_assets"
  """
  swap_assets(
    """distinct select on columns"""
    distinct_on: [swap_assets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [swap_assets_order_by!]

    """filter the rows returned"""
    where: swap_assets_bool_exp
  ): [swap_assets!]!

  """
  fetch aggregated fields from the table: "swap_assets"
  """
  swap_assets_aggregate(
    """distinct select on columns"""
    distinct_on: [swap_assets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [swap_assets_order_by!]

    """filter the rows returned"""
    where: swap_assets_bool_exp
  ): swap_assets_aggregate!

  """fetch data from the table: "swap_assets" using primary key columns"""
  swap_assets_by_pk(asset: String!, chain: String!): swap_assets

  """
  fetch data from the table in a streaming manner: "swap_assets"
  """
  swap_assets_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [swap_assets_stream_cursor_input]!

    """filter the rows returned"""
    where: swap_assets_bool_exp
  ): [swap_assets!]!

  """An array relationship"""
  swap_orders(
    """distinct select on columns"""
    distinct_on: [swap_orders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [swap_orders_order_by!]

    """filter the rows returned"""
    where: swap_orders_bool_exp
  ): [swap_orders!]!

  """An aggregate relationship"""
  swap_orders_aggregate(
    """distinct select on columns"""
    distinct_on: [swap_orders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [swap_orders_order_by!]

    """filter the rows returned"""
    where: swap_orders_bool_exp
  ): swap_orders_aggregate!

  """fetch data from the table: "swap_orders" using primary key columns"""
  swap_orders_by_pk(id: uuid!): swap_orders

  """
  fetch data from the table in a streaming manner: "swap_orders"
  """
  swap_orders_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [swap_orders_stream_cursor_input]!

    """filter the rows returned"""
    where: swap_orders_bool_exp
  ): [swap_orders!]!

  """
  fetch data from the table: "trust_network"
  """
  trust_network(
    """distinct select on columns"""
    distinct_on: [trust_network_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [trust_network_order_by!]

    """filter the rows returned"""
    where: trust_network_bool_exp
  ): [trust_network!]!

  """
  fetch aggregated fields from the table: "trust_network"
  """
  trust_network_aggregate(
    """distinct select on columns"""
    distinct_on: [trust_network_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [trust_network_order_by!]

    """filter the rows returned"""
    where: trust_network_bool_exp
  ): trust_network_aggregate!

  """fetch data from the table: "trust_network" using primary key columns"""
  trust_network_by_pk(account: String!, trust: String!): trust_network

  """
  fetch data from the table: "trust_network_notification"
  """
  trust_network_notification(
    """distinct select on columns"""
    distinct_on: [trust_network_notification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [trust_network_notification_order_by!]

    """filter the rows returned"""
    where: trust_network_notification_bool_exp
  ): [trust_network_notification!]!

  """
  fetch aggregated fields from the table: "trust_network_notification"
  """
  trust_network_notification_aggregate(
    """distinct select on columns"""
    distinct_on: [trust_network_notification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [trust_network_notification_order_by!]

    """filter the rows returned"""
    where: trust_network_notification_bool_exp
  ): trust_network_notification_aggregate!

  """
  fetch data from the table: "trust_network_notification" using primary key columns
  """
  trust_network_notification_by_pk(account: String!, trust: String!): trust_network_notification

  """
  fetch data from the table in a streaming manner: "trust_network_notification"
  """
  trust_network_notification_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [trust_network_notification_stream_cursor_input]!

    """filter the rows returned"""
    where: trust_network_notification_bool_exp
  ): [trust_network_notification!]!

  """
  fetch data from the table: "trust_network_status"
  """
  trust_network_status(
    """distinct select on columns"""
    distinct_on: [trust_network_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [trust_network_status_order_by!]

    """filter the rows returned"""
    where: trust_network_status_bool_exp
  ): [trust_network_status!]!

  """
  fetch aggregated fields from the table: "trust_network_status"
  """
  trust_network_status_aggregate(
    """distinct select on columns"""
    distinct_on: [trust_network_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [trust_network_status_order_by!]

    """filter the rows returned"""
    where: trust_network_status_bool_exp
  ): trust_network_status_aggregate!

  """
  fetch data from the table: "trust_network_status" using primary key columns
  """
  trust_network_status_by_pk(status: String!): trust_network_status

  """
  fetch data from the table in a streaming manner: "trust_network_status"
  """
  trust_network_status_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [trust_network_status_stream_cursor_input]!

    """filter the rows returned"""
    where: trust_network_status_bool_exp
  ): [trust_network_status!]!

  """
  fetch data from the table in a streaming manner: "trust_network"
  """
  trust_network_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [trust_network_stream_cursor_input]!

    """filter the rows returned"""
    where: trust_network_bool_exp
  ): [trust_network!]!
}

"""
columns and relationships of "swap_assets"
"""
type swap_assets {
  active_swaps: Boolean!
  asset: String!
  asset_name: String!
  chain: String!
  wallet_address: String!
}

"""
aggregated selection of "swap_assets"
"""
type swap_assets_aggregate {
  aggregate: swap_assets_aggregate_fields
  nodes: [swap_assets!]!
}

"""
aggregate fields of "swap_assets"
"""
type swap_assets_aggregate_fields {
  count(columns: [swap_assets_select_column!], distinct: Boolean): Int!
  max: swap_assets_max_fields
  min: swap_assets_min_fields
}

"""
Boolean expression to filter rows from the table "swap_assets". All fields are combined with a logical 'AND'.
"""
input swap_assets_bool_exp {
  _and: [swap_assets_bool_exp!]
  _not: swap_assets_bool_exp
  _or: [swap_assets_bool_exp!]
  active_swaps: Boolean_comparison_exp
  asset: String_comparison_exp
  asset_name: String_comparison_exp
  chain: String_comparison_exp
  wallet_address: String_comparison_exp
}

"""
unique or primary key constraints on table "swap_assets"
"""
enum swap_assets_constraint {
  """
  unique or primary key constraint on columns "chain", "asset"
  """
  swap_assets_pkey
}

"""
input type for inserting data into table "swap_assets"
"""
input swap_assets_insert_input {
  active_swaps: Boolean
  asset: String
  asset_name: String
  chain: String
  wallet_address: String
}

"""aggregate max on columns"""
type swap_assets_max_fields {
  asset: String
  asset_name: String
  chain: String
  wallet_address: String
}

"""aggregate min on columns"""
type swap_assets_min_fields {
  asset: String
  asset_name: String
  chain: String
  wallet_address: String
}

"""
response of any mutation on the table "swap_assets"
"""
type swap_assets_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [swap_assets!]!
}

"""
on_conflict condition type for table "swap_assets"
"""
input swap_assets_on_conflict {
  constraint: swap_assets_constraint!
  update_columns: [swap_assets_update_column!]! = []
  where: swap_assets_bool_exp
}

"""Ordering options when selecting data from "swap_assets"."""
input swap_assets_order_by {
  active_swaps: order_by
  asset: order_by
  asset_name: order_by
  chain: order_by
  wallet_address: order_by
}

"""primary key columns input for table: swap_assets"""
input swap_assets_pk_columns_input {
  asset: String!
  chain: String!
}

"""
select columns of table "swap_assets"
"""
enum swap_assets_select_column {
  """column name"""
  active_swaps

  """column name"""
  asset

  """column name"""
  asset_name

  """column name"""
  chain

  """column name"""
  wallet_address
}

"""
input type for updating data in table "swap_assets"
"""
input swap_assets_set_input {
  active_swaps: Boolean
  asset: String
  asset_name: String
  chain: String
  wallet_address: String
}

"""
Streaming cursor of the table "swap_assets"
"""
input swap_assets_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: swap_assets_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input swap_assets_stream_cursor_value_input {
  active_swaps: Boolean
  asset: String
  asset_name: String
  chain: String
  wallet_address: String
}

"""
update columns of table "swap_assets"
"""
enum swap_assets_update_column {
  """column name"""
  active_swaps

  """column name"""
  asset

  """column name"""
  asset_name

  """column name"""
  chain

  """column name"""
  wallet_address
}

input swap_assets_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: swap_assets_set_input

  """filter the rows which have to be updated"""
  where: swap_assets_bool_exp!
}

"""
columns and relationships of "swap_orders"
"""
type swap_orders {
  asset: String!
  asset_amount: float8!
  masterbots_account: String!
  masterbots_amount: float8!
  masterbots_currency: String!
  masterbots_trx: String
  created_at: timestamptz!
  gems_id: String
  id: uuid!
  order_status: String!
  order_type: String!
  price: float8!

  """An object relationship"""
  reg_account: reg_accounts!
  updated_at: timestamptz!
  wallet_address: String!
}

"""
aggregated selection of "swap_orders"
"""
type swap_orders_aggregate {
  aggregate: swap_orders_aggregate_fields
  nodes: [swap_orders!]!
}

input swap_orders_aggregate_bool_exp {
  avg: swap_orders_aggregate_bool_exp_avg
  corr: swap_orders_aggregate_bool_exp_corr
  count: swap_orders_aggregate_bool_exp_count
  covar_samp: swap_orders_aggregate_bool_exp_covar_samp
  max: swap_orders_aggregate_bool_exp_max
  min: swap_orders_aggregate_bool_exp_min
  stddev_samp: swap_orders_aggregate_bool_exp_stddev_samp
  sum: swap_orders_aggregate_bool_exp_sum
  var_samp: swap_orders_aggregate_bool_exp_var_samp
}

input swap_orders_aggregate_bool_exp_avg {
  arguments: swap_orders_select_column_swap_orders_aggregate_bool_exp_avg_arguments_columns!
  distinct: Boolean
  filter: swap_orders_bool_exp
  predicate: float8_comparison_exp!
}

input swap_orders_aggregate_bool_exp_corr {
  arguments: swap_orders_aggregate_bool_exp_corr_arguments!
  distinct: Boolean
  filter: swap_orders_bool_exp
  predicate: float8_comparison_exp!
}

input swap_orders_aggregate_bool_exp_corr_arguments {
  X: swap_orders_select_column_swap_orders_aggregate_bool_exp_corr_arguments_columns!
  Y: swap_orders_select_column_swap_orders_aggregate_bool_exp_corr_arguments_columns!
}

input swap_orders_aggregate_bool_exp_count {
  arguments: [swap_orders_select_column!]
  distinct: Boolean
  filter: swap_orders_bool_exp
  predicate: Int_comparison_exp!
}

input swap_orders_aggregate_bool_exp_covar_samp {
  arguments: swap_orders_aggregate_bool_exp_covar_samp_arguments!
  distinct: Boolean
  filter: swap_orders_bool_exp
  predicate: float8_comparison_exp!
}

input swap_orders_aggregate_bool_exp_covar_samp_arguments {
  X: swap_orders_select_column_swap_orders_aggregate_bool_exp_covar_samp_arguments_columns!
  Y: swap_orders_select_column_swap_orders_aggregate_bool_exp_covar_samp_arguments_columns!
}

input swap_orders_aggregate_bool_exp_max {
  arguments: swap_orders_select_column_swap_orders_aggregate_bool_exp_max_arguments_columns!
  distinct: Boolean
  filter: swap_orders_bool_exp
  predicate: float8_comparison_exp!
}

input swap_orders_aggregate_bool_exp_min {
  arguments: swap_orders_select_column_swap_orders_aggregate_bool_exp_min_arguments_columns!
  distinct: Boolean
  filter: swap_orders_bool_exp
  predicate: float8_comparison_exp!
}

input swap_orders_aggregate_bool_exp_stddev_samp {
  arguments: swap_orders_select_column_swap_orders_aggregate_bool_exp_stddev_samp_arguments_columns!
  distinct: Boolean
  filter: swap_orders_bool_exp
  predicate: float8_comparison_exp!
}

input swap_orders_aggregate_bool_exp_sum {
  arguments: swap_orders_select_column_swap_orders_aggregate_bool_exp_sum_arguments_columns!
  distinct: Boolean
  filter: swap_orders_bool_exp
  predicate: float8_comparison_exp!
}

input swap_orders_aggregate_bool_exp_var_samp {
  arguments: swap_orders_select_column_swap_orders_aggregate_bool_exp_var_samp_arguments_columns!
  distinct: Boolean
  filter: swap_orders_bool_exp
  predicate: float8_comparison_exp!
}

"""
aggregate fields of "swap_orders"
"""
type swap_orders_aggregate_fields {
  avg: swap_orders_avg_fields
  count(columns: [swap_orders_select_column!], distinct: Boolean): Int!
  max: swap_orders_max_fields
  min: swap_orders_min_fields
  stddev: swap_orders_stddev_fields
  stddev_pop: swap_orders_stddev_pop_fields
  stddev_samp: swap_orders_stddev_samp_fields
  sum: swap_orders_sum_fields
  var_pop: swap_orders_var_pop_fields
  var_samp: swap_orders_var_samp_fields
  variance: swap_orders_variance_fields
}

"""
order by aggregate values of table "swap_orders"
"""
input swap_orders_aggregate_order_by {
  avg: swap_orders_avg_order_by
  count: order_by
  max: swap_orders_max_order_by
  min: swap_orders_min_order_by
  stddev: swap_orders_stddev_order_by
  stddev_pop: swap_orders_stddev_pop_order_by
  stddev_samp: swap_orders_stddev_samp_order_by
  sum: swap_orders_sum_order_by
  var_pop: swap_orders_var_pop_order_by
  var_samp: swap_orders_var_samp_order_by
  variance: swap_orders_variance_order_by
}

"""
input type for inserting array relation for remote table "swap_orders"
"""
input swap_orders_arr_rel_insert_input {
  data: [swap_orders_insert_input!]!

  """upsert condition"""
  on_conflict: swap_orders_on_conflict
}

"""aggregate avg on columns"""
type swap_orders_avg_fields {
  asset_amount: Float
  masterbots_amount: Float
  price: Float
}

"""
order by avg() on columns of table "swap_orders"
"""
input swap_orders_avg_order_by {
  asset_amount: order_by
  masterbots_amount: order_by
  price: order_by
}

"""
Boolean expression to filter rows from the table "swap_orders". All fields are combined with a logical 'AND'.
"""
input swap_orders_bool_exp {
  _and: [swap_orders_bool_exp!]
  _not: swap_orders_bool_exp
  _or: [swap_orders_bool_exp!]
  asset: String_comparison_exp
  asset_amount: float8_comparison_exp
  masterbots_account: String_comparison_exp
  masterbots_amount: float8_comparison_exp
  masterbots_currency: String_comparison_exp
  masterbots_trx: String_comparison_exp
  created_at: timestamptz_comparison_exp
  gems_id: String_comparison_exp
  id: uuid_comparison_exp
  order_status: String_comparison_exp
  order_type: String_comparison_exp
  price: float8_comparison_exp
  reg_account: reg_accounts_bool_exp
  updated_at: timestamptz_comparison_exp
  wallet_address: String_comparison_exp
}

"""
unique or primary key constraints on table "swap_orders"
"""
enum swap_orders_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  swap_orders_pkey
}

"""
input type for incrementing numeric columns in table "swap_orders"
"""
input swap_orders_inc_input {
  asset_amount: float8
  masterbots_amount: float8
  price: float8
}

"""
input type for inserting data into table "swap_orders"
"""
input swap_orders_insert_input {
  asset: String
  asset_amount: float8
  masterbots_account: String
  masterbots_amount: float8
  masterbots_currency: String
  masterbots_trx: String
  created_at: timestamptz
  gems_id: String
  id: uuid
  order_status: String
  order_type: String
  price: float8
  reg_account: reg_accounts_obj_rel_insert_input
  updated_at: timestamptz
  wallet_address: String
}

"""aggregate max on columns"""
type swap_orders_max_fields {
  asset: String
  asset_amount: float8
  masterbots_account: String
  masterbots_amount: float8
  masterbots_currency: String
  masterbots_trx: String
  created_at: timestamptz
  gems_id: String
  id: uuid
  order_status: String
  order_type: String
  price: float8
  updated_at: timestamptz
  wallet_address: String
}

"""
order by max() on columns of table "swap_orders"
"""
input swap_orders_max_order_by {
  asset: order_by
  asset_amount: order_by
  masterbots_account: order_by
  masterbots_amount: order_by
  masterbots_currency: order_by
  masterbots_trx: order_by
  created_at: order_by
  gems_id: order_by
  id: order_by
  order_status: order_by
  order_type: order_by
  price: order_by
  updated_at: order_by
  wallet_address: order_by
}

"""aggregate min on columns"""
type swap_orders_min_fields {
  asset: String
  asset_amount: float8
  masterbots_account: String
  masterbots_amount: float8
  masterbots_currency: String
  masterbots_trx: String
  created_at: timestamptz
  gems_id: String
  id: uuid
  order_status: String
  order_type: String
  price: float8
  updated_at: timestamptz
  wallet_address: String
}

"""
order by min() on columns of table "swap_orders"
"""
input swap_orders_min_order_by {
  asset: order_by
  asset_amount: order_by
  masterbots_account: order_by
  masterbots_amount: order_by
  masterbots_currency: order_by
  masterbots_trx: order_by
  created_at: order_by
  gems_id: order_by
  id: order_by
  order_status: order_by
  order_type: order_by
  price: order_by
  updated_at: order_by
  wallet_address: order_by
}

"""
response of any mutation on the table "swap_orders"
"""
type swap_orders_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [swap_orders!]!
}

"""
on_conflict condition type for table "swap_orders"
"""
input swap_orders_on_conflict {
  constraint: swap_orders_constraint!
  update_columns: [swap_orders_update_column!]! = []
  where: swap_orders_bool_exp
}

"""Ordering options when selecting data from "swap_orders"."""
input swap_orders_order_by {
  asset: order_by
  asset_amount: order_by
  masterbots_account: order_by
  masterbots_amount: order_by
  masterbots_currency: order_by
  masterbots_trx: order_by
  created_at: order_by
  gems_id: order_by
  id: order_by
  order_status: order_by
  order_type: order_by
  price: order_by
  reg_account: reg_accounts_order_by
  updated_at: order_by
  wallet_address: order_by
}

"""primary key columns input for table: swap_orders"""
input swap_orders_pk_columns_input {
  id: uuid!
}

"""
select columns of table "swap_orders"
"""
enum swap_orders_select_column {
  """column name"""
  asset

  """column name"""
  asset_amount

  """column name"""
  masterbots_account

  """column name"""
  masterbots_amount

  """column name"""
  masterbots_currency

  """column name"""
  masterbots_trx

  """column name"""
  created_at

  """column name"""
  gems_id

  """column name"""
  id

  """column name"""
  order_status

  """column name"""
  order_type

  """column name"""
  price

  """column name"""
  updated_at

  """column name"""
  wallet_address
}

"""
select "swap_orders_aggregate_bool_exp_avg_arguments_columns" columns of table "swap_orders"
"""
enum swap_orders_select_column_swap_orders_aggregate_bool_exp_avg_arguments_columns {
  """column name"""
  asset_amount

  """column name"""
  masterbots_amount

  """column name"""
  price
}

"""
select "swap_orders_aggregate_bool_exp_corr_arguments_columns" columns of table "swap_orders"
"""
enum swap_orders_select_column_swap_orders_aggregate_bool_exp_corr_arguments_columns {
  """column name"""
  asset_amount

  """column name"""
  masterbots_amount

  """column name"""
  price
}

"""
select "swap_orders_aggregate_bool_exp_covar_samp_arguments_columns" columns of table "swap_orders"
"""
enum swap_orders_select_column_swap_orders_aggregate_bool_exp_covar_samp_arguments_columns {
  """column name"""
  asset_amount

  """column name"""
  masterbots_amount

  """column name"""
  price
}

"""
select "swap_orders_aggregate_bool_exp_max_arguments_columns" columns of table "swap_orders"
"""
enum swap_orders_select_column_swap_orders_aggregate_bool_exp_max_arguments_columns {
  """column name"""
  asset_amount

  """column name"""
  masterbots_amount

  """column name"""
  price
}

"""
select "swap_orders_aggregate_bool_exp_min_arguments_columns" columns of table "swap_orders"
"""
enum swap_orders_select_column_swap_orders_aggregate_bool_exp_min_arguments_columns {
  """column name"""
  asset_amount

  """column name"""
  masterbots_amount

  """column name"""
  price
}

"""
select "swap_orders_aggregate_bool_exp_stddev_samp_arguments_columns" columns of table "swap_orders"
"""
enum swap_orders_select_column_swap_orders_aggregate_bool_exp_stddev_samp_arguments_columns {
  """column name"""
  asset_amount

  """column name"""
  masterbots_amount

  """column name"""
  price
}

"""
select "swap_orders_aggregate_bool_exp_sum_arguments_columns" columns of table "swap_orders"
"""
enum swap_orders_select_column_swap_orders_aggregate_bool_exp_sum_arguments_columns {
  """column name"""
  asset_amount

  """column name"""
  masterbots_amount

  """column name"""
  price
}

"""
select "swap_orders_aggregate_bool_exp_var_samp_arguments_columns" columns of table "swap_orders"
"""
enum swap_orders_select_column_swap_orders_aggregate_bool_exp_var_samp_arguments_columns {
  """column name"""
  asset_amount

  """column name"""
  masterbots_amount

  """column name"""
  price
}

"""
input type for updating data in table "swap_orders"
"""
input swap_orders_set_input {
  asset: String
  asset_amount: float8
  masterbots_account: String
  masterbots_amount: float8
  masterbots_currency: String
  masterbots_trx: String
  created_at: timestamptz
  gems_id: String
  id: uuid
  order_status: String
  order_type: String
  price: float8
  updated_at: timestamptz
  wallet_address: String
}

"""aggregate stddev on columns"""
type swap_orders_stddev_fields {
  asset_amount: Float
  masterbots_amount: Float
  price: Float
}

"""
order by stddev() on columns of table "swap_orders"
"""
input swap_orders_stddev_order_by {
  asset_amount: order_by
  masterbots_amount: order_by
  price: order_by
}

"""aggregate stddev_pop on columns"""
type swap_orders_stddev_pop_fields {
  asset_amount: Float
  masterbots_amount: Float
  price: Float
}

"""
order by stddev_pop() on columns of table "swap_orders"
"""
input swap_orders_stddev_pop_order_by {
  asset_amount: order_by
  masterbots_amount: order_by
  price: order_by
}

"""aggregate stddev_samp on columns"""
type swap_orders_stddev_samp_fields {
  asset_amount: Float
  masterbots_amount: Float
  price: Float
}

"""
order by stddev_samp() on columns of table "swap_orders"
"""
input swap_orders_stddev_samp_order_by {
  asset_amount: order_by
  masterbots_amount: order_by
  price: order_by
}

"""
Streaming cursor of the table "swap_orders"
"""
input swap_orders_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: swap_orders_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input swap_orders_stream_cursor_value_input {
  asset: String
  asset_amount: float8
  masterbots_account: String
  masterbots_amount: float8
  masterbots_currency: String
  masterbots_trx: String
  created_at: timestamptz
  gems_id: String
  id: uuid
  order_status: String
  order_type: String
  price: float8
  updated_at: timestamptz
  wallet_address: String
}

"""aggregate sum on columns"""
type swap_orders_sum_fields {
  asset_amount: float8
  masterbots_amount: float8
  price: float8
}

"""
order by sum() on columns of table "swap_orders"
"""
input swap_orders_sum_order_by {
  asset_amount: order_by
  masterbots_amount: order_by
  price: order_by
}

"""
update columns of table "swap_orders"
"""
enum swap_orders_update_column {
  """column name"""
  asset

  """column name"""
  asset_amount

  """column name"""
  masterbots_account

  """column name"""
  masterbots_amount

  """column name"""
  masterbots_currency

  """column name"""
  masterbots_trx

  """column name"""
  created_at

  """column name"""
  gems_id

  """column name"""
  id

  """column name"""
  order_status

  """column name"""
  order_type

  """column name"""
  price

  """column name"""
  updated_at

  """column name"""
  wallet_address
}

input swap_orders_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: swap_orders_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: swap_orders_set_input

  """filter the rows which have to be updated"""
  where: swap_orders_bool_exp!
}

"""aggregate var_pop on columns"""
type swap_orders_var_pop_fields {
  asset_amount: Float
  masterbots_amount: Float
  price: Float
}

"""
order by var_pop() on columns of table "swap_orders"
"""
input swap_orders_var_pop_order_by {
  asset_amount: order_by
  masterbots_amount: order_by
  price: order_by
}

"""aggregate var_samp on columns"""
type swap_orders_var_samp_fields {
  asset_amount: Float
  masterbots_amount: Float
  price: Float
}

"""
order by var_samp() on columns of table "swap_orders"
"""
input swap_orders_var_samp_order_by {
  asset_amount: order_by
  masterbots_amount: order_by
  price: order_by
}

"""aggregate variance on columns"""
type swap_orders_variance_fields {
  asset_amount: Float
  masterbots_amount: Float
  price: Float
}

"""
order by variance() on columns of table "swap_orders"
"""
input swap_orders_variance_order_by {
  asset_amount: order_by
  masterbots_amount: order_by
  price: order_by
}

scalar timestamp

"""
Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'.
"""
input timestamp_comparison_exp {
  _eq: timestamp
  _gt: timestamp
  _gte: timestamp
  _in: [timestamp!]
  _is_null: Boolean
  _lt: timestamp
  _lte: timestamp
  _neq: timestamp
  _nin: [timestamp!]
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

input toggle_trust_network_input {
  account: String!
  reject: Boolean
}

type toggle_trust_network_output {
  success: Boolean
}

"""
columns and relationships of "trust_network"
"""
type trust_network {
  account: String!
  created_at: timestamptz!
  is_mutual: Boolean!
  trust: String!

  """An object relationship"""
  trust_by: reg_accounts!

  """An object relationship"""
  trust_network: reg_accounts!
}

"""
aggregated selection of "trust_network"
"""
type trust_network_aggregate {
  aggregate: trust_network_aggregate_fields
  nodes: [trust_network!]!
}

input trust_network_aggregate_bool_exp {
  bool_and: trust_network_aggregate_bool_exp_bool_and
  bool_or: trust_network_aggregate_bool_exp_bool_or
  count: trust_network_aggregate_bool_exp_count
}

input trust_network_aggregate_bool_exp_bool_and {
  arguments: trust_network_select_column_trust_network_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: trust_network_bool_exp
  predicate: Boolean_comparison_exp!
}

input trust_network_aggregate_bool_exp_bool_or {
  arguments: trust_network_select_column_trust_network_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: trust_network_bool_exp
  predicate: Boolean_comparison_exp!
}

input trust_network_aggregate_bool_exp_count {
  arguments: [trust_network_select_column!]
  distinct: Boolean
  filter: trust_network_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "trust_network"
"""
type trust_network_aggregate_fields {
  count(columns: [trust_network_select_column!], distinct: Boolean): Int!
  max: trust_network_max_fields
  min: trust_network_min_fields
}

"""
order by aggregate values of table "trust_network"
"""
input trust_network_aggregate_order_by {
  count: order_by
  max: trust_network_max_order_by
  min: trust_network_min_order_by
}

"""
input type for inserting array relation for remote table "trust_network"
"""
input trust_network_arr_rel_insert_input {
  data: [trust_network_insert_input!]!

  """upsert condition"""
  on_conflict: trust_network_on_conflict
}

"""
Boolean expression to filter rows from the table "trust_network". All fields are combined with a logical 'AND'.
"""
input trust_network_bool_exp {
  _and: [trust_network_bool_exp!]
  _not: trust_network_bool_exp
  _or: [trust_network_bool_exp!]
  account: String_comparison_exp
  created_at: timestamptz_comparison_exp
  is_mutual: Boolean_comparison_exp
  trust: String_comparison_exp
  trust_by: reg_accounts_bool_exp
  trust_network: reg_accounts_bool_exp
}

"""
unique or primary key constraints on table "trust_network"
"""
enum trust_network_constraint {
  """
  unique or primary key constraint on columns "trust", "account"
  """
  trust_network_pkey
}

"""
input type for inserting data into table "trust_network"
"""
input trust_network_insert_input {
  account: String
  created_at: timestamptz
  is_mutual: Boolean
  trust: String
  trust_by: reg_accounts_obj_rel_insert_input
  trust_network: reg_accounts_obj_rel_insert_input
}

"""aggregate max on columns"""
type trust_network_max_fields {
  account: String
  created_at: timestamptz
  trust: String
}

"""
order by max() on columns of table "trust_network"
"""
input trust_network_max_order_by {
  account: order_by
  created_at: order_by
  trust: order_by
}

"""aggregate min on columns"""
type trust_network_min_fields {
  account: String
  created_at: timestamptz
  trust: String
}

"""
order by min() on columns of table "trust_network"
"""
input trust_network_min_order_by {
  account: order_by
  created_at: order_by
  trust: order_by
}

"""
response of any mutation on the table "trust_network"
"""
type trust_network_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [trust_network!]!
}

"""
columns and relationships of "trust_network_notification"
"""
type trust_network_notification {
  account: String!
  created_at: timestamptz!

  """An object relationship"""
  regAccountByTrust: reg_accounts!

  """An object relationship"""
  reg_account: reg_accounts!
  trust: String!
}

"""
aggregated selection of "trust_network_notification"
"""
type trust_network_notification_aggregate {
  aggregate: trust_network_notification_aggregate_fields
  nodes: [trust_network_notification!]!
}

input trust_network_notification_aggregate_bool_exp {
  count: trust_network_notification_aggregate_bool_exp_count
}

input trust_network_notification_aggregate_bool_exp_count {
  arguments: [trust_network_notification_select_column!]
  distinct: Boolean
  filter: trust_network_notification_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "trust_network_notification"
"""
type trust_network_notification_aggregate_fields {
  count(columns: [trust_network_notification_select_column!], distinct: Boolean): Int!
  max: trust_network_notification_max_fields
  min: trust_network_notification_min_fields
}

"""
order by aggregate values of table "trust_network_notification"
"""
input trust_network_notification_aggregate_order_by {
  count: order_by
  max: trust_network_notification_max_order_by
  min: trust_network_notification_min_order_by
}

"""
input type for inserting array relation for remote table "trust_network_notification"
"""
input trust_network_notification_arr_rel_insert_input {
  data: [trust_network_notification_insert_input!]!

  """upsert condition"""
  on_conflict: trust_network_notification_on_conflict
}

"""
Boolean expression to filter rows from the table "trust_network_notification". All fields are combined with a logical 'AND'.
"""
input trust_network_notification_bool_exp {
  _and: [trust_network_notification_bool_exp!]
  _not: trust_network_notification_bool_exp
  _or: [trust_network_notification_bool_exp!]
  account: String_comparison_exp
  created_at: timestamptz_comparison_exp
  regAccountByTrust: reg_accounts_bool_exp
  reg_account: reg_accounts_bool_exp
  trust: String_comparison_exp
}

"""
unique or primary key constraints on table "trust_network_notification"
"""
enum trust_network_notification_constraint {
  """
  unique or primary key constraint on columns "trust", "account"
  """
  trust_network_notification_pkey
}

"""
input type for inserting data into table "trust_network_notification"
"""
input trust_network_notification_insert_input {
  account: String
  created_at: timestamptz
  regAccountByTrust: reg_accounts_obj_rel_insert_input
  reg_account: reg_accounts_obj_rel_insert_input
  trust: String
}

"""aggregate max on columns"""
type trust_network_notification_max_fields {
  account: String
  created_at: timestamptz
  trust: String
}

"""
order by max() on columns of table "trust_network_notification"
"""
input trust_network_notification_max_order_by {
  account: order_by
  created_at: order_by
  trust: order_by
}

"""aggregate min on columns"""
type trust_network_notification_min_fields {
  account: String
  created_at: timestamptz
  trust: String
}

"""
order by min() on columns of table "trust_network_notification"
"""
input trust_network_notification_min_order_by {
  account: order_by
  created_at: order_by
  trust: order_by
}

"""
response of any mutation on the table "trust_network_notification"
"""
type trust_network_notification_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [trust_network_notification!]!
}

"""
on_conflict condition type for table "trust_network_notification"
"""
input trust_network_notification_on_conflict {
  constraint: trust_network_notification_constraint!
  update_columns: [trust_network_notification_update_column!]! = []
  where: trust_network_notification_bool_exp
}

"""
Ordering options when selecting data from "trust_network_notification".
"""
input trust_network_notification_order_by {
  account: order_by
  created_at: order_by
  regAccountByTrust: reg_accounts_order_by
  reg_account: reg_accounts_order_by
  trust: order_by
}

"""primary key columns input for table: trust_network_notification"""
input trust_network_notification_pk_columns_input {
  account: String!
  trust: String!
}

"""
select columns of table "trust_network_notification"
"""
enum trust_network_notification_select_column {
  """column name"""
  account

  """column name"""
  created_at

  """column name"""
  trust
}

"""
input type for updating data in table "trust_network_notification"
"""
input trust_network_notification_set_input {
  account: String
  created_at: timestamptz
  trust: String
}

"""
Streaming cursor of the table "trust_network_notification"
"""
input trust_network_notification_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: trust_network_notification_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input trust_network_notification_stream_cursor_value_input {
  account: String
  created_at: timestamptz
  trust: String
}

"""
update columns of table "trust_network_notification"
"""
enum trust_network_notification_update_column {
  """column name"""
  account

  """column name"""
  created_at

  """column name"""
  trust
}

input trust_network_notification_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: trust_network_notification_set_input

  """filter the rows which have to be updated"""
  where: trust_network_notification_bool_exp!
}

"""
on_conflict condition type for table "trust_network"
"""
input trust_network_on_conflict {
  constraint: trust_network_constraint!
  update_columns: [trust_network_update_column!]! = []
  where: trust_network_bool_exp
}

"""Ordering options when selecting data from "trust_network"."""
input trust_network_order_by {
  account: order_by
  created_at: order_by
  is_mutual: order_by
  trust: order_by
  trust_by: reg_accounts_order_by
  trust_network: reg_accounts_order_by
}

type trust_network_output {
  trusted_network: [String]
}

"""primary key columns input for table: trust_network"""
input trust_network_pk_columns_input {
  account: String!
  trust: String!
}

"""
select columns of table "trust_network"
"""
enum trust_network_select_column {
  """column name"""
  account

  """column name"""
  created_at

  """column name"""
  is_mutual

  """column name"""
  trust
}

"""
select "trust_network_aggregate_bool_exp_bool_and_arguments_columns" columns of table "trust_network"
"""
enum trust_network_select_column_trust_network_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  is_mutual
}

"""
select "trust_network_aggregate_bool_exp_bool_or_arguments_columns" columns of table "trust_network"
"""
enum trust_network_select_column_trust_network_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  is_mutual
}

"""
input type for updating data in table "trust_network"
"""
input trust_network_set_input {
  account: String
  created_at: timestamptz
  is_mutual: Boolean
  trust: String
}

"""
columns and relationships of "trust_network_status"
"""
type trust_network_status {
  status: String!
}

"""
aggregated selection of "trust_network_status"
"""
type trust_network_status_aggregate {
  aggregate: trust_network_status_aggregate_fields
  nodes: [trust_network_status!]!
}

"""
aggregate fields of "trust_network_status"
"""
type trust_network_status_aggregate_fields {
  count(columns: [trust_network_status_select_column!], distinct: Boolean): Int!
  max: trust_network_status_max_fields
  min: trust_network_status_min_fields
}

"""
Boolean expression to filter rows from the table "trust_network_status". All fields are combined with a logical 'AND'.
"""
input trust_network_status_bool_exp {
  _and: [trust_network_status_bool_exp!]
  _not: trust_network_status_bool_exp
  _or: [trust_network_status_bool_exp!]
  status: String_comparison_exp
}

"""
unique or primary key constraints on table "trust_network_status"
"""
enum trust_network_status_constraint {
  """
  unique or primary key constraint on columns "status"
  """
  trusted_network_status_pkey
}

"""
input type for inserting data into table "trust_network_status"
"""
input trust_network_status_insert_input {
  status: String
}

"""aggregate max on columns"""
type trust_network_status_max_fields {
  status: String
}

"""aggregate min on columns"""
type trust_network_status_min_fields {
  status: String
}

"""
response of any mutation on the table "trust_network_status"
"""
type trust_network_status_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [trust_network_status!]!
}

"""
on_conflict condition type for table "trust_network_status"
"""
input trust_network_status_on_conflict {
  constraint: trust_network_status_constraint!
  update_columns: [trust_network_status_update_column!]! = []
  where: trust_network_status_bool_exp
}

"""Ordering options when selecting data from "trust_network_status"."""
input trust_network_status_order_by {
  status: order_by
}

"""primary key columns input for table: trust_network_status"""
input trust_network_status_pk_columns_input {
  status: String!
}

"""
select columns of table "trust_network_status"
"""
enum trust_network_status_select_column {
  """column name"""
  status
}

"""
input type for updating data in table "trust_network_status"
"""
input trust_network_status_set_input {
  status: String
}

"""
Streaming cursor of the table "trust_network_status"
"""
input trust_network_status_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: trust_network_status_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input trust_network_status_stream_cursor_value_input {
  status: String
}

"""
update columns of table "trust_network_status"
"""
enum trust_network_status_update_column {
  """column name"""
  status
}

input trust_network_status_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: trust_network_status_set_input

  """filter the rows which have to be updated"""
  where: trust_network_status_bool_exp!
}

"""
Streaming cursor of the table "trust_network"
"""
input trust_network_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: trust_network_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input trust_network_stream_cursor_value_input {
  account: String
  created_at: timestamptz
  is_mutual: Boolean
  trust: String
}

"""
update columns of table "trust_network"
"""
enum trust_network_update_column {
  """column name"""
  account

  """column name"""
  created_at

  """column name"""
  is_mutual

  """column name"""
  trust
}

input trust_network_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: trust_network_set_input

  """filter the rows which have to be updated"""
  where: trust_network_bool_exp!
}

scalar uuid

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}