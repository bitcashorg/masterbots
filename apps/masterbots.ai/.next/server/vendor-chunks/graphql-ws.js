"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/graphql-ws";
exports.ids = ["vendor-chunks/graphql-ws"];
exports.modules = {
  /***/ "(rsc)/../../node_modules/graphql-ws/lib/client.mjs":
    /*!****************************************************!*\
  !*** ../../node_modules/graphql-ws/lib/client.mjs ***!
  \****************************************************/
    /***/ (
      __unused_webpack___webpack_module__,
      __webpack_exports__,
      __webpack_require__,
    ) => {
      eval(
        "__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CloseCode: () => (/* reexport safe */ _common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode),\n/* harmony export */   DEPRECATED_GRAPHQL_WS_PROTOCOL: () => (/* reexport safe */ _common_mjs__WEBPACK_IMPORTED_MODULE_0__.DEPRECATED_GRAPHQL_WS_PROTOCOL),\n/* harmony export */   GRAPHQL_TRANSPORT_WS_PROTOCOL: () => (/* reexport safe */ _common_mjs__WEBPACK_IMPORTED_MODULE_0__.GRAPHQL_TRANSPORT_WS_PROTOCOL),\n/* harmony export */   MessageType: () => (/* reexport safe */ _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType),\n/* harmony export */   TerminatedCloseEvent: () => (/* binding */ TerminatedCloseEvent),\n/* harmony export */   createClient: () => (/* binding */ createClient),\n/* harmony export */   isMessage: () => (/* reexport safe */ _common_mjs__WEBPACK_IMPORTED_MODULE_0__.isMessage),\n/* harmony export */   parseMessage: () => (/* reexport safe */ _common_mjs__WEBPACK_IMPORTED_MODULE_0__.parseMessage),\n/* harmony export */   stringifyMessage: () => (/* reexport safe */ _common_mjs__WEBPACK_IMPORTED_MODULE_0__.stringifyMessage),\n/* harmony export */   validateMessage: () => (/* reexport safe */ _common_mjs__WEBPACK_IMPORTED_MODULE_0__.validateMessage)\n/* harmony export */ });\n/* harmony import */ var _common_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.mjs */ \"(rsc)/../../node_modules/graphql-ws/lib/common.mjs\");\n/* harmony import */ var _utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.mjs */ \"(rsc)/../../node_modules/graphql-ws/lib/utils.mjs\");\n/**\n *\n * client\n *\n */\nvar __await = (undefined && undefined.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = (undefined && undefined.__asyncGenerator) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\n\n\n/** This file is the entry point for browsers, re-export common elements. */\n\n/**\n * Creates a disposable GraphQL over WebSocket client.\n *\n * @category Client\n */\nfunction createClient(options) {\n    const { url, connectionParams, lazy = true, onNonLazyError = console.error, lazyCloseTimeout: lazyCloseTimeoutMs = 0, keepAlive = 0, disablePong, connectionAckWaitTimeout = 0, retryAttempts = 5, retryWait = async function randomisedExponentialBackoff(retries) {\n        let retryDelay = 1000; // start with 1s delay\n        for (let i = 0; i < retries; i++) {\n            retryDelay *= 2;\n        }\n        await new Promise((resolve) => setTimeout(resolve, retryDelay +\n            // add random timeout from 300ms to 3s\n            Math.floor(Math.random() * (3000 - 300) + 300)));\n    }, shouldRetry = isLikeCloseEvent, isFatalConnectionProblem, on, webSocketImpl, \n    /**\n     * Generates a v4 UUID to be used as the ID using `Math`\n     * as the random number generator. Supply your own generator\n     * in case you need more uniqueness.\n     *\n     * Reference: https://gist.github.com/jed/982883\n     */\n    generateID = function generateUUID() {\n        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n            const r = (Math.random() * 16) | 0, v = c == 'x' ? r : (r & 0x3) | 0x8;\n            return v.toString(16);\n        });\n    }, jsonMessageReplacer: replacer, jsonMessageReviver: reviver, } = options;\n    let ws;\n    if (webSocketImpl) {\n        if (!isWebSocket(webSocketImpl)) {\n            throw new Error('Invalid WebSocket implementation provided');\n        }\n        ws = webSocketImpl;\n    }\n    else if (typeof WebSocket !== 'undefined') {\n        ws = WebSocket;\n    }\n    else if (typeof global !== 'undefined') {\n        ws =\n            global.WebSocket ||\n                // @ts-expect-error: Support more browsers\n                global.MozWebSocket;\n    }\n    else if (typeof window !== 'undefined') {\n        ws =\n            window.WebSocket ||\n                // @ts-expect-error: Support more browsers\n                window.MozWebSocket;\n    }\n    if (!ws)\n        throw new Error(\"WebSocket implementation missing; on Node you can `import WebSocket from 'ws';` and pass `webSocketImpl: WebSocket` to `createClient`\");\n    const WebSocketImpl = ws;\n    // websocket status emitter, subscriptions are handled differently\n    const emitter = (() => {\n        const message = (() => {\n            const listeners = {};\n            return {\n                on(id, listener) {\n                    listeners[id] = listener;\n                    return () => {\n                        delete listeners[id];\n                    };\n                },\n                emit(message) {\n                    var _a;\n                    if ('id' in message)\n                        (_a = listeners[message.id]) === null || _a === void 0 ? void 0 : _a.call(listeners, message);\n                },\n            };\n        })();\n        const listeners = {\n            connecting: (on === null || on === void 0 ? void 0 : on.connecting) ? [on.connecting] : [],\n            opened: (on === null || on === void 0 ? void 0 : on.opened) ? [on.opened] : [],\n            connected: (on === null || on === void 0 ? void 0 : on.connected) ? [on.connected] : [],\n            ping: (on === null || on === void 0 ? void 0 : on.ping) ? [on.ping] : [],\n            pong: (on === null || on === void 0 ? void 0 : on.pong) ? [on.pong] : [],\n            message: (on === null || on === void 0 ? void 0 : on.message) ? [message.emit, on.message] : [message.emit],\n            closed: (on === null || on === void 0 ? void 0 : on.closed) ? [on.closed] : [],\n            error: (on === null || on === void 0 ? void 0 : on.error) ? [on.error] : [],\n        };\n        return {\n            onMessage: message.on,\n            on(event, listener) {\n                const l = listeners[event];\n                l.push(listener);\n                return () => {\n                    l.splice(l.indexOf(listener), 1);\n                };\n            },\n            emit(event, ...args) {\n                // we copy the listeners so that unlistens dont \"pull the rug under our feet\"\n                for (const listener of [...listeners[event]]) {\n                    // @ts-expect-error: The args should fit\n                    listener(...args);\n                }\n            },\n        };\n    })();\n    // invokes the callback either when an error or closed event is emitted,\n    // first one that gets called prevails, other emissions are ignored\n    function errorOrClosed(cb) {\n        const listening = [\n            // errors are fatal and more critical than close events, throw them first\n            emitter.on('error', (err) => {\n                listening.forEach((unlisten) => unlisten());\n                cb(err);\n            }),\n            // closes can be graceful and not fatal, throw them second (if error didnt throw)\n            emitter.on('closed', (event) => {\n                listening.forEach((unlisten) => unlisten());\n                cb(event);\n            }),\n        ];\n    }\n    let connecting, locks = 0, lazyCloseTimeout, retrying = false, retries = 0, disposed = false;\n    async function connect() {\n        // clear the lazy close timeout immediatelly so that close gets debounced\n        // see: https://github.com/enisdenjo/graphql-ws/issues/388\n        clearTimeout(lazyCloseTimeout);\n        const [socket, throwOnClose] = await (connecting !== null && connecting !== void 0 ? connecting : (connecting = new Promise((connected, denied) => (async () => {\n            if (retrying) {\n                await retryWait(retries);\n                // subscriptions might complete while waiting for retry\n                if (!locks) {\n                    connecting = undefined;\n                    return denied({ code: 1000, reason: 'All Subscriptions Gone' });\n                }\n                retries++;\n            }\n            emitter.emit('connecting', retrying);\n            const socket = new WebSocketImpl(typeof url === 'function' ? await url() : url, _common_mjs__WEBPACK_IMPORTED_MODULE_0__.GRAPHQL_TRANSPORT_WS_PROTOCOL);\n            let connectionAckTimeout, queuedPing;\n            function enqueuePing() {\n                if (isFinite(keepAlive) && keepAlive > 0) {\n                    clearTimeout(queuedPing); // in case where a pong was received before a ping (this is valid behaviour)\n                    queuedPing = setTimeout(() => {\n                        if (socket.readyState === WebSocketImpl.OPEN) {\n                            socket.send((0,_common_mjs__WEBPACK_IMPORTED_MODULE_0__.stringifyMessage)({ type: _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.Ping }));\n                            emitter.emit('ping', false, undefined);\n                        }\n                    }, keepAlive);\n                }\n            }\n            errorOrClosed((errOrEvent) => {\n                connecting = undefined;\n                clearTimeout(connectionAckTimeout);\n                clearTimeout(queuedPing);\n                denied(errOrEvent);\n                if (errOrEvent instanceof TerminatedCloseEvent) {\n                    socket.close(4499, 'Terminated'); // close event is artificial and emitted manually, see `Client.terminate()` below\n                    socket.onerror = null;\n                    socket.onclose = null;\n                }\n            });\n            socket.onerror = (err) => emitter.emit('error', err);\n            socket.onclose = (event) => emitter.emit('closed', event);\n            socket.onopen = async () => {\n                try {\n                    emitter.emit('opened', socket);\n                    const payload = typeof connectionParams === 'function'\n                        ? await connectionParams()\n                        : connectionParams;\n                    // connectionParams might take too long causing the server to kick off the client\n                    // the necessary error/close event is already reported - simply stop execution\n                    if (socket.readyState !== WebSocketImpl.OPEN)\n                        return;\n                    socket.send((0,_common_mjs__WEBPACK_IMPORTED_MODULE_0__.stringifyMessage)(payload\n                        ? {\n                            type: _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.ConnectionInit,\n                            payload,\n                        }\n                        : {\n                            type: _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.ConnectionInit,\n                            // payload is completely absent if not provided\n                        }, replacer));\n                    if (isFinite(connectionAckWaitTimeout) &&\n                        connectionAckWaitTimeout > 0) {\n                        connectionAckTimeout = setTimeout(() => {\n                            socket.close(_common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.ConnectionAcknowledgementTimeout, 'Connection acknowledgement timeout');\n                        }, connectionAckWaitTimeout);\n                    }\n                    enqueuePing(); // enqueue ping (noop if disabled)\n                }\n                catch (err) {\n                    emitter.emit('error', err);\n                    socket.close(_common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.InternalClientError, (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.limitCloseReason)(err instanceof Error ? err.message : new Error(err).message, 'Internal client error'));\n                }\n            };\n            let acknowledged = false;\n            socket.onmessage = ({ data }) => {\n                try {\n                    const message = (0,_common_mjs__WEBPACK_IMPORTED_MODULE_0__.parseMessage)(data, reviver);\n                    emitter.emit('message', message);\n                    if (message.type === 'ping' || message.type === 'pong') {\n                        emitter.emit(message.type, true, message.payload); // received\n                        if (message.type === 'pong') {\n                            enqueuePing(); // enqueue next ping (noop if disabled)\n                        }\n                        else if (!disablePong) {\n                            // respond with pong on ping\n                            socket.send((0,_common_mjs__WEBPACK_IMPORTED_MODULE_0__.stringifyMessage)(message.payload\n                                ? {\n                                    type: _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.Pong,\n                                    payload: message.payload,\n                                }\n                                : {\n                                    type: _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.Pong,\n                                    // payload is completely absent if not provided\n                                }));\n                            emitter.emit('pong', false, message.payload);\n                        }\n                        return; // ping and pongs can be received whenever\n                    }\n                    if (acknowledged)\n                        return; // already connected and acknowledged\n                    if (message.type !== _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.ConnectionAck)\n                        throw new Error(`First message cannot be of type ${message.type}`);\n                    clearTimeout(connectionAckTimeout);\n                    acknowledged = true;\n                    emitter.emit('connected', socket, message.payload, retrying); // connected = socket opened + acknowledged\n                    retrying = false; // future lazy connects are not retries\n                    retries = 0; // reset the retries on connect\n                    connected([\n                        socket,\n                        new Promise((_, reject) => errorOrClosed(reject)),\n                    ]);\n                }\n                catch (err) {\n                    socket.onmessage = null; // stop reading messages as soon as reading breaks once\n                    emitter.emit('error', err);\n                    socket.close(_common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.BadResponse, (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.limitCloseReason)(err instanceof Error ? err.message : new Error(err).message, 'Bad response'));\n                }\n            };\n        })())));\n        // if the provided socket is in a closing state, wait for the throw on close\n        if (socket.readyState === WebSocketImpl.CLOSING)\n            await throwOnClose;\n        let release = () => {\n            // releases this connection\n        };\n        const released = new Promise((resolve) => (release = resolve));\n        return [\n            socket,\n            release,\n            Promise.race([\n                // wait for\n                released.then(() => {\n                    if (!locks) {\n                        // and if no more locks are present, complete the connection\n                        const complete = () => socket.close(1000, 'Normal Closure');\n                        if (isFinite(lazyCloseTimeoutMs) && lazyCloseTimeoutMs > 0) {\n                            // if the keepalive is set, allow for the specified calmdown time and\n                            // then complete if the socket is still open.\n                            lazyCloseTimeout = setTimeout(() => {\n                                if (socket.readyState === WebSocketImpl.OPEN)\n                                    complete();\n                            }, lazyCloseTimeoutMs);\n                        }\n                        else {\n                            // otherwise complete immediately\n                            complete();\n                        }\n                    }\n                }),\n                // or\n                throwOnClose,\n            ]),\n        ];\n    }\n    /**\n     * Checks the `connect` problem and evaluates if the client should retry.\n     */\n    function shouldRetryConnectOrThrow(errOrCloseEvent) {\n        // some close codes are worth reporting immediately\n        if (isLikeCloseEvent(errOrCloseEvent) &&\n            (isFatalInternalCloseCode(errOrCloseEvent.code) ||\n                [\n                    _common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.InternalServerError,\n                    _common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.InternalClientError,\n                    _common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.BadRequest,\n                    _common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.BadResponse,\n                    _common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.Unauthorized,\n                    // CloseCode.Forbidden, might grant access out after retry\n                    _common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.SubprotocolNotAcceptable,\n                    // CloseCode.ConnectionInitialisationTimeout, might not time out after retry\n                    // CloseCode.ConnectionAcknowledgementTimeout, might not time out after retry\n                    _common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.SubscriberAlreadyExists,\n                    _common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.TooManyInitialisationRequests,\n                    // 4499, // Terminated, probably because the socket froze, we want to retry\n                ].includes(errOrCloseEvent.code)))\n            throw errOrCloseEvent;\n        // client was disposed, no retries should proceed regardless\n        if (disposed)\n            return false;\n        // normal closure (possibly all subscriptions have completed)\n        // if no locks were acquired in the meantime, shouldnt try again\n        if (isLikeCloseEvent(errOrCloseEvent) && errOrCloseEvent.code === 1000)\n            return locks > 0;\n        // retries are not allowed or we tried to many times, report error\n        if (!retryAttempts || retries >= retryAttempts)\n            throw errOrCloseEvent;\n        // throw non-retryable connection problems\n        if (!shouldRetry(errOrCloseEvent))\n            throw errOrCloseEvent;\n        // @deprecated throw fatal connection problems immediately\n        if (isFatalConnectionProblem === null || isFatalConnectionProblem === void 0 ? void 0 : isFatalConnectionProblem(errOrCloseEvent))\n            throw errOrCloseEvent;\n        // looks good, start retrying\n        return (retrying = true);\n    }\n    // in non-lazy (hot?) mode always hold one connection lock to persist the socket\n    if (!lazy) {\n        (async () => {\n            locks++;\n            for (;;) {\n                try {\n                    const [, , throwOnClose] = await connect();\n                    await throwOnClose; // will always throw because releaser is not used\n                }\n                catch (errOrCloseEvent) {\n                    try {\n                        if (!shouldRetryConnectOrThrow(errOrCloseEvent))\n                            return;\n                    }\n                    catch (errOrCloseEvent) {\n                        // report thrown error, no further retries\n                        return onNonLazyError === null || onNonLazyError === void 0 ? void 0 : onNonLazyError(errOrCloseEvent);\n                    }\n                }\n            }\n        })();\n    }\n    function subscribe(payload, sink) {\n        const id = generateID(payload);\n        let done = false, errored = false, releaser = () => {\n            // for handling completions before connect\n            locks--;\n            done = true;\n        };\n        (async () => {\n            locks++;\n            for (;;) {\n                try {\n                    const [socket, release, waitForReleaseOrThrowOnClose] = await connect();\n                    // if done while waiting for connect, release the connection lock right away\n                    if (done)\n                        return release();\n                    const unlisten = emitter.onMessage(id, (message) => {\n                        switch (message.type) {\n                            case _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.Next: {\n                                // eslint-disable-next-line @typescript-eslint/no-explicit-any -- payload will fit type\n                                sink.next(message.payload);\n                                return;\n                            }\n                            case _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.Error: {\n                                (errored = true), (done = true);\n                                sink.error(message.payload);\n                                releaser();\n                                return;\n                            }\n                            case _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.Complete: {\n                                done = true;\n                                releaser(); // release completes the sink\n                                return;\n                            }\n                        }\n                    });\n                    socket.send((0,_common_mjs__WEBPACK_IMPORTED_MODULE_0__.stringifyMessage)({\n                        id,\n                        type: _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.Subscribe,\n                        payload,\n                    }, replacer));\n                    releaser = () => {\n                        if (!done && socket.readyState === WebSocketImpl.OPEN)\n                            // if not completed already and socket is open, send complete message to server on release\n                            socket.send((0,_common_mjs__WEBPACK_IMPORTED_MODULE_0__.stringifyMessage)({\n                                id,\n                                type: _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.Complete,\n                            }, replacer));\n                        locks--;\n                        done = true;\n                        release();\n                    };\n                    // either the releaser will be called, connection completed and\n                    // the promise resolved or the socket closed and the promise rejected.\n                    // whatever happens though, we want to stop listening for messages\n                    await waitForReleaseOrThrowOnClose.finally(unlisten);\n                    return; // completed, shouldnt try again\n                }\n                catch (errOrCloseEvent) {\n                    if (!shouldRetryConnectOrThrow(errOrCloseEvent))\n                        return;\n                }\n            }\n        })()\n            .then(() => {\n            // delivering either an error or a complete terminates the sequence\n            if (!errored)\n                sink.complete();\n        }) // resolves on release or normal closure\n            .catch((err) => {\n            sink.error(err);\n        }); // rejects on close events and errors\n        return () => {\n            // dispose only of active subscriptions\n            if (!done)\n                releaser();\n        };\n    }\n    return {\n        on: emitter.on,\n        subscribe,\n        iterate(request) {\n            const pending = [];\n            const deferred = {\n                done: false,\n                error: null,\n                resolve: () => {\n                    // noop\n                },\n            };\n            const dispose = subscribe(request, {\n                next(val) {\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any -- payload will fit type\n                    pending.push(val);\n                    deferred.resolve();\n                },\n                error(err) {\n                    deferred.done = true;\n                    deferred.error = err;\n                    deferred.resolve();\n                },\n                complete() {\n                    deferred.done = true;\n                    deferred.resolve();\n                },\n            });\n            const iterator = (function iterator() {\n                return __asyncGenerator(this, arguments, function* iterator_1() {\n                    for (;;) {\n                        if (!pending.length) {\n                            // only wait if there are no pending messages available\n                            yield __await(new Promise((resolve) => (deferred.resolve = resolve)));\n                        }\n                        // first flush\n                        while (pending.length) {\n                            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                            yield yield __await(pending.shift());\n                        }\n                        // then error\n                        if (deferred.error) {\n                            throw deferred.error;\n                        }\n                        // or complete\n                        if (deferred.done) {\n                            return yield __await(void 0);\n                        }\n                    }\n                });\n            })();\n            iterator.throw = async (err) => {\n                if (!deferred.done) {\n                    deferred.done = true;\n                    deferred.error = err;\n                    deferred.resolve();\n                }\n                return { done: true, value: undefined };\n            };\n            iterator.return = async () => {\n                dispose();\n                return { done: true, value: undefined };\n            };\n            return iterator;\n        },\n        async dispose() {\n            disposed = true;\n            if (connecting) {\n                // if there is a connection, close it\n                const [socket] = await connecting;\n                socket.close(1000, 'Normal Closure');\n            }\n        },\n        terminate() {\n            if (connecting) {\n                // only if there is a connection\n                emitter.emit('closed', new TerminatedCloseEvent());\n            }\n        },\n    };\n}\n/**\n * A synthetic close event `4499: Terminated` is issued to the current to immediately\n * close the connection without waiting for the one coming from `WebSocket.onclose`.\n *\n * Terminating is not considered fatal and a connection retry will occur as expected.\n *\n * Useful in cases where the WebSocket is stuck and not emitting any events;\n * can happen on iOS Safari, see: https://github.com/enisdenjo/graphql-ws/discussions/290.\n */\nclass TerminatedCloseEvent extends Error {\n    constructor() {\n        super(...arguments);\n        this.name = 'TerminatedCloseEvent';\n        this.message = '4499: Terminated';\n        this.code = 4499;\n        this.reason = 'Terminated';\n        this.wasClean = false;\n    }\n}\nfunction isLikeCloseEvent(val) {\n    return (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.isObject)(val) && 'code' in val && 'reason' in val;\n}\nfunction isFatalInternalCloseCode(code) {\n    if ([\n        1000, // Normal Closure is not an erroneous close code\n        1001, // Going Away\n        1006, // Abnormal Closure\n        1005, // No Status Received\n        1012, // Service Restart\n        1013, // Try Again Later\n        1014, // Bad Gateway\n    ].includes(code))\n        return false;\n    // all other internal errors are fatal\n    return code >= 1000 && code <= 1999;\n}\nfunction isWebSocket(val) {\n    return (typeof val === 'function' &&\n        'constructor' in val &&\n        'CLOSED' in val &&\n        'CLOSING' in val &&\n        'CONNECTING' in val &&\n        'OPEN' in val);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2dyYXBocWwtd3MvbGliL2NsaWVudC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBSSxJQUFJLFNBQUksNEJBQTRCO0FBQ3ZELHdCQUF3QixTQUFJLElBQUksU0FBSTtBQUNwQztBQUNBO0FBQ0EsME1BQTBNLGNBQWM7QUFDeE4sOEJBQThCLHNCQUFzQjtBQUNwRCwwQkFBMEIsWUFBWSxzQkFBc0IscUNBQXFDLDJDQUEyQyxNQUFNO0FBQ2xKLDRCQUE0QixNQUFNLGlCQUFpQixZQUFZO0FBQy9ELHVCQUF1QjtBQUN2Qiw4QkFBOEI7QUFDOUIsNkJBQTZCO0FBQzdCLDRCQUE0QjtBQUM1QjtBQUNzSDtBQUM3RDtBQUN6RDtBQUM2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZO0FBQ1osK0JBQStCO0FBQy9CLHdCQUF3QixhQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLLGdFQUFnRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELDRDQUE0QztBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyw4Q0FBOEM7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEYsc0VBQTZCO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0Esd0NBQXdDLDZEQUFnQixHQUFHLE1BQU0sb0RBQVcsT0FBTztBQUNuRjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw2REFBZ0I7QUFDaEQ7QUFDQSxrQ0FBa0Msb0RBQVc7QUFDN0M7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG9EQUFXO0FBQzdDO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxrREFBUztBQUNsRCx5QkFBeUI7QUFDekI7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtEQUFTLHNCQUFzQiw0REFBZ0I7QUFDaEY7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE1BQU07QUFDeEM7QUFDQSxvQ0FBb0MseURBQVk7QUFDaEQ7QUFDQTtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsNkRBQWdCO0FBQ3hEO0FBQ0EsMENBQTBDLG9EQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxvREFBVztBQUNyRDtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMseUNBQXlDLG9EQUFXO0FBQ3BELDJFQUEyRSxhQUFhO0FBQ3hGO0FBQ0E7QUFDQSxrRkFBa0Y7QUFDbEYsc0NBQXNDO0FBQ3RDLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSxpQ0FBaUMsa0RBQVMsY0FBYyw0REFBZ0I7QUFDeEU7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0RBQVM7QUFDN0Isb0JBQW9CLGtEQUFTO0FBQzdCLG9CQUFvQixrREFBUztBQUM3QixvQkFBb0Isa0RBQVM7QUFDN0Isb0JBQW9CLGtEQUFTO0FBQzdCO0FBQ0Esb0JBQW9CLGtEQUFTO0FBQzdCO0FBQ0E7QUFDQSxvQkFBb0Isa0RBQVM7QUFDN0Isb0JBQW9CLGtEQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsb0RBQVc7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsb0RBQVc7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxvREFBVztBQUM1QztBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsZ0NBQWdDLDZEQUFnQjtBQUNoRDtBQUNBLDhCQUE4QixvREFBVztBQUN6QztBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsNkRBQWdCO0FBQ3hEO0FBQ0Esc0NBQXNDLG9EQUFXO0FBQ2pELDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUyxHQUFHO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvREFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvc2hlcmlmZi9EZXNrdG9wL2JpdGNhc2gtYXBwcy9tYXN0ZXJib3RzL25vZGVfbW9kdWxlcy9ncmFwaHFsLXdzL2xpYi9jbGllbnQubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICpcbiAqIGNsaWVudFxuICpcbiAqL1xudmFyIF9fYXdhaXQgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXQpIHx8IGZ1bmN0aW9uICh2KSB7IHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpOyB9XG52YXIgX19hc3luY0dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19hc3luY0dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcbiAgICByZXR1cm4gaSA9IE9iamVjdC5jcmVhdGUoKHR5cGVvZiBBc3luY0l0ZXJhdG9yID09PSBcImZ1bmN0aW9uXCIgPyBBc3luY0l0ZXJhdG9yIDogT2JqZWN0KS5wcm90b3R5cGUpLCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIsIGF3YWl0UmV0dXJuKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xuICAgIGZ1bmN0aW9uIGF3YWl0UmV0dXJuKGYpIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUodikudGhlbihmLCByZWplY3QpOyB9OyB9XG4gICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlmIChnW25dKSB7IGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IGlmIChmKSBpW25dID0gZihpW25dKTsgfSB9XG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxufTtcbmltcG9ydCB7IENsb3NlQ29kZSwgR1JBUEhRTF9UUkFOU1BPUlRfV1NfUFJPVE9DT0wsIE1lc3NhZ2VUeXBlLCBwYXJzZU1lc3NhZ2UsIHN0cmluZ2lmeU1lc3NhZ2UsIH0gZnJvbSAnLi9jb21tb24ubWpzJztcbmltcG9ydCB7IGlzT2JqZWN0LCBsaW1pdENsb3NlUmVhc29uIH0gZnJvbSAnLi91dGlscy5tanMnO1xuLyoqIFRoaXMgZmlsZSBpcyB0aGUgZW50cnkgcG9pbnQgZm9yIGJyb3dzZXJzLCByZS1leHBvcnQgY29tbW9uIGVsZW1lbnRzLiAqL1xuZXhwb3J0ICogZnJvbSAnLi9jb21tb24ubWpzJztcbi8qKlxuICogQ3JlYXRlcyBhIGRpc3Bvc2FibGUgR3JhcGhRTCBvdmVyIFdlYlNvY2tldCBjbGllbnQuXG4gKlxuICogQGNhdGVnb3J5IENsaWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ2xpZW50KG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHVybCwgY29ubmVjdGlvblBhcmFtcywgbGF6eSA9IHRydWUsIG9uTm9uTGF6eUVycm9yID0gY29uc29sZS5lcnJvciwgbGF6eUNsb3NlVGltZW91dDogbGF6eUNsb3NlVGltZW91dE1zID0gMCwga2VlcEFsaXZlID0gMCwgZGlzYWJsZVBvbmcsIGNvbm5lY3Rpb25BY2tXYWl0VGltZW91dCA9IDAsIHJldHJ5QXR0ZW1wdHMgPSA1LCByZXRyeVdhaXQgPSBhc3luYyBmdW5jdGlvbiByYW5kb21pc2VkRXhwb25lbnRpYWxCYWNrb2ZmKHJldHJpZXMpIHtcbiAgICAgICAgbGV0IHJldHJ5RGVsYXkgPSAxMDAwOyAvLyBzdGFydCB3aXRoIDFzIGRlbGF5XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmV0cmllczsgaSsrKSB7XG4gICAgICAgICAgICByZXRyeURlbGF5ICo9IDI7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgcmV0cnlEZWxheSArXG4gICAgICAgICAgICAvLyBhZGQgcmFuZG9tIHRpbWVvdXQgZnJvbSAzMDBtcyB0byAzc1xuICAgICAgICAgICAgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKDMwMDAgLSAzMDApICsgMzAwKSkpO1xuICAgIH0sIHNob3VsZFJldHJ5ID0gaXNMaWtlQ2xvc2VFdmVudCwgaXNGYXRhbENvbm5lY3Rpb25Qcm9ibGVtLCBvbiwgd2ViU29ja2V0SW1wbCwgXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgdjQgVVVJRCB0byBiZSB1c2VkIGFzIHRoZSBJRCB1c2luZyBgTWF0aGBcbiAgICAgKiBhcyB0aGUgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IuIFN1cHBseSB5b3VyIG93biBnZW5lcmF0b3JcbiAgICAgKiBpbiBjYXNlIHlvdSBuZWVkIG1vcmUgdW5pcXVlbmVzcy5cbiAgICAgKlxuICAgICAqIFJlZmVyZW5jZTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vamVkLzk4Mjg4M1xuICAgICAqL1xuICAgIGdlbmVyYXRlSUQgPSBmdW5jdGlvbiBnZW5lcmF0ZVVVSUQoKSB7XG4gICAgICAgIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIChjKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByID0gKE1hdGgucmFuZG9tKCkgKiAxNikgfCAwLCB2ID0gYyA9PSAneCcgPyByIDogKHIgJiAweDMpIHwgMHg4O1xuICAgICAgICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuICAgICAgICB9KTtcbiAgICB9LCBqc29uTWVzc2FnZVJlcGxhY2VyOiByZXBsYWNlciwganNvbk1lc3NhZ2VSZXZpdmVyOiByZXZpdmVyLCB9ID0gb3B0aW9ucztcbiAgICBsZXQgd3M7XG4gICAgaWYgKHdlYlNvY2tldEltcGwpIHtcbiAgICAgICAgaWYgKCFpc1dlYlNvY2tldCh3ZWJTb2NrZXRJbXBsKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFdlYlNvY2tldCBpbXBsZW1lbnRhdGlvbiBwcm92aWRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHdzID0gd2ViU29ja2V0SW1wbDtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIFdlYlNvY2tldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgd3MgPSBXZWJTb2NrZXQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHdzID1cbiAgICAgICAgICAgIGdsb2JhbC5XZWJTb2NrZXQgfHxcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBTdXBwb3J0IG1vcmUgYnJvd3NlcnNcbiAgICAgICAgICAgICAgICBnbG9iYWwuTW96V2ViU29ja2V0O1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB3cyA9XG4gICAgICAgICAgICB3aW5kb3cuV2ViU29ja2V0IHx8XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogU3VwcG9ydCBtb3JlIGJyb3dzZXJzXG4gICAgICAgICAgICAgICAgd2luZG93Lk1veldlYlNvY2tldDtcbiAgICB9XG4gICAgaWYgKCF3cylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2ViU29ja2V0IGltcGxlbWVudGF0aW9uIG1pc3Npbmc7IG9uIE5vZGUgeW91IGNhbiBgaW1wb3J0IFdlYlNvY2tldCBmcm9tICd3cyc7YCBhbmQgcGFzcyBgd2ViU29ja2V0SW1wbDogV2ViU29ja2V0YCB0byBgY3JlYXRlQ2xpZW50YFwiKTtcbiAgICBjb25zdCBXZWJTb2NrZXRJbXBsID0gd3M7XG4gICAgLy8gd2Vic29ja2V0IHN0YXR1cyBlbWl0dGVyLCBzdWJzY3JpcHRpb25zIGFyZSBoYW5kbGVkIGRpZmZlcmVudGx5XG4gICAgY29uc3QgZW1pdHRlciA9ICgoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXJzID0ge307XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG9uKGlkLCBsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnNbaWRdID0gbGlzdGVuZXI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgbGlzdGVuZXJzW2lkXTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVtaXQobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIGlmICgnaWQnIGluIG1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAoX2EgPSBsaXN0ZW5lcnNbbWVzc2FnZS5pZF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGxpc3RlbmVycywgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKCk7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHtcbiAgICAgICAgICAgIGNvbm5lY3Rpbmc6IChvbiA9PT0gbnVsbCB8fCBvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb24uY29ubmVjdGluZykgPyBbb24uY29ubmVjdGluZ10gOiBbXSxcbiAgICAgICAgICAgIG9wZW5lZDogKG9uID09PSBudWxsIHx8IG9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbi5vcGVuZWQpID8gW29uLm9wZW5lZF0gOiBbXSxcbiAgICAgICAgICAgIGNvbm5lY3RlZDogKG9uID09PSBudWxsIHx8IG9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbi5jb25uZWN0ZWQpID8gW29uLmNvbm5lY3RlZF0gOiBbXSxcbiAgICAgICAgICAgIHBpbmc6IChvbiA9PT0gbnVsbCB8fCBvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb24ucGluZykgPyBbb24ucGluZ10gOiBbXSxcbiAgICAgICAgICAgIHBvbmc6IChvbiA9PT0gbnVsbCB8fCBvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb24ucG9uZykgPyBbb24ucG9uZ10gOiBbXSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IChvbiA9PT0gbnVsbCB8fCBvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb24ubWVzc2FnZSkgPyBbbWVzc2FnZS5lbWl0LCBvbi5tZXNzYWdlXSA6IFttZXNzYWdlLmVtaXRdLFxuICAgICAgICAgICAgY2xvc2VkOiAob24gPT09IG51bGwgfHwgb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uLmNsb3NlZCkgPyBbb24uY2xvc2VkXSA6IFtdLFxuICAgICAgICAgICAgZXJyb3I6IChvbiA9PT0gbnVsbCB8fCBvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb24uZXJyb3IpID8gW29uLmVycm9yXSA6IFtdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb25NZXNzYWdlOiBtZXNzYWdlLm9uLFxuICAgICAgICAgICAgb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbCA9IGxpc3RlbmVyc1tldmVudF07XG4gICAgICAgICAgICAgICAgbC5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsLnNwbGljZShsLmluZGV4T2YobGlzdGVuZXIpLCAxKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVtaXQoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBjb3B5IHRoZSBsaXN0ZW5lcnMgc28gdGhhdCB1bmxpc3RlbnMgZG9udCBcInB1bGwgdGhlIHJ1ZyB1bmRlciBvdXIgZmVldFwiXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiBbLi4ubGlzdGVuZXJzW2V2ZW50XV0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogVGhlIGFyZ3Mgc2hvdWxkIGZpdFxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lciguLi5hcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0pKCk7XG4gICAgLy8gaW52b2tlcyB0aGUgY2FsbGJhY2sgZWl0aGVyIHdoZW4gYW4gZXJyb3Igb3IgY2xvc2VkIGV2ZW50IGlzIGVtaXR0ZWQsXG4gICAgLy8gZmlyc3Qgb25lIHRoYXQgZ2V0cyBjYWxsZWQgcHJldmFpbHMsIG90aGVyIGVtaXNzaW9ucyBhcmUgaWdub3JlZFxuICAgIGZ1bmN0aW9uIGVycm9yT3JDbG9zZWQoY2IpIHtcbiAgICAgICAgY29uc3QgbGlzdGVuaW5nID0gW1xuICAgICAgICAgICAgLy8gZXJyb3JzIGFyZSBmYXRhbCBhbmQgbW9yZSBjcml0aWNhbCB0aGFuIGNsb3NlIGV2ZW50cywgdGhyb3cgdGhlbSBmaXJzdFxuICAgICAgICAgICAgZW1pdHRlci5vbignZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgbGlzdGVuaW5nLmZvckVhY2goKHVubGlzdGVuKSA9PiB1bmxpc3RlbigpKTtcbiAgICAgICAgICAgICAgICBjYihlcnIpO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAvLyBjbG9zZXMgY2FuIGJlIGdyYWNlZnVsIGFuZCBub3QgZmF0YWwsIHRocm93IHRoZW0gc2Vjb25kIChpZiBlcnJvciBkaWRudCB0aHJvdylcbiAgICAgICAgICAgIGVtaXR0ZXIub24oJ2Nsb3NlZCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGxpc3RlbmluZy5mb3JFYWNoKCh1bmxpc3RlbikgPT4gdW5saXN0ZW4oKSk7XG4gICAgICAgICAgICAgICAgY2IoZXZlbnQpO1xuICAgICAgICAgICAgfSksXG4gICAgICAgIF07XG4gICAgfVxuICAgIGxldCBjb25uZWN0aW5nLCBsb2NrcyA9IDAsIGxhenlDbG9zZVRpbWVvdXQsIHJldHJ5aW5nID0gZmFsc2UsIHJldHJpZXMgPSAwLCBkaXNwb3NlZCA9IGZhbHNlO1xuICAgIGFzeW5jIGZ1bmN0aW9uIGNvbm5lY3QoKSB7XG4gICAgICAgIC8vIGNsZWFyIHRoZSBsYXp5IGNsb3NlIHRpbWVvdXQgaW1tZWRpYXRlbGx5IHNvIHRoYXQgY2xvc2UgZ2V0cyBkZWJvdW5jZWRcbiAgICAgICAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vZW5pc2RlbmpvL2dyYXBocWwtd3MvaXNzdWVzLzM4OFxuICAgICAgICBjbGVhclRpbWVvdXQobGF6eUNsb3NlVGltZW91dCk7XG4gICAgICAgIGNvbnN0IFtzb2NrZXQsIHRocm93T25DbG9zZV0gPSBhd2FpdCAoY29ubmVjdGluZyAhPT0gbnVsbCAmJiBjb25uZWN0aW5nICE9PSB2b2lkIDAgPyBjb25uZWN0aW5nIDogKGNvbm5lY3RpbmcgPSBuZXcgUHJvbWlzZSgoY29ubmVjdGVkLCBkZW5pZWQpID0+IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAocmV0cnlpbmcpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCByZXRyeVdhaXQocmV0cmllcyk7XG4gICAgICAgICAgICAgICAgLy8gc3Vic2NyaXB0aW9ucyBtaWdodCBjb21wbGV0ZSB3aGlsZSB3YWl0aW5nIGZvciByZXRyeVxuICAgICAgICAgICAgICAgIGlmICghbG9ja3MpIHtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlbmllZCh7IGNvZGU6IDEwMDAsIHJlYXNvbjogJ0FsbCBTdWJzY3JpcHRpb25zIEdvbmUnIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXRyaWVzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ2Nvbm5lY3RpbmcnLCByZXRyeWluZyk7XG4gICAgICAgICAgICBjb25zdCBzb2NrZXQgPSBuZXcgV2ViU29ja2V0SW1wbCh0eXBlb2YgdXJsID09PSAnZnVuY3Rpb24nID8gYXdhaXQgdXJsKCkgOiB1cmwsIEdSQVBIUUxfVFJBTlNQT1JUX1dTX1BST1RPQ09MKTtcbiAgICAgICAgICAgIGxldCBjb25uZWN0aW9uQWNrVGltZW91dCwgcXVldWVkUGluZztcbiAgICAgICAgICAgIGZ1bmN0aW9uIGVucXVldWVQaW5nKCkge1xuICAgICAgICAgICAgICAgIGlmIChpc0Zpbml0ZShrZWVwQWxpdmUpICYmIGtlZXBBbGl2ZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHF1ZXVlZFBpbmcpOyAvLyBpbiBjYXNlIHdoZXJlIGEgcG9uZyB3YXMgcmVjZWl2ZWQgYmVmb3JlIGEgcGluZyAodGhpcyBpcyB2YWxpZCBiZWhhdmlvdXIpXG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlZFBpbmcgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzb2NrZXQucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0SW1wbC5PUEVOKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc29ja2V0LnNlbmQoc3RyaW5naWZ5TWVzc2FnZSh7IHR5cGU6IE1lc3NhZ2VUeXBlLlBpbmcgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgncGluZycsIGZhbHNlLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBrZWVwQWxpdmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVycm9yT3JDbG9zZWQoKGVyck9yRXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW5nID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChjb25uZWN0aW9uQWNrVGltZW91dCk7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHF1ZXVlZFBpbmcpO1xuICAgICAgICAgICAgICAgIGRlbmllZChlcnJPckV2ZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyT3JFdmVudCBpbnN0YW5jZW9mIFRlcm1pbmF0ZWRDbG9zZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5jbG9zZSg0NDk5LCAnVGVybWluYXRlZCcpOyAvLyBjbG9zZSBldmVudCBpcyBhcnRpZmljaWFsIGFuZCBlbWl0dGVkIG1hbnVhbGx5LCBzZWUgYENsaWVudC50ZXJtaW5hdGUoKWAgYmVsb3dcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0Lm9uZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQub25jbG9zZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzb2NrZXQub25lcnJvciA9IChlcnIpID0+IGVtaXR0ZXIuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgc29ja2V0Lm9uY2xvc2UgPSAoZXZlbnQpID0+IGVtaXR0ZXIuZW1pdCgnY2xvc2VkJywgZXZlbnQpO1xuICAgICAgICAgICAgc29ja2V0Lm9ub3BlbiA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ29wZW5lZCcsIHNvY2tldCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB0eXBlb2YgY29ubmVjdGlvblBhcmFtcyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBhd2FpdCBjb25uZWN0aW9uUGFyYW1zKClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogY29ubmVjdGlvblBhcmFtcztcbiAgICAgICAgICAgICAgICAgICAgLy8gY29ubmVjdGlvblBhcmFtcyBtaWdodCB0YWtlIHRvbyBsb25nIGNhdXNpbmcgdGhlIHNlcnZlciB0byBraWNrIG9mZiB0aGUgY2xpZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBuZWNlc3NhcnkgZXJyb3IvY2xvc2UgZXZlbnQgaXMgYWxyZWFkeSByZXBvcnRlZCAtIHNpbXBseSBzdG9wIGV4ZWN1dGlvblxuICAgICAgICAgICAgICAgICAgICBpZiAoc29ja2V0LnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldEltcGwuT1BFTilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LnNlbmQoc3RyaW5naWZ5TWVzc2FnZShwYXlsb2FkXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5Db25uZWN0aW9uSW5pdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuQ29ubmVjdGlvbkluaXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGF5bG9hZCBpcyBjb21wbGV0ZWx5IGFic2VudCBpZiBub3QgcHJvdmlkZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHJlcGxhY2VyKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Zpbml0ZShjb25uZWN0aW9uQWNrV2FpdFRpbWVvdXQpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uQWNrV2FpdFRpbWVvdXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uQWNrVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldC5jbG9zZShDbG9zZUNvZGUuQ29ubmVjdGlvbkFja25vd2xlZGdlbWVudFRpbWVvdXQsICdDb25uZWN0aW9uIGFja25vd2xlZGdlbWVudCB0aW1lb3V0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBjb25uZWN0aW9uQWNrV2FpdFRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVucXVldWVQaW5nKCk7IC8vIGVucXVldWUgcGluZyAobm9vcCBpZiBkaXNhYmxlZClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LmNsb3NlKENsb3NlQ29kZS5JbnRlcm5hbENsaWVudEVycm9yLCBsaW1pdENsb3NlUmVhc29uKGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiBuZXcgRXJyb3IoZXJyKS5tZXNzYWdlLCAnSW50ZXJuYWwgY2xpZW50IGVycm9yJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgYWNrbm93bGVkZ2VkID0gZmFsc2U7XG4gICAgICAgICAgICBzb2NrZXQub25tZXNzYWdlID0gKHsgZGF0YSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IHBhcnNlTWVzc2FnZShkYXRhLCByZXZpdmVyKTtcbiAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLnR5cGUgPT09ICdwaW5nJyB8fCBtZXNzYWdlLnR5cGUgPT09ICdwb25nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KG1lc3NhZ2UudHlwZSwgdHJ1ZSwgbWVzc2FnZS5wYXlsb2FkKTsgLy8gcmVjZWl2ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLnR5cGUgPT09ICdwb25nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVucXVldWVQaW5nKCk7IC8vIGVucXVldWUgbmV4dCBwaW5nIChub29wIGlmIGRpc2FibGVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWRpc2FibGVQb25nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVzcG9uZCB3aXRoIHBvbmcgb24gcGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldC5zZW5kKHN0cmluZ2lmeU1lc3NhZ2UobWVzc2FnZS5wYXlsb2FkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuUG9uZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IG1lc3NhZ2UucGF5bG9hZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLlBvbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwYXlsb2FkIGlzIGNvbXBsZXRlbHkgYWJzZW50IGlmIG5vdCBwcm92aWRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdwb25nJywgZmFsc2UsIG1lc3NhZ2UucGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIHBpbmcgYW5kIHBvbmdzIGNhbiBiZSByZWNlaXZlZCB3aGVuZXZlclxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY2tub3dsZWRnZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIGFscmVhZHkgY29ubmVjdGVkIGFuZCBhY2tub3dsZWRnZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPT0gTWVzc2FnZVR5cGUuQ29ubmVjdGlvbkFjaylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmlyc3QgbWVzc2FnZSBjYW5ub3QgYmUgb2YgdHlwZSAke21lc3NhZ2UudHlwZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGNvbm5lY3Rpb25BY2tUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgYWNrbm93bGVkZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdjb25uZWN0ZWQnLCBzb2NrZXQsIG1lc3NhZ2UucGF5bG9hZCwgcmV0cnlpbmcpOyAvLyBjb25uZWN0ZWQgPSBzb2NrZXQgb3BlbmVkICsgYWNrbm93bGVkZ2VkXG4gICAgICAgICAgICAgICAgICAgIHJldHJ5aW5nID0gZmFsc2U7IC8vIGZ1dHVyZSBsYXp5IGNvbm5lY3RzIGFyZSBub3QgcmV0cmllc1xuICAgICAgICAgICAgICAgICAgICByZXRyaWVzID0gMDsgLy8gcmVzZXQgdGhlIHJldHJpZXMgb24gY29ubmVjdFxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0ZWQoW1xuICAgICAgICAgICAgICAgICAgICAgICAgc29ja2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4gZXJyb3JPckNsb3NlZChyZWplY3QpKSxcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0Lm9ubWVzc2FnZSA9IG51bGw7IC8vIHN0b3AgcmVhZGluZyBtZXNzYWdlcyBhcyBzb29uIGFzIHJlYWRpbmcgYnJlYWtzIG9uY2VcbiAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5jbG9zZShDbG9zZUNvZGUuQmFkUmVzcG9uc2UsIGxpbWl0Q2xvc2VSZWFzb24oZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6IG5ldyBFcnJvcihlcnIpLm1lc3NhZ2UsICdCYWQgcmVzcG9uc2UnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkoKSkpKTtcbiAgICAgICAgLy8gaWYgdGhlIHByb3ZpZGVkIHNvY2tldCBpcyBpbiBhIGNsb3Npbmcgc3RhdGUsIHdhaXQgZm9yIHRoZSB0aHJvdyBvbiBjbG9zZVxuICAgICAgICBpZiAoc29ja2V0LnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldEltcGwuQ0xPU0lORylcbiAgICAgICAgICAgIGF3YWl0IHRocm93T25DbG9zZTtcbiAgICAgICAgbGV0IHJlbGVhc2UgPSAoKSA9PiB7XG4gICAgICAgICAgICAvLyByZWxlYXNlcyB0aGlzIGNvbm5lY3Rpb25cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVsZWFzZWQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gKHJlbGVhc2UgPSByZXNvbHZlKSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBzb2NrZXQsXG4gICAgICAgICAgICByZWxlYXNlLFxuICAgICAgICAgICAgUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgICAgICAgICAvLyB3YWl0IGZvclxuICAgICAgICAgICAgICAgIHJlbGVhc2VkLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWxvY2tzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgaWYgbm8gbW9yZSBsb2NrcyBhcmUgcHJlc2VudCwgY29tcGxldGUgdGhlIGNvbm5lY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4gc29ja2V0LmNsb3NlKDEwMDAsICdOb3JtYWwgQ2xvc3VyZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRmluaXRlKGxhenlDbG9zZVRpbWVvdXRNcykgJiYgbGF6eUNsb3NlVGltZW91dE1zID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBrZWVwYWxpdmUgaXMgc2V0LCBhbGxvdyBmb3IgdGhlIHNwZWNpZmllZCBjYWxtZG93biB0aW1lIGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZW4gY29tcGxldGUgaWYgdGhlIHNvY2tldCBpcyBzdGlsbCBvcGVuLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhenlDbG9zZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvY2tldC5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXRJbXBsLk9QRU4pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGxhenlDbG9zZVRpbWVvdXRNcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgY29tcGxldGUgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgLy8gb3JcbiAgICAgICAgICAgICAgICB0aHJvd09uQ2xvc2UsXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHRoZSBgY29ubmVjdGAgcHJvYmxlbSBhbmQgZXZhbHVhdGVzIGlmIHRoZSBjbGllbnQgc2hvdWxkIHJldHJ5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNob3VsZFJldHJ5Q29ubmVjdE9yVGhyb3coZXJyT3JDbG9zZUV2ZW50KSB7XG4gICAgICAgIC8vIHNvbWUgY2xvc2UgY29kZXMgYXJlIHdvcnRoIHJlcG9ydGluZyBpbW1lZGlhdGVseVxuICAgICAgICBpZiAoaXNMaWtlQ2xvc2VFdmVudChlcnJPckNsb3NlRXZlbnQpICYmXG4gICAgICAgICAgICAoaXNGYXRhbEludGVybmFsQ2xvc2VDb2RlKGVyck9yQ2xvc2VFdmVudC5jb2RlKSB8fFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgQ2xvc2VDb2RlLkludGVybmFsU2VydmVyRXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIENsb3NlQ29kZS5JbnRlcm5hbENsaWVudEVycm9yLFxuICAgICAgICAgICAgICAgICAgICBDbG9zZUNvZGUuQmFkUmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgQ2xvc2VDb2RlLkJhZFJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICBDbG9zZUNvZGUuVW5hdXRob3JpemVkLFxuICAgICAgICAgICAgICAgICAgICAvLyBDbG9zZUNvZGUuRm9yYmlkZGVuLCBtaWdodCBncmFudCBhY2Nlc3Mgb3V0IGFmdGVyIHJldHJ5XG4gICAgICAgICAgICAgICAgICAgIENsb3NlQ29kZS5TdWJwcm90b2NvbE5vdEFjY2VwdGFibGUsXG4gICAgICAgICAgICAgICAgICAgIC8vIENsb3NlQ29kZS5Db25uZWN0aW9uSW5pdGlhbGlzYXRpb25UaW1lb3V0LCBtaWdodCBub3QgdGltZSBvdXQgYWZ0ZXIgcmV0cnlcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2xvc2VDb2RlLkNvbm5lY3Rpb25BY2tub3dsZWRnZW1lbnRUaW1lb3V0LCBtaWdodCBub3QgdGltZSBvdXQgYWZ0ZXIgcmV0cnlcbiAgICAgICAgICAgICAgICAgICAgQ2xvc2VDb2RlLlN1YnNjcmliZXJBbHJlYWR5RXhpc3RzLFxuICAgICAgICAgICAgICAgICAgICBDbG9zZUNvZGUuVG9vTWFueUluaXRpYWxpc2F0aW9uUmVxdWVzdHMsXG4gICAgICAgICAgICAgICAgICAgIC8vIDQ0OTksIC8vIFRlcm1pbmF0ZWQsIHByb2JhYmx5IGJlY2F1c2UgdGhlIHNvY2tldCBmcm96ZSwgd2Ugd2FudCB0byByZXRyeVxuICAgICAgICAgICAgICAgIF0uaW5jbHVkZXMoZXJyT3JDbG9zZUV2ZW50LmNvZGUpKSlcbiAgICAgICAgICAgIHRocm93IGVyck9yQ2xvc2VFdmVudDtcbiAgICAgICAgLy8gY2xpZW50IHdhcyBkaXNwb3NlZCwgbm8gcmV0cmllcyBzaG91bGQgcHJvY2VlZCByZWdhcmRsZXNzXG4gICAgICAgIGlmIChkaXNwb3NlZClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gbm9ybWFsIGNsb3N1cmUgKHBvc3NpYmx5IGFsbCBzdWJzY3JpcHRpb25zIGhhdmUgY29tcGxldGVkKVxuICAgICAgICAvLyBpZiBubyBsb2NrcyB3ZXJlIGFjcXVpcmVkIGluIHRoZSBtZWFudGltZSwgc2hvdWxkbnQgdHJ5IGFnYWluXG4gICAgICAgIGlmIChpc0xpa2VDbG9zZUV2ZW50KGVyck9yQ2xvc2VFdmVudCkgJiYgZXJyT3JDbG9zZUV2ZW50LmNvZGUgPT09IDEwMDApXG4gICAgICAgICAgICByZXR1cm4gbG9ja3MgPiAwO1xuICAgICAgICAvLyByZXRyaWVzIGFyZSBub3QgYWxsb3dlZCBvciB3ZSB0cmllZCB0byBtYW55IHRpbWVzLCByZXBvcnQgZXJyb3JcbiAgICAgICAgaWYgKCFyZXRyeUF0dGVtcHRzIHx8IHJldHJpZXMgPj0gcmV0cnlBdHRlbXB0cylcbiAgICAgICAgICAgIHRocm93IGVyck9yQ2xvc2VFdmVudDtcbiAgICAgICAgLy8gdGhyb3cgbm9uLXJldHJ5YWJsZSBjb25uZWN0aW9uIHByb2JsZW1zXG4gICAgICAgIGlmICghc2hvdWxkUmV0cnkoZXJyT3JDbG9zZUV2ZW50KSlcbiAgICAgICAgICAgIHRocm93IGVyck9yQ2xvc2VFdmVudDtcbiAgICAgICAgLy8gQGRlcHJlY2F0ZWQgdGhyb3cgZmF0YWwgY29ubmVjdGlvbiBwcm9ibGVtcyBpbW1lZGlhdGVseVxuICAgICAgICBpZiAoaXNGYXRhbENvbm5lY3Rpb25Qcm9ibGVtID09PSBudWxsIHx8IGlzRmF0YWxDb25uZWN0aW9uUHJvYmxlbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaXNGYXRhbENvbm5lY3Rpb25Qcm9ibGVtKGVyck9yQ2xvc2VFdmVudCkpXG4gICAgICAgICAgICB0aHJvdyBlcnJPckNsb3NlRXZlbnQ7XG4gICAgICAgIC8vIGxvb2tzIGdvb2QsIHN0YXJ0IHJldHJ5aW5nXG4gICAgICAgIHJldHVybiAocmV0cnlpbmcgPSB0cnVlKTtcbiAgICB9XG4gICAgLy8gaW4gbm9uLWxhenkgKGhvdD8pIG1vZGUgYWx3YXlzIGhvbGQgb25lIGNvbm5lY3Rpb24gbG9jayB0byBwZXJzaXN0IHRoZSBzb2NrZXRcbiAgICBpZiAoIWxhenkpIHtcbiAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGxvY2tzKys7XG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgWywgLCB0aHJvd09uQ2xvc2VdID0gYXdhaXQgY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aHJvd09uQ2xvc2U7IC8vIHdpbGwgYWx3YXlzIHRocm93IGJlY2F1c2UgcmVsZWFzZXIgaXMgbm90IHVzZWRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVyck9yQ2xvc2VFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzaG91bGRSZXRyeUNvbm5lY3RPclRocm93KGVyck9yQ2xvc2VFdmVudCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJPckNsb3NlRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlcG9ydCB0aHJvd24gZXJyb3IsIG5vIGZ1cnRoZXIgcmV0cmllc1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9uTm9uTGF6eUVycm9yID09PSBudWxsIHx8IG9uTm9uTGF6eUVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbk5vbkxhenlFcnJvcihlcnJPckNsb3NlRXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdWJzY3JpYmUocGF5bG9hZCwgc2luaykge1xuICAgICAgICBjb25zdCBpZCA9IGdlbmVyYXRlSUQocGF5bG9hZCk7XG4gICAgICAgIGxldCBkb25lID0gZmFsc2UsIGVycm9yZWQgPSBmYWxzZSwgcmVsZWFzZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICAvLyBmb3IgaGFuZGxpbmcgY29tcGxldGlvbnMgYmVmb3JlIGNvbm5lY3RcbiAgICAgICAgICAgIGxvY2tzLS07XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGxvY2tzKys7XG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW3NvY2tldCwgcmVsZWFzZSwgd2FpdEZvclJlbGVhc2VPclRocm93T25DbG9zZV0gPSBhd2FpdCBjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGRvbmUgd2hpbGUgd2FpdGluZyBmb3IgY29ubmVjdCwgcmVsZWFzZSB0aGUgY29ubmVjdGlvbiBsb2NrIHJpZ2h0IGF3YXlcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVsZWFzZSgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1bmxpc3RlbiA9IGVtaXR0ZXIub25NZXNzYWdlKGlkLCAobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChtZXNzYWdlLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLk5leHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgLS0gcGF5bG9hZCB3aWxsIGZpdCB0eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpbmsubmV4dChtZXNzYWdlLnBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuRXJyb3I6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGVycm9yZWQgPSB0cnVlKSwgKGRvbmUgPSB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2luay5lcnJvcihtZXNzYWdlLnBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxlYXNlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuQ29tcGxldGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbGVhc2VyKCk7IC8vIHJlbGVhc2UgY29tcGxldGVzIHRoZSBzaW5rXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQuc2VuZChzdHJpbmdpZnlNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuU3Vic2NyaWJlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgICAgICAgICAgICAgfSwgcmVwbGFjZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVsZWFzZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRvbmUgJiYgc29ja2V0LnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldEltcGwuT1BFTilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBub3QgY29tcGxldGVkIGFscmVhZHkgYW5kIHNvY2tldCBpcyBvcGVuLCBzZW5kIGNvbXBsZXRlIG1lc3NhZ2UgdG8gc2VydmVyIG9uIHJlbGVhc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQuc2VuZChzdHJpbmdpZnlNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLkNvbXBsZXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHJlcGxhY2VyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2Nrcy0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWxlYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIC8vIGVpdGhlciB0aGUgcmVsZWFzZXIgd2lsbCBiZSBjYWxsZWQsIGNvbm5lY3Rpb24gY29tcGxldGVkIGFuZFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgcHJvbWlzZSByZXNvbHZlZCBvciB0aGUgc29ja2V0IGNsb3NlZCBhbmQgdGhlIHByb21pc2UgcmVqZWN0ZWQuXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoYXRldmVyIGhhcHBlbnMgdGhvdWdoLCB3ZSB3YW50IHRvIHN0b3AgbGlzdGVuaW5nIGZvciBtZXNzYWdlc1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB3YWl0Rm9yUmVsZWFzZU9yVGhyb3dPbkNsb3NlLmZpbmFsbHkodW5saXN0ZW4pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIGNvbXBsZXRlZCwgc2hvdWxkbnQgdHJ5IGFnYWluXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJPckNsb3NlRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzaG91bGRSZXRyeUNvbm5lY3RPclRocm93KGVyck9yQ2xvc2VFdmVudCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAvLyBkZWxpdmVyaW5nIGVpdGhlciBhbiBlcnJvciBvciBhIGNvbXBsZXRlIHRlcm1pbmF0ZXMgdGhlIHNlcXVlbmNlXG4gICAgICAgICAgICBpZiAoIWVycm9yZWQpXG4gICAgICAgICAgICAgICAgc2luay5jb21wbGV0ZSgpO1xuICAgICAgICB9KSAvLyByZXNvbHZlcyBvbiByZWxlYXNlIG9yIG5vcm1hbCBjbG9zdXJlXG4gICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgc2luay5lcnJvcihlcnIpO1xuICAgICAgICB9KTsgLy8gcmVqZWN0cyBvbiBjbG9zZSBldmVudHMgYW5kIGVycm9yc1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgLy8gZGlzcG9zZSBvbmx5IG9mIGFjdGl2ZSBzdWJzY3JpcHRpb25zXG4gICAgICAgICAgICBpZiAoIWRvbmUpXG4gICAgICAgICAgICAgICAgcmVsZWFzZXIoKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgb246IGVtaXR0ZXIub24sXG4gICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgaXRlcmF0ZShyZXF1ZXN0KSB7XG4gICAgICAgICAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgICAgICAgICBjb25zdCBkZWZlcnJlZCA9IHtcbiAgICAgICAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgICByZXNvbHZlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vb3BcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGRpc3Bvc2UgPSBzdWJzY3JpYmUocmVxdWVzdCwge1xuICAgICAgICAgICAgICAgIG5leHQodmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55IC0tIHBheWxvYWQgd2lsbCBmaXQgdHlwZVxuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nLnB1c2godmFsKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXJyb3IoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLmRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5lcnJvciA9IGVycjtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY29tcGxldGUoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLmRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgaXRlcmF0b3IgPSAoZnVuY3Rpb24gaXRlcmF0b3IoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogaXRlcmF0b3JfMSgpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwZW5kaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgd2FpdCBpZiB0aGVyZSBhcmUgbm8gcGVuZGluZyBtZXNzYWdlcyBhdmFpbGFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCBfX2F3YWl0KG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiAoZGVmZXJyZWQucmVzb2x2ZSA9IHJlc29sdmUpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmaXJzdCBmbHVzaFxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHBlbmRpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KHBlbmRpbmcuc2hpZnQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGVuIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVmZXJyZWQuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBkZWZlcnJlZC5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9yIGNvbXBsZXRlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVmZXJyZWQuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCBfX2F3YWl0KHZvaWQgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICBpdGVyYXRvci50aHJvdyA9IGFzeW5jIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWRlZmVycmVkLmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLmVycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpdGVyYXRvci5yZXR1cm4gPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gaXRlcmF0b3I7XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIGRpc3Bvc2UoKSB7XG4gICAgICAgICAgICBkaXNwb3NlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoY29ubmVjdGluZykge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgY29ubmVjdGlvbiwgY2xvc2UgaXRcbiAgICAgICAgICAgICAgICBjb25zdCBbc29ja2V0XSA9IGF3YWl0IGNvbm5lY3Rpbmc7XG4gICAgICAgICAgICAgICAgc29ja2V0LmNsb3NlKDEwMDAsICdOb3JtYWwgQ2xvc3VyZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0ZXJtaW5hdGUoKSB7XG4gICAgICAgICAgICBpZiAoY29ubmVjdGluZykge1xuICAgICAgICAgICAgICAgIC8vIG9ubHkgaWYgdGhlcmUgaXMgYSBjb25uZWN0aW9uXG4gICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdjbG9zZWQnLCBuZXcgVGVybWluYXRlZENsb3NlRXZlbnQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogQSBzeW50aGV0aWMgY2xvc2UgZXZlbnQgYDQ0OTk6IFRlcm1pbmF0ZWRgIGlzIGlzc3VlZCB0byB0aGUgY3VycmVudCB0byBpbW1lZGlhdGVseVxuICogY2xvc2UgdGhlIGNvbm5lY3Rpb24gd2l0aG91dCB3YWl0aW5nIGZvciB0aGUgb25lIGNvbWluZyBmcm9tIGBXZWJTb2NrZXQub25jbG9zZWAuXG4gKlxuICogVGVybWluYXRpbmcgaXMgbm90IGNvbnNpZGVyZWQgZmF0YWwgYW5kIGEgY29ubmVjdGlvbiByZXRyeSB3aWxsIG9jY3VyIGFzIGV4cGVjdGVkLlxuICpcbiAqIFVzZWZ1bCBpbiBjYXNlcyB3aGVyZSB0aGUgV2ViU29ja2V0IGlzIHN0dWNrIGFuZCBub3QgZW1pdHRpbmcgYW55IGV2ZW50cztcbiAqIGNhbiBoYXBwZW4gb24gaU9TIFNhZmFyaSwgc2VlOiBodHRwczovL2dpdGh1Yi5jb20vZW5pc2RlbmpvL2dyYXBocWwtd3MvZGlzY3Vzc2lvbnMvMjkwLlxuICovXG5leHBvcnQgY2xhc3MgVGVybWluYXRlZENsb3NlRXZlbnQgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdUZXJtaW5hdGVkQ2xvc2VFdmVudCc7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9ICc0NDk5OiBUZXJtaW5hdGVkJztcbiAgICAgICAgdGhpcy5jb2RlID0gNDQ5OTtcbiAgICAgICAgdGhpcy5yZWFzb24gPSAnVGVybWluYXRlZCc7XG4gICAgICAgIHRoaXMud2FzQ2xlYW4gPSBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc0xpa2VDbG9zZUV2ZW50KHZhbCkge1xuICAgIHJldHVybiBpc09iamVjdCh2YWwpICYmICdjb2RlJyBpbiB2YWwgJiYgJ3JlYXNvbicgaW4gdmFsO1xufVxuZnVuY3Rpb24gaXNGYXRhbEludGVybmFsQ2xvc2VDb2RlKGNvZGUpIHtcbiAgICBpZiAoW1xuICAgICAgICAxMDAwLCAvLyBOb3JtYWwgQ2xvc3VyZSBpcyBub3QgYW4gZXJyb25lb3VzIGNsb3NlIGNvZGVcbiAgICAgICAgMTAwMSwgLy8gR29pbmcgQXdheVxuICAgICAgICAxMDA2LCAvLyBBYm5vcm1hbCBDbG9zdXJlXG4gICAgICAgIDEwMDUsIC8vIE5vIFN0YXR1cyBSZWNlaXZlZFxuICAgICAgICAxMDEyLCAvLyBTZXJ2aWNlIFJlc3RhcnRcbiAgICAgICAgMTAxMywgLy8gVHJ5IEFnYWluIExhdGVyXG4gICAgICAgIDEwMTQsIC8vIEJhZCBHYXRld2F5XG4gICAgXS5pbmNsdWRlcyhjb2RlKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIC8vIGFsbCBvdGhlciBpbnRlcm5hbCBlcnJvcnMgYXJlIGZhdGFsXG4gICAgcmV0dXJuIGNvZGUgPj0gMTAwMCAmJiBjb2RlIDw9IDE5OTk7XG59XG5mdW5jdGlvbiBpc1dlYlNvY2tldCh2YWwpIHtcbiAgICByZXR1cm4gKHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgJ2NvbnN0cnVjdG9yJyBpbiB2YWwgJiZcbiAgICAgICAgJ0NMT1NFRCcgaW4gdmFsICYmXG4gICAgICAgICdDTE9TSU5HJyBpbiB2YWwgJiZcbiAgICAgICAgJ0NPTk5FQ1RJTkcnIGluIHZhbCAmJlxuICAgICAgICAnT1BFTicgaW4gdmFsKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/graphql-ws/lib/client.mjs\n",
      );

      /***/
    },

  /***/ "(rsc)/../../node_modules/graphql-ws/lib/common.mjs":
    /*!****************************************************!*\
  !*** ../../node_modules/graphql-ws/lib/common.mjs ***!
  \****************************************************/
    /***/ (
      __unused_webpack___webpack_module__,
      __webpack_exports__,
      __webpack_require__,
    ) => {
      eval(
        '__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CloseCode: () => (/* binding */ CloseCode),\n/* harmony export */   DEPRECATED_GRAPHQL_WS_PROTOCOL: () => (/* binding */ DEPRECATED_GRAPHQL_WS_PROTOCOL),\n/* harmony export */   GRAPHQL_TRANSPORT_WS_PROTOCOL: () => (/* binding */ GRAPHQL_TRANSPORT_WS_PROTOCOL),\n/* harmony export */   MessageType: () => (/* binding */ MessageType),\n/* harmony export */   isMessage: () => (/* binding */ isMessage),\n/* harmony export */   parseMessage: () => (/* binding */ parseMessage),\n/* harmony export */   stringifyMessage: () => (/* binding */ stringifyMessage),\n/* harmony export */   validateMessage: () => (/* binding */ validateMessage)\n/* harmony export */ });\n/* harmony import */ var _utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.mjs */ "(rsc)/../../node_modules/graphql-ws/lib/utils.mjs");\n/**\n *\n * common\n *\n */\n\n/**\n * The WebSocket sub-protocol used for the [GraphQL over WebSocket Protocol](https://github.com/graphql/graphql-over-http/blob/main/rfcs/GraphQLOverWebSocket.md).\n *\n * @category Common\n */\nconst GRAPHQL_TRANSPORT_WS_PROTOCOL = \'graphql-transport-ws\';\n/**\n * The deprecated subprotocol used by [subscriptions-transport-ws](https://github.com/apollographql/subscriptions-transport-ws).\n *\n * @private\n */\nconst DEPRECATED_GRAPHQL_WS_PROTOCOL = \'graphql-ws\';\n/**\n * `graphql-ws` expected and standard close codes of the [GraphQL over WebSocket Protocol](https://github.com/graphql/graphql-over-http/blob/main/rfcs/GraphQLOverWebSocket.md).\n *\n * @category Common\n */\nvar CloseCode;\n(function (CloseCode) {\n    CloseCode[CloseCode["InternalServerError"] = 4500] = "InternalServerError";\n    CloseCode[CloseCode["InternalClientError"] = 4005] = "InternalClientError";\n    CloseCode[CloseCode["BadRequest"] = 4400] = "BadRequest";\n    CloseCode[CloseCode["BadResponse"] = 4004] = "BadResponse";\n    /** Tried subscribing before connect ack */\n    CloseCode[CloseCode["Unauthorized"] = 4401] = "Unauthorized";\n    CloseCode[CloseCode["Forbidden"] = 4403] = "Forbidden";\n    CloseCode[CloseCode["SubprotocolNotAcceptable"] = 4406] = "SubprotocolNotAcceptable";\n    CloseCode[CloseCode["ConnectionInitialisationTimeout"] = 4408] = "ConnectionInitialisationTimeout";\n    CloseCode[CloseCode["ConnectionAcknowledgementTimeout"] = 4504] = "ConnectionAcknowledgementTimeout";\n    /** Subscriber distinction is very important */\n    CloseCode[CloseCode["SubscriberAlreadyExists"] = 4409] = "SubscriberAlreadyExists";\n    CloseCode[CloseCode["TooManyInitialisationRequests"] = 4429] = "TooManyInitialisationRequests";\n})(CloseCode || (CloseCode = {}));\n/**\n * Types of messages allowed to be sent by the client/server over the WS protocol.\n *\n * @category Common\n */\nvar MessageType;\n(function (MessageType) {\n    MessageType["ConnectionInit"] = "connection_init";\n    MessageType["ConnectionAck"] = "connection_ack";\n    MessageType["Ping"] = "ping";\n    MessageType["Pong"] = "pong";\n    MessageType["Subscribe"] = "subscribe";\n    MessageType["Next"] = "next";\n    MessageType["Error"] = "error";\n    MessageType["Complete"] = "complete";\n})(MessageType || (MessageType = {}));\n/**\n * Validates the message against the GraphQL over WebSocket Protocol.\n *\n * Invalid messages will throw descriptive errors.\n *\n * @category Common\n */\nfunction validateMessage(val) {\n    if (!(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(val)) {\n        throw new Error(`Message is expected to be an object, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val)}`);\n    }\n    if (!val.type) {\n        throw new Error(`Message is missing the \'type\' property`);\n    }\n    if (typeof val.type !== \'string\') {\n        throw new Error(`Message is expects the \'type\' property to be a string, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.type)}`);\n    }\n    switch (val.type) {\n        case MessageType.ConnectionInit:\n        case MessageType.ConnectionAck:\n        case MessageType.Ping:\n        case MessageType.Pong: {\n            if (val.payload != null && !(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(val.payload)) {\n                throw new Error(`"${val.type}" message expects the \'payload\' property to be an object or nullish or missing, but got "${val.payload}"`);\n            }\n            break;\n        }\n        case MessageType.Subscribe: {\n            if (typeof val.id !== \'string\') {\n                throw new Error(`"${val.type}" message expects the \'id\' property to be a string, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.id)}`);\n            }\n            if (!val.id) {\n                throw new Error(`"${val.type}" message requires a non-empty \'id\' property`);\n            }\n            if (!(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(val.payload)) {\n                throw new Error(`"${val.type}" message expects the \'payload\' property to be an object, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.payload)}`);\n            }\n            if (typeof val.payload.query !== \'string\') {\n                throw new Error(`"${val.type}" message payload expects the \'query\' property to be a string, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.payload.query)}`);\n            }\n            if (val.payload.variables != null && !(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(val.payload.variables)) {\n                throw new Error(`"${val.type}" message payload expects the \'variables\' property to be a an object or nullish or missing, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.payload.variables)}`);\n            }\n            if (val.payload.operationName != null &&\n                (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.payload.operationName) !== \'string\') {\n                throw new Error(`"${val.type}" message payload expects the \'operationName\' property to be a string or nullish or missing, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.payload.operationName)}`);\n            }\n            if (val.payload.extensions != null && !(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(val.payload.extensions)) {\n                throw new Error(`"${val.type}" message payload expects the \'extensions\' property to be a an object or nullish or missing, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.payload.extensions)}`);\n            }\n            break;\n        }\n        case MessageType.Next: {\n            if (typeof val.id !== \'string\') {\n                throw new Error(`"${val.type}" message expects the \'id\' property to be a string, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.id)}`);\n            }\n            if (!val.id) {\n                throw new Error(`"${val.type}" message requires a non-empty \'id\' property`);\n            }\n            if (!(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(val.payload)) {\n                throw new Error(`"${val.type}" message expects the \'payload\' property to be an object, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.payload)}`);\n            }\n            break;\n        }\n        case MessageType.Error: {\n            if (typeof val.id !== \'string\') {\n                throw new Error(`"${val.type}" message expects the \'id\' property to be a string, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.id)}`);\n            }\n            if (!val.id) {\n                throw new Error(`"${val.type}" message requires a non-empty \'id\' property`);\n            }\n            if (!(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.areGraphQLErrors)(val.payload)) {\n                throw new Error(`"${val.type}" message expects the \'payload\' property to be an array of GraphQL errors, but got ${JSON.stringify(val.payload)}`);\n            }\n            break;\n        }\n        case MessageType.Complete: {\n            if (typeof val.id !== \'string\') {\n                throw new Error(`"${val.type}" message expects the \'id\' property to be a string, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.id)}`);\n            }\n            if (!val.id) {\n                throw new Error(`"${val.type}" message requires a non-empty \'id\' property`);\n            }\n            break;\n        }\n        default:\n            throw new Error(`Invalid message \'type\' property "${val.type}"`);\n    }\n    return val;\n}\n/**\n * Checks if the provided value is a valid GraphQL over WebSocket message.\n *\n * @deprecated Use `validateMessage` instead.\n *\n * @category Common\n */\nfunction isMessage(val) {\n    try {\n        validateMessage(val);\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n}\n/**\n * Parses the raw websocket message data to a valid message.\n *\n * @category Common\n */\nfunction parseMessage(data, reviver) {\n    return validateMessage(typeof data === \'string\' ? JSON.parse(data, reviver) : data);\n}\n/**\n * Stringifies a valid message ready to be sent through the socket.\n *\n * @category Common\n */\nfunction stringifyMessage(msg, replacer) {\n    validateMessage(msg);\n    return JSON.stringify(msg, replacer);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2dyYXBocWwtd3MvbGliL2NvbW1vbi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUN5RTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4QkFBOEI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQ0FBa0M7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFNBQVMsb0RBQVE7QUFDakIsd0VBQXdFLDBEQUFjLE1BQU07QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRiwwREFBYyxXQUFXO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxvREFBUTtBQUNoRCxvQ0FBb0MsU0FBUywyRkFBMkYsWUFBWTtBQUNwSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFNBQVMsOERBQThELDBEQUFjLFNBQVM7QUFDbEk7QUFDQTtBQUNBLG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0EsaUJBQWlCLG9EQUFRO0FBQ3pCLG9DQUFvQyxTQUFTLG9FQUFvRSwwREFBYyxjQUFjO0FBQzdJO0FBQ0E7QUFDQSxvQ0FBb0MsU0FBUyx5RUFBeUUsMERBQWMsb0JBQW9CO0FBQ3hKO0FBQ0Esa0RBQWtELG9EQUFRO0FBQzFELG9DQUFvQyxTQUFTLHNHQUFzRywwREFBYyx3QkFBd0I7QUFDekw7QUFDQTtBQUNBLGdCQUFnQiwwREFBYztBQUM5QixvQ0FBb0MsU0FBUyx1R0FBdUcsMERBQWMsNEJBQTRCO0FBQzlMO0FBQ0EsbURBQW1ELG9EQUFRO0FBQzNELG9DQUFvQyxTQUFTLHVHQUF1RywwREFBYyx5QkFBeUI7QUFDM0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxTQUFTLDhEQUE4RCwwREFBYyxTQUFTO0FBQ2xJO0FBQ0E7QUFDQSxvQ0FBb0MsU0FBUztBQUM3QztBQUNBLGlCQUFpQixvREFBUTtBQUN6QixvQ0FBb0MsU0FBUyxvRUFBb0UsMERBQWMsY0FBYztBQUM3STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFNBQVMsOERBQThELDBEQUFjLFNBQVM7QUFDbEk7QUFDQTtBQUNBLG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0EsaUJBQWlCLDREQUFnQjtBQUNqQyxvQ0FBb0MsU0FBUyxxRkFBcUYsNEJBQTRCO0FBQzlKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsU0FBUyw4REFBOEQsMERBQWMsU0FBUztBQUNsSTtBQUNBO0FBQ0Esb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsU0FBUztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zaGVyaWZmL0Rlc2t0b3AvYml0Y2FzaC1hcHBzL21hc3RlcmJvdHMvbm9kZV9tb2R1bGVzL2dyYXBocWwtd3MvbGliL2NvbW1vbi5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKlxuICogY29tbW9uXG4gKlxuICovXG5pbXBvcnQgeyBhcmVHcmFwaFFMRXJyb3JzLCBleHRlbmRlZFR5cGVvZiwgaXNPYmplY3QgfSBmcm9tICcuL3V0aWxzLm1qcyc7XG4vKipcbiAqIFRoZSBXZWJTb2NrZXQgc3ViLXByb3RvY29sIHVzZWQgZm9yIHRoZSBbR3JhcGhRTCBvdmVyIFdlYlNvY2tldCBQcm90b2NvbF0oaHR0cHM6Ly9naXRodWIuY29tL2dyYXBocWwvZ3JhcGhxbC1vdmVyLWh0dHAvYmxvYi9tYWluL3JmY3MvR3JhcGhRTE92ZXJXZWJTb2NrZXQubWQpLlxuICpcbiAqIEBjYXRlZ29yeSBDb21tb25cbiAqL1xuZXhwb3J0IGNvbnN0IEdSQVBIUUxfVFJBTlNQT1JUX1dTX1BST1RPQ09MID0gJ2dyYXBocWwtdHJhbnNwb3J0LXdzJztcbi8qKlxuICogVGhlIGRlcHJlY2F0ZWQgc3VicHJvdG9jb2wgdXNlZCBieSBbc3Vic2NyaXB0aW9ucy10cmFuc3BvcnQtd3NdKGh0dHBzOi8vZ2l0aHViLmNvbS9hcG9sbG9ncmFwaHFsL3N1YnNjcmlwdGlvbnMtdHJhbnNwb3J0LXdzKS5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgREVQUkVDQVRFRF9HUkFQSFFMX1dTX1BST1RPQ09MID0gJ2dyYXBocWwtd3MnO1xuLyoqXG4gKiBgZ3JhcGhxbC13c2AgZXhwZWN0ZWQgYW5kIHN0YW5kYXJkIGNsb3NlIGNvZGVzIG9mIHRoZSBbR3JhcGhRTCBvdmVyIFdlYlNvY2tldCBQcm90b2NvbF0oaHR0cHM6Ly9naXRodWIuY29tL2dyYXBocWwvZ3JhcGhxbC1vdmVyLWh0dHAvYmxvYi9tYWluL3JmY3MvR3JhcGhRTE92ZXJXZWJTb2NrZXQubWQpLlxuICpcbiAqIEBjYXRlZ29yeSBDb21tb25cbiAqL1xuZXhwb3J0IHZhciBDbG9zZUNvZGU7XG4oZnVuY3Rpb24gKENsb3NlQ29kZSkge1xuICAgIENsb3NlQ29kZVtDbG9zZUNvZGVbXCJJbnRlcm5hbFNlcnZlckVycm9yXCJdID0gNDUwMF0gPSBcIkludGVybmFsU2VydmVyRXJyb3JcIjtcbiAgICBDbG9zZUNvZGVbQ2xvc2VDb2RlW1wiSW50ZXJuYWxDbGllbnRFcnJvclwiXSA9IDQwMDVdID0gXCJJbnRlcm5hbENsaWVudEVycm9yXCI7XG4gICAgQ2xvc2VDb2RlW0Nsb3NlQ29kZVtcIkJhZFJlcXVlc3RcIl0gPSA0NDAwXSA9IFwiQmFkUmVxdWVzdFwiO1xuICAgIENsb3NlQ29kZVtDbG9zZUNvZGVbXCJCYWRSZXNwb25zZVwiXSA9IDQwMDRdID0gXCJCYWRSZXNwb25zZVwiO1xuICAgIC8qKiBUcmllZCBzdWJzY3JpYmluZyBiZWZvcmUgY29ubmVjdCBhY2sgKi9cbiAgICBDbG9zZUNvZGVbQ2xvc2VDb2RlW1wiVW5hdXRob3JpemVkXCJdID0gNDQwMV0gPSBcIlVuYXV0aG9yaXplZFwiO1xuICAgIENsb3NlQ29kZVtDbG9zZUNvZGVbXCJGb3JiaWRkZW5cIl0gPSA0NDAzXSA9IFwiRm9yYmlkZGVuXCI7XG4gICAgQ2xvc2VDb2RlW0Nsb3NlQ29kZVtcIlN1YnByb3RvY29sTm90QWNjZXB0YWJsZVwiXSA9IDQ0MDZdID0gXCJTdWJwcm90b2NvbE5vdEFjY2VwdGFibGVcIjtcbiAgICBDbG9zZUNvZGVbQ2xvc2VDb2RlW1wiQ29ubmVjdGlvbkluaXRpYWxpc2F0aW9uVGltZW91dFwiXSA9IDQ0MDhdID0gXCJDb25uZWN0aW9uSW5pdGlhbGlzYXRpb25UaW1lb3V0XCI7XG4gICAgQ2xvc2VDb2RlW0Nsb3NlQ29kZVtcIkNvbm5lY3Rpb25BY2tub3dsZWRnZW1lbnRUaW1lb3V0XCJdID0gNDUwNF0gPSBcIkNvbm5lY3Rpb25BY2tub3dsZWRnZW1lbnRUaW1lb3V0XCI7XG4gICAgLyoqIFN1YnNjcmliZXIgZGlzdGluY3Rpb24gaXMgdmVyeSBpbXBvcnRhbnQgKi9cbiAgICBDbG9zZUNvZGVbQ2xvc2VDb2RlW1wiU3Vic2NyaWJlckFscmVhZHlFeGlzdHNcIl0gPSA0NDA5XSA9IFwiU3Vic2NyaWJlckFscmVhZHlFeGlzdHNcIjtcbiAgICBDbG9zZUNvZGVbQ2xvc2VDb2RlW1wiVG9vTWFueUluaXRpYWxpc2F0aW9uUmVxdWVzdHNcIl0gPSA0NDI5XSA9IFwiVG9vTWFueUluaXRpYWxpc2F0aW9uUmVxdWVzdHNcIjtcbn0pKENsb3NlQ29kZSB8fCAoQ2xvc2VDb2RlID0ge30pKTtcbi8qKlxuICogVHlwZXMgb2YgbWVzc2FnZXMgYWxsb3dlZCB0byBiZSBzZW50IGJ5IHRoZSBjbGllbnQvc2VydmVyIG92ZXIgdGhlIFdTIHByb3RvY29sLlxuICpcbiAqIEBjYXRlZ29yeSBDb21tb25cbiAqL1xuZXhwb3J0IHZhciBNZXNzYWdlVHlwZTtcbihmdW5jdGlvbiAoTWVzc2FnZVR5cGUpIHtcbiAgICBNZXNzYWdlVHlwZVtcIkNvbm5lY3Rpb25Jbml0XCJdID0gXCJjb25uZWN0aW9uX2luaXRcIjtcbiAgICBNZXNzYWdlVHlwZVtcIkNvbm5lY3Rpb25BY2tcIl0gPSBcImNvbm5lY3Rpb25fYWNrXCI7XG4gICAgTWVzc2FnZVR5cGVbXCJQaW5nXCJdID0gXCJwaW5nXCI7XG4gICAgTWVzc2FnZVR5cGVbXCJQb25nXCJdID0gXCJwb25nXCI7XG4gICAgTWVzc2FnZVR5cGVbXCJTdWJzY3JpYmVcIl0gPSBcInN1YnNjcmliZVwiO1xuICAgIE1lc3NhZ2VUeXBlW1wiTmV4dFwiXSA9IFwibmV4dFwiO1xuICAgIE1lc3NhZ2VUeXBlW1wiRXJyb3JcIl0gPSBcImVycm9yXCI7XG4gICAgTWVzc2FnZVR5cGVbXCJDb21wbGV0ZVwiXSA9IFwiY29tcGxldGVcIjtcbn0pKE1lc3NhZ2VUeXBlIHx8IChNZXNzYWdlVHlwZSA9IHt9KSk7XG4vKipcbiAqIFZhbGlkYXRlcyB0aGUgbWVzc2FnZSBhZ2FpbnN0IHRoZSBHcmFwaFFMIG92ZXIgV2ViU29ja2V0IFByb3RvY29sLlxuICpcbiAqIEludmFsaWQgbWVzc2FnZXMgd2lsbCB0aHJvdyBkZXNjcmlwdGl2ZSBlcnJvcnMuXG4gKlxuICogQGNhdGVnb3J5IENvbW1vblxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVNZXNzYWdlKHZhbCkge1xuICAgIGlmICghaXNPYmplY3QodmFsKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1lc3NhZ2UgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gb2JqZWN0LCBidXQgZ290ICR7ZXh0ZW5kZWRUeXBlb2YodmFsKX1gKTtcbiAgICB9XG4gICAgaWYgKCF2YWwudHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1lc3NhZ2UgaXMgbWlzc2luZyB0aGUgJ3R5cGUnIHByb3BlcnR5YCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsLnR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTWVzc2FnZSBpcyBleHBlY3RzIHRoZSAndHlwZScgcHJvcGVydHkgdG8gYmUgYSBzdHJpbmcsIGJ1dCBnb3QgJHtleHRlbmRlZFR5cGVvZih2YWwudHlwZSl9YCk7XG4gICAgfVxuICAgIHN3aXRjaCAodmFsLnR5cGUpIHtcbiAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5Db25uZWN0aW9uSW5pdDpcbiAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5Db25uZWN0aW9uQWNrOlxuICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLlBpbmc6XG4gICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuUG9uZzoge1xuICAgICAgICAgICAgaWYgKHZhbC5wYXlsb2FkICE9IG51bGwgJiYgIWlzT2JqZWN0KHZhbC5wYXlsb2FkKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke3ZhbC50eXBlfVwiIG1lc3NhZ2UgZXhwZWN0cyB0aGUgJ3BheWxvYWQnIHByb3BlcnR5IHRvIGJlIGFuIG9iamVjdCBvciBudWxsaXNoIG9yIG1pc3NpbmcsIGJ1dCBnb3QgXCIke3ZhbC5wYXlsb2FkfVwiYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLlN1YnNjcmliZToge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwuaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSBleHBlY3RzIHRoZSAnaWQnIHByb3BlcnR5IHRvIGJlIGEgc3RyaW5nLCBidXQgZ290ICR7ZXh0ZW5kZWRUeXBlb2YodmFsLmlkKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdmFsLmlkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSByZXF1aXJlcyBhIG5vbi1lbXB0eSAnaWQnIHByb3BlcnR5YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzT2JqZWN0KHZhbC5wYXlsb2FkKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke3ZhbC50eXBlfVwiIG1lc3NhZ2UgZXhwZWN0cyB0aGUgJ3BheWxvYWQnIHByb3BlcnR5IHRvIGJlIGFuIG9iamVjdCwgYnV0IGdvdCAke2V4dGVuZGVkVHlwZW9mKHZhbC5wYXlsb2FkKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsLnBheWxvYWQucXVlcnkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSBwYXlsb2FkIGV4cGVjdHMgdGhlICdxdWVyeScgcHJvcGVydHkgdG8gYmUgYSBzdHJpbmcsIGJ1dCBnb3QgJHtleHRlbmRlZFR5cGVvZih2YWwucGF5bG9hZC5xdWVyeSl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsLnBheWxvYWQudmFyaWFibGVzICE9IG51bGwgJiYgIWlzT2JqZWN0KHZhbC5wYXlsb2FkLnZhcmlhYmxlcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHt2YWwudHlwZX1cIiBtZXNzYWdlIHBheWxvYWQgZXhwZWN0cyB0aGUgJ3ZhcmlhYmxlcycgcHJvcGVydHkgdG8gYmUgYSBhbiBvYmplY3Qgb3IgbnVsbGlzaCBvciBtaXNzaW5nLCBidXQgZ290ICR7ZXh0ZW5kZWRUeXBlb2YodmFsLnBheWxvYWQudmFyaWFibGVzKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWwucGF5bG9hZC5vcGVyYXRpb25OYW1lICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICBleHRlbmRlZFR5cGVvZih2YWwucGF5bG9hZC5vcGVyYXRpb25OYW1lKSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHt2YWwudHlwZX1cIiBtZXNzYWdlIHBheWxvYWQgZXhwZWN0cyB0aGUgJ29wZXJhdGlvbk5hbWUnIHByb3BlcnR5IHRvIGJlIGEgc3RyaW5nIG9yIG51bGxpc2ggb3IgbWlzc2luZywgYnV0IGdvdCAke2V4dGVuZGVkVHlwZW9mKHZhbC5wYXlsb2FkLm9wZXJhdGlvbk5hbWUpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbC5wYXlsb2FkLmV4dGVuc2lvbnMgIT0gbnVsbCAmJiAhaXNPYmplY3QodmFsLnBheWxvYWQuZXh0ZW5zaW9ucykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHt2YWwudHlwZX1cIiBtZXNzYWdlIHBheWxvYWQgZXhwZWN0cyB0aGUgJ2V4dGVuc2lvbnMnIHByb3BlcnR5IHRvIGJlIGEgYW4gb2JqZWN0IG9yIG51bGxpc2ggb3IgbWlzc2luZywgYnV0IGdvdCAke2V4dGVuZGVkVHlwZW9mKHZhbC5wYXlsb2FkLmV4dGVuc2lvbnMpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5OZXh0OiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbC5pZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHt2YWwudHlwZX1cIiBtZXNzYWdlIGV4cGVjdHMgdGhlICdpZCcgcHJvcGVydHkgdG8gYmUgYSBzdHJpbmcsIGJ1dCBnb3QgJHtleHRlbmRlZFR5cGVvZih2YWwuaWQpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF2YWwuaWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHt2YWwudHlwZX1cIiBtZXNzYWdlIHJlcXVpcmVzIGEgbm9uLWVtcHR5ICdpZCcgcHJvcGVydHlgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNPYmplY3QodmFsLnBheWxvYWQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSBleHBlY3RzIHRoZSAncGF5bG9hZCcgcHJvcGVydHkgdG8gYmUgYW4gb2JqZWN0LCBidXQgZ290ICR7ZXh0ZW5kZWRUeXBlb2YodmFsLnBheWxvYWQpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5FcnJvcjoge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwuaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSBleHBlY3RzIHRoZSAnaWQnIHByb3BlcnR5IHRvIGJlIGEgc3RyaW5nLCBidXQgZ290ICR7ZXh0ZW5kZWRUeXBlb2YodmFsLmlkKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdmFsLmlkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSByZXF1aXJlcyBhIG5vbi1lbXB0eSAnaWQnIHByb3BlcnR5YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWFyZUdyYXBoUUxFcnJvcnModmFsLnBheWxvYWQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSBleHBlY3RzIHRoZSAncGF5bG9hZCcgcHJvcGVydHkgdG8gYmUgYW4gYXJyYXkgb2YgR3JhcGhRTCBlcnJvcnMsIGJ1dCBnb3QgJHtKU09OLnN0cmluZ2lmeSh2YWwucGF5bG9hZCl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLkNvbXBsZXRlOiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbC5pZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHt2YWwudHlwZX1cIiBtZXNzYWdlIGV4cGVjdHMgdGhlICdpZCcgcHJvcGVydHkgdG8gYmUgYSBzdHJpbmcsIGJ1dCBnb3QgJHtleHRlbmRlZFR5cGVvZih2YWwuaWQpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF2YWwuaWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHt2YWwudHlwZX1cIiBtZXNzYWdlIHJlcXVpcmVzIGEgbm9uLWVtcHR5ICdpZCcgcHJvcGVydHlgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbWVzc2FnZSAndHlwZScgcHJvcGVydHkgXCIke3ZhbC50eXBlfVwiYCk7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG59XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgcHJvdmlkZWQgdmFsdWUgaXMgYSB2YWxpZCBHcmFwaFFMIG92ZXIgV2ViU29ja2V0IG1lc3NhZ2UuXG4gKlxuICogQGRlcHJlY2F0ZWQgVXNlIGB2YWxpZGF0ZU1lc3NhZ2VgIGluc3RlYWQuXG4gKlxuICogQGNhdGVnb3J5IENvbW1vblxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNNZXNzYWdlKHZhbCkge1xuICAgIHRyeSB7XG4gICAgICAgIHZhbGlkYXRlTWVzc2FnZSh2YWwpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vKipcbiAqIFBhcnNlcyB0aGUgcmF3IHdlYnNvY2tldCBtZXNzYWdlIGRhdGEgdG8gYSB2YWxpZCBtZXNzYWdlLlxuICpcbiAqIEBjYXRlZ29yeSBDb21tb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlTWVzc2FnZShkYXRhLCByZXZpdmVyKSB7XG4gICAgcmV0dXJuIHZhbGlkYXRlTWVzc2FnZSh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgPyBKU09OLnBhcnNlKGRhdGEsIHJldml2ZXIpIDogZGF0YSk7XG59XG4vKipcbiAqIFN0cmluZ2lmaWVzIGEgdmFsaWQgbWVzc2FnZSByZWFkeSB0byBiZSBzZW50IHRocm91Z2ggdGhlIHNvY2tldC5cbiAqXG4gKiBAY2F0ZWdvcnkgQ29tbW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdpZnlNZXNzYWdlKG1zZywgcmVwbGFjZXIpIHtcbiAgICB2YWxpZGF0ZU1lc3NhZ2UobXNnKTtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkobXNnLCByZXBsYWNlcik7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/graphql-ws/lib/common.mjs\n',
      );

      /***/
    },

  /***/ "(rsc)/../../node_modules/graphql-ws/lib/utils.mjs":
    /*!***************************************************!*\
  !*** ../../node_modules/graphql-ws/lib/utils.mjs ***!
  \***************************************************/
    /***/ (
      __unused_webpack___webpack_module__,
      __webpack_exports__,
      __webpack_require__,
    ) => {
      eval(
        "__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   areGraphQLErrors: () => (/* binding */ areGraphQLErrors),\n/* harmony export */   extendedTypeof: () => (/* binding */ extendedTypeof),\n/* harmony export */   isAsyncGenerator: () => (/* binding */ isAsyncGenerator),\n/* harmony export */   isAsyncIterable: () => (/* binding */ isAsyncIterable),\n/* harmony export */   isObject: () => (/* binding */ isObject),\n/* harmony export */   limitCloseReason: () => (/* binding */ limitCloseReason)\n/* harmony export */ });\n/** @private */\nfunction extendedTypeof(val) {\n    if (val === null) {\n        return 'null';\n    }\n    if (Array.isArray(val)) {\n        return 'array';\n    }\n    return typeof val;\n}\n/** @private */\nfunction isObject(val) {\n    return extendedTypeof(val) === 'object';\n}\n/** @private */\nfunction isAsyncIterable(val) {\n    return typeof Object(val)[Symbol.asyncIterator] === 'function';\n}\n/** @private */\nfunction isAsyncGenerator(val) {\n    return (isObject(val) &&\n        typeof Object(val)[Symbol.asyncIterator] === 'function' &&\n        typeof val.return === 'function'\n    // for lazy ones, we only need the return anyway\n    // typeof val.throw === 'function' &&\n    // typeof val.next === 'function'\n    );\n}\n/** @private */\nfunction areGraphQLErrors(obj) {\n    return (Array.isArray(obj) &&\n        // must be at least one error\n        obj.length > 0 &&\n        // error has at least a message\n        obj.every((ob) => 'message' in ob));\n}\n/**\n * Limits the WebSocket close event reason to not exceed a length of one frame.\n * Reference: https://datatracker.ietf.org/doc/html/rfc6455#section-5.2.\n *\n * @private\n */\nfunction limitCloseReason(reason, whenTooLong) {\n    return reason.length < 124 ? reason : whenTooLong;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2dyYXBocWwtd3MvbGliL3V0aWxzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zaGVyaWZmL0Rlc2t0b3AvYml0Y2FzaC1hcHBzL21hc3RlcmJvdHMvbm9kZV9tb2R1bGVzL2dyYXBocWwtd3MvbGliL3V0aWxzLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQHByaXZhdGUgKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmRlZFR5cGVvZih2YWwpIHtcbiAgICBpZiAodmFsID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgfVxuICAgIHJldHVybiB0eXBlb2YgdmFsO1xufVxuLyoqIEBwcml2YXRlICovXG5leHBvcnQgZnVuY3Rpb24gaXNPYmplY3QodmFsKSB7XG4gICAgcmV0dXJuIGV4dGVuZGVkVHlwZW9mKHZhbCkgPT09ICdvYmplY3QnO1xufVxuLyoqIEBwcml2YXRlICovXG5leHBvcnQgZnVuY3Rpb24gaXNBc3luY0l0ZXJhYmxlKHZhbCkge1xuICAgIHJldHVybiB0eXBlb2YgT2JqZWN0KHZhbClbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID09PSAnZnVuY3Rpb24nO1xufVxuLyoqIEBwcml2YXRlICovXG5leHBvcnQgZnVuY3Rpb24gaXNBc3luY0dlbmVyYXRvcih2YWwpIHtcbiAgICByZXR1cm4gKGlzT2JqZWN0KHZhbCkgJiZcbiAgICAgICAgdHlwZW9mIE9iamVjdCh2YWwpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICB0eXBlb2YgdmFsLnJldHVybiA9PT0gJ2Z1bmN0aW9uJ1xuICAgIC8vIGZvciBsYXp5IG9uZXMsIHdlIG9ubHkgbmVlZCB0aGUgcmV0dXJuIGFueXdheVxuICAgIC8vIHR5cGVvZiB2YWwudGhyb3cgPT09ICdmdW5jdGlvbicgJiZcbiAgICAvLyB0eXBlb2YgdmFsLm5leHQgPT09ICdmdW5jdGlvbidcbiAgICApO1xufVxuLyoqIEBwcml2YXRlICovXG5leHBvcnQgZnVuY3Rpb24gYXJlR3JhcGhRTEVycm9ycyhvYmopIHtcbiAgICByZXR1cm4gKEFycmF5LmlzQXJyYXkob2JqKSAmJlxuICAgICAgICAvLyBtdXN0IGJlIGF0IGxlYXN0IG9uZSBlcnJvclxuICAgICAgICBvYmoubGVuZ3RoID4gMCAmJlxuICAgICAgICAvLyBlcnJvciBoYXMgYXQgbGVhc3QgYSBtZXNzYWdlXG4gICAgICAgIG9iai5ldmVyeSgob2IpID0+ICdtZXNzYWdlJyBpbiBvYikpO1xufVxuLyoqXG4gKiBMaW1pdHMgdGhlIFdlYlNvY2tldCBjbG9zZSBldmVudCByZWFzb24gdG8gbm90IGV4Y2VlZCBhIGxlbmd0aCBvZiBvbmUgZnJhbWUuXG4gKiBSZWZlcmVuY2U6IGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNjQ1NSNzZWN0aW9uLTUuMi5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gbGltaXRDbG9zZVJlYXNvbihyZWFzb24sIHdoZW5Ub29Mb25nKSB7XG4gICAgcmV0dXJuIHJlYXNvbi5sZW5ndGggPCAxMjQgPyByZWFzb24gOiB3aGVuVG9vTG9uZztcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/graphql-ws/lib/utils.mjs\n",
      );

      /***/
    },

  /***/ "(ssr)/../../node_modules/graphql-ws/lib/client.mjs":
    /*!****************************************************!*\
  !*** ../../node_modules/graphql-ws/lib/client.mjs ***!
  \****************************************************/
    /***/ (
      __unused_webpack___webpack_module__,
      __webpack_exports__,
      __webpack_require__,
    ) => {
      eval(
        "__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CloseCode: () => (/* reexport safe */ _common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode),\n/* harmony export */   DEPRECATED_GRAPHQL_WS_PROTOCOL: () => (/* reexport safe */ _common_mjs__WEBPACK_IMPORTED_MODULE_0__.DEPRECATED_GRAPHQL_WS_PROTOCOL),\n/* harmony export */   GRAPHQL_TRANSPORT_WS_PROTOCOL: () => (/* reexport safe */ _common_mjs__WEBPACK_IMPORTED_MODULE_0__.GRAPHQL_TRANSPORT_WS_PROTOCOL),\n/* harmony export */   MessageType: () => (/* reexport safe */ _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType),\n/* harmony export */   TerminatedCloseEvent: () => (/* binding */ TerminatedCloseEvent),\n/* harmony export */   createClient: () => (/* binding */ createClient),\n/* harmony export */   isMessage: () => (/* reexport safe */ _common_mjs__WEBPACK_IMPORTED_MODULE_0__.isMessage),\n/* harmony export */   parseMessage: () => (/* reexport safe */ _common_mjs__WEBPACK_IMPORTED_MODULE_0__.parseMessage),\n/* harmony export */   stringifyMessage: () => (/* reexport safe */ _common_mjs__WEBPACK_IMPORTED_MODULE_0__.stringifyMessage),\n/* harmony export */   validateMessage: () => (/* reexport safe */ _common_mjs__WEBPACK_IMPORTED_MODULE_0__.validateMessage)\n/* harmony export */ });\n/* harmony import */ var _common_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.mjs */ \"(ssr)/../../node_modules/graphql-ws/lib/common.mjs\");\n/* harmony import */ var _utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.mjs */ \"(ssr)/../../node_modules/graphql-ws/lib/utils.mjs\");\n/**\n *\n * client\n *\n */\nvar __await = (undefined && undefined.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = (undefined && undefined.__asyncGenerator) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\n\n\n/** This file is the entry point for browsers, re-export common elements. */\n\n/**\n * Creates a disposable GraphQL over WebSocket client.\n *\n * @category Client\n */\nfunction createClient(options) {\n    const { url, connectionParams, lazy = true, onNonLazyError = console.error, lazyCloseTimeout: lazyCloseTimeoutMs = 0, keepAlive = 0, disablePong, connectionAckWaitTimeout = 0, retryAttempts = 5, retryWait = async function randomisedExponentialBackoff(retries) {\n        let retryDelay = 1000; // start with 1s delay\n        for (let i = 0; i < retries; i++) {\n            retryDelay *= 2;\n        }\n        await new Promise((resolve) => setTimeout(resolve, retryDelay +\n            // add random timeout from 300ms to 3s\n            Math.floor(Math.random() * (3000 - 300) + 300)));\n    }, shouldRetry = isLikeCloseEvent, isFatalConnectionProblem, on, webSocketImpl, \n    /**\n     * Generates a v4 UUID to be used as the ID using `Math`\n     * as the random number generator. Supply your own generator\n     * in case you need more uniqueness.\n     *\n     * Reference: https://gist.github.com/jed/982883\n     */\n    generateID = function generateUUID() {\n        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n            const r = (Math.random() * 16) | 0, v = c == 'x' ? r : (r & 0x3) | 0x8;\n            return v.toString(16);\n        });\n    }, jsonMessageReplacer: replacer, jsonMessageReviver: reviver, } = options;\n    let ws;\n    if (webSocketImpl) {\n        if (!isWebSocket(webSocketImpl)) {\n            throw new Error('Invalid WebSocket implementation provided');\n        }\n        ws = webSocketImpl;\n    }\n    else if (typeof WebSocket !== 'undefined') {\n        ws = WebSocket;\n    }\n    else if (typeof global !== 'undefined') {\n        ws =\n            global.WebSocket ||\n                // @ts-expect-error: Support more browsers\n                global.MozWebSocket;\n    }\n    else if (typeof window !== 'undefined') {\n        ws =\n            window.WebSocket ||\n                // @ts-expect-error: Support more browsers\n                window.MozWebSocket;\n    }\n    if (!ws)\n        throw new Error(\"WebSocket implementation missing; on Node you can `import WebSocket from 'ws';` and pass `webSocketImpl: WebSocket` to `createClient`\");\n    const WebSocketImpl = ws;\n    // websocket status emitter, subscriptions are handled differently\n    const emitter = (() => {\n        const message = (() => {\n            const listeners = {};\n            return {\n                on(id, listener) {\n                    listeners[id] = listener;\n                    return () => {\n                        delete listeners[id];\n                    };\n                },\n                emit(message) {\n                    var _a;\n                    if ('id' in message)\n                        (_a = listeners[message.id]) === null || _a === void 0 ? void 0 : _a.call(listeners, message);\n                },\n            };\n        })();\n        const listeners = {\n            connecting: (on === null || on === void 0 ? void 0 : on.connecting) ? [on.connecting] : [],\n            opened: (on === null || on === void 0 ? void 0 : on.opened) ? [on.opened] : [],\n            connected: (on === null || on === void 0 ? void 0 : on.connected) ? [on.connected] : [],\n            ping: (on === null || on === void 0 ? void 0 : on.ping) ? [on.ping] : [],\n            pong: (on === null || on === void 0 ? void 0 : on.pong) ? [on.pong] : [],\n            message: (on === null || on === void 0 ? void 0 : on.message) ? [message.emit, on.message] : [message.emit],\n            closed: (on === null || on === void 0 ? void 0 : on.closed) ? [on.closed] : [],\n            error: (on === null || on === void 0 ? void 0 : on.error) ? [on.error] : [],\n        };\n        return {\n            onMessage: message.on,\n            on(event, listener) {\n                const l = listeners[event];\n                l.push(listener);\n                return () => {\n                    l.splice(l.indexOf(listener), 1);\n                };\n            },\n            emit(event, ...args) {\n                // we copy the listeners so that unlistens dont \"pull the rug under our feet\"\n                for (const listener of [...listeners[event]]) {\n                    // @ts-expect-error: The args should fit\n                    listener(...args);\n                }\n            },\n        };\n    })();\n    // invokes the callback either when an error or closed event is emitted,\n    // first one that gets called prevails, other emissions are ignored\n    function errorOrClosed(cb) {\n        const listening = [\n            // errors are fatal and more critical than close events, throw them first\n            emitter.on('error', (err) => {\n                listening.forEach((unlisten) => unlisten());\n                cb(err);\n            }),\n            // closes can be graceful and not fatal, throw them second (if error didnt throw)\n            emitter.on('closed', (event) => {\n                listening.forEach((unlisten) => unlisten());\n                cb(event);\n            }),\n        ];\n    }\n    let connecting, locks = 0, lazyCloseTimeout, retrying = false, retries = 0, disposed = false;\n    async function connect() {\n        // clear the lazy close timeout immediatelly so that close gets debounced\n        // see: https://github.com/enisdenjo/graphql-ws/issues/388\n        clearTimeout(lazyCloseTimeout);\n        const [socket, throwOnClose] = await (connecting !== null && connecting !== void 0 ? connecting : (connecting = new Promise((connected, denied) => (async () => {\n            if (retrying) {\n                await retryWait(retries);\n                // subscriptions might complete while waiting for retry\n                if (!locks) {\n                    connecting = undefined;\n                    return denied({ code: 1000, reason: 'All Subscriptions Gone' });\n                }\n                retries++;\n            }\n            emitter.emit('connecting', retrying);\n            const socket = new WebSocketImpl(typeof url === 'function' ? await url() : url, _common_mjs__WEBPACK_IMPORTED_MODULE_0__.GRAPHQL_TRANSPORT_WS_PROTOCOL);\n            let connectionAckTimeout, queuedPing;\n            function enqueuePing() {\n                if (isFinite(keepAlive) && keepAlive > 0) {\n                    clearTimeout(queuedPing); // in case where a pong was received before a ping (this is valid behaviour)\n                    queuedPing = setTimeout(() => {\n                        if (socket.readyState === WebSocketImpl.OPEN) {\n                            socket.send((0,_common_mjs__WEBPACK_IMPORTED_MODULE_0__.stringifyMessage)({ type: _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.Ping }));\n                            emitter.emit('ping', false, undefined);\n                        }\n                    }, keepAlive);\n                }\n            }\n            errorOrClosed((errOrEvent) => {\n                connecting = undefined;\n                clearTimeout(connectionAckTimeout);\n                clearTimeout(queuedPing);\n                denied(errOrEvent);\n                if (errOrEvent instanceof TerminatedCloseEvent) {\n                    socket.close(4499, 'Terminated'); // close event is artificial and emitted manually, see `Client.terminate()` below\n                    socket.onerror = null;\n                    socket.onclose = null;\n                }\n            });\n            socket.onerror = (err) => emitter.emit('error', err);\n            socket.onclose = (event) => emitter.emit('closed', event);\n            socket.onopen = async () => {\n                try {\n                    emitter.emit('opened', socket);\n                    const payload = typeof connectionParams === 'function'\n                        ? await connectionParams()\n                        : connectionParams;\n                    // connectionParams might take too long causing the server to kick off the client\n                    // the necessary error/close event is already reported - simply stop execution\n                    if (socket.readyState !== WebSocketImpl.OPEN)\n                        return;\n                    socket.send((0,_common_mjs__WEBPACK_IMPORTED_MODULE_0__.stringifyMessage)(payload\n                        ? {\n                            type: _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.ConnectionInit,\n                            payload,\n                        }\n                        : {\n                            type: _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.ConnectionInit,\n                            // payload is completely absent if not provided\n                        }, replacer));\n                    if (isFinite(connectionAckWaitTimeout) &&\n                        connectionAckWaitTimeout > 0) {\n                        connectionAckTimeout = setTimeout(() => {\n                            socket.close(_common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.ConnectionAcknowledgementTimeout, 'Connection acknowledgement timeout');\n                        }, connectionAckWaitTimeout);\n                    }\n                    enqueuePing(); // enqueue ping (noop if disabled)\n                }\n                catch (err) {\n                    emitter.emit('error', err);\n                    socket.close(_common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.InternalClientError, (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.limitCloseReason)(err instanceof Error ? err.message : new Error(err).message, 'Internal client error'));\n                }\n            };\n            let acknowledged = false;\n            socket.onmessage = ({ data }) => {\n                try {\n                    const message = (0,_common_mjs__WEBPACK_IMPORTED_MODULE_0__.parseMessage)(data, reviver);\n                    emitter.emit('message', message);\n                    if (message.type === 'ping' || message.type === 'pong') {\n                        emitter.emit(message.type, true, message.payload); // received\n                        if (message.type === 'pong') {\n                            enqueuePing(); // enqueue next ping (noop if disabled)\n                        }\n                        else if (!disablePong) {\n                            // respond with pong on ping\n                            socket.send((0,_common_mjs__WEBPACK_IMPORTED_MODULE_0__.stringifyMessage)(message.payload\n                                ? {\n                                    type: _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.Pong,\n                                    payload: message.payload,\n                                }\n                                : {\n                                    type: _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.Pong,\n                                    // payload is completely absent if not provided\n                                }));\n                            emitter.emit('pong', false, message.payload);\n                        }\n                        return; // ping and pongs can be received whenever\n                    }\n                    if (acknowledged)\n                        return; // already connected and acknowledged\n                    if (message.type !== _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.ConnectionAck)\n                        throw new Error(`First message cannot be of type ${message.type}`);\n                    clearTimeout(connectionAckTimeout);\n                    acknowledged = true;\n                    emitter.emit('connected', socket, message.payload, retrying); // connected = socket opened + acknowledged\n                    retrying = false; // future lazy connects are not retries\n                    retries = 0; // reset the retries on connect\n                    connected([\n                        socket,\n                        new Promise((_, reject) => errorOrClosed(reject)),\n                    ]);\n                }\n                catch (err) {\n                    socket.onmessage = null; // stop reading messages as soon as reading breaks once\n                    emitter.emit('error', err);\n                    socket.close(_common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.BadResponse, (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.limitCloseReason)(err instanceof Error ? err.message : new Error(err).message, 'Bad response'));\n                }\n            };\n        })())));\n        // if the provided socket is in a closing state, wait for the throw on close\n        if (socket.readyState === WebSocketImpl.CLOSING)\n            await throwOnClose;\n        let release = () => {\n            // releases this connection\n        };\n        const released = new Promise((resolve) => (release = resolve));\n        return [\n            socket,\n            release,\n            Promise.race([\n                // wait for\n                released.then(() => {\n                    if (!locks) {\n                        // and if no more locks are present, complete the connection\n                        const complete = () => socket.close(1000, 'Normal Closure');\n                        if (isFinite(lazyCloseTimeoutMs) && lazyCloseTimeoutMs > 0) {\n                            // if the keepalive is set, allow for the specified calmdown time and\n                            // then complete if the socket is still open.\n                            lazyCloseTimeout = setTimeout(() => {\n                                if (socket.readyState === WebSocketImpl.OPEN)\n                                    complete();\n                            }, lazyCloseTimeoutMs);\n                        }\n                        else {\n                            // otherwise complete immediately\n                            complete();\n                        }\n                    }\n                }),\n                // or\n                throwOnClose,\n            ]),\n        ];\n    }\n    /**\n     * Checks the `connect` problem and evaluates if the client should retry.\n     */\n    function shouldRetryConnectOrThrow(errOrCloseEvent) {\n        // some close codes are worth reporting immediately\n        if (isLikeCloseEvent(errOrCloseEvent) &&\n            (isFatalInternalCloseCode(errOrCloseEvent.code) ||\n                [\n                    _common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.InternalServerError,\n                    _common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.InternalClientError,\n                    _common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.BadRequest,\n                    _common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.BadResponse,\n                    _common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.Unauthorized,\n                    // CloseCode.Forbidden, might grant access out after retry\n                    _common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.SubprotocolNotAcceptable,\n                    // CloseCode.ConnectionInitialisationTimeout, might not time out after retry\n                    // CloseCode.ConnectionAcknowledgementTimeout, might not time out after retry\n                    _common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.SubscriberAlreadyExists,\n                    _common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.TooManyInitialisationRequests,\n                    // 4499, // Terminated, probably because the socket froze, we want to retry\n                ].includes(errOrCloseEvent.code)))\n            throw errOrCloseEvent;\n        // client was disposed, no retries should proceed regardless\n        if (disposed)\n            return false;\n        // normal closure (possibly all subscriptions have completed)\n        // if no locks were acquired in the meantime, shouldnt try again\n        if (isLikeCloseEvent(errOrCloseEvent) && errOrCloseEvent.code === 1000)\n            return locks > 0;\n        // retries are not allowed or we tried to many times, report error\n        if (!retryAttempts || retries >= retryAttempts)\n            throw errOrCloseEvent;\n        // throw non-retryable connection problems\n        if (!shouldRetry(errOrCloseEvent))\n            throw errOrCloseEvent;\n        // @deprecated throw fatal connection problems immediately\n        if (isFatalConnectionProblem === null || isFatalConnectionProblem === void 0 ? void 0 : isFatalConnectionProblem(errOrCloseEvent))\n            throw errOrCloseEvent;\n        // looks good, start retrying\n        return (retrying = true);\n    }\n    // in non-lazy (hot?) mode always hold one connection lock to persist the socket\n    if (!lazy) {\n        (async () => {\n            locks++;\n            for (;;) {\n                try {\n                    const [, , throwOnClose] = await connect();\n                    await throwOnClose; // will always throw because releaser is not used\n                }\n                catch (errOrCloseEvent) {\n                    try {\n                        if (!shouldRetryConnectOrThrow(errOrCloseEvent))\n                            return;\n                    }\n                    catch (errOrCloseEvent) {\n                        // report thrown error, no further retries\n                        return onNonLazyError === null || onNonLazyError === void 0 ? void 0 : onNonLazyError(errOrCloseEvent);\n                    }\n                }\n            }\n        })();\n    }\n    function subscribe(payload, sink) {\n        const id = generateID(payload);\n        let done = false, errored = false, releaser = () => {\n            // for handling completions before connect\n            locks--;\n            done = true;\n        };\n        (async () => {\n            locks++;\n            for (;;) {\n                try {\n                    const [socket, release, waitForReleaseOrThrowOnClose] = await connect();\n                    // if done while waiting for connect, release the connection lock right away\n                    if (done)\n                        return release();\n                    const unlisten = emitter.onMessage(id, (message) => {\n                        switch (message.type) {\n                            case _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.Next: {\n                                // eslint-disable-next-line @typescript-eslint/no-explicit-any -- payload will fit type\n                                sink.next(message.payload);\n                                return;\n                            }\n                            case _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.Error: {\n                                (errored = true), (done = true);\n                                sink.error(message.payload);\n                                releaser();\n                                return;\n                            }\n                            case _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.Complete: {\n                                done = true;\n                                releaser(); // release completes the sink\n                                return;\n                            }\n                        }\n                    });\n                    socket.send((0,_common_mjs__WEBPACK_IMPORTED_MODULE_0__.stringifyMessage)({\n                        id,\n                        type: _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.Subscribe,\n                        payload,\n                    }, replacer));\n                    releaser = () => {\n                        if (!done && socket.readyState === WebSocketImpl.OPEN)\n                            // if not completed already and socket is open, send complete message to server on release\n                            socket.send((0,_common_mjs__WEBPACK_IMPORTED_MODULE_0__.stringifyMessage)({\n                                id,\n                                type: _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.Complete,\n                            }, replacer));\n                        locks--;\n                        done = true;\n                        release();\n                    };\n                    // either the releaser will be called, connection completed and\n                    // the promise resolved or the socket closed and the promise rejected.\n                    // whatever happens though, we want to stop listening for messages\n                    await waitForReleaseOrThrowOnClose.finally(unlisten);\n                    return; // completed, shouldnt try again\n                }\n                catch (errOrCloseEvent) {\n                    if (!shouldRetryConnectOrThrow(errOrCloseEvent))\n                        return;\n                }\n            }\n        })()\n            .then(() => {\n            // delivering either an error or a complete terminates the sequence\n            if (!errored)\n                sink.complete();\n        }) // resolves on release or normal closure\n            .catch((err) => {\n            sink.error(err);\n        }); // rejects on close events and errors\n        return () => {\n            // dispose only of active subscriptions\n            if (!done)\n                releaser();\n        };\n    }\n    return {\n        on: emitter.on,\n        subscribe,\n        iterate(request) {\n            const pending = [];\n            const deferred = {\n                done: false,\n                error: null,\n                resolve: () => {\n                    // noop\n                },\n            };\n            const dispose = subscribe(request, {\n                next(val) {\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any -- payload will fit type\n                    pending.push(val);\n                    deferred.resolve();\n                },\n                error(err) {\n                    deferred.done = true;\n                    deferred.error = err;\n                    deferred.resolve();\n                },\n                complete() {\n                    deferred.done = true;\n                    deferred.resolve();\n                },\n            });\n            const iterator = (function iterator() {\n                return __asyncGenerator(this, arguments, function* iterator_1() {\n                    for (;;) {\n                        if (!pending.length) {\n                            // only wait if there are no pending messages available\n                            yield __await(new Promise((resolve) => (deferred.resolve = resolve)));\n                        }\n                        // first flush\n                        while (pending.length) {\n                            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                            yield yield __await(pending.shift());\n                        }\n                        // then error\n                        if (deferred.error) {\n                            throw deferred.error;\n                        }\n                        // or complete\n                        if (deferred.done) {\n                            return yield __await(void 0);\n                        }\n                    }\n                });\n            })();\n            iterator.throw = async (err) => {\n                if (!deferred.done) {\n                    deferred.done = true;\n                    deferred.error = err;\n                    deferred.resolve();\n                }\n                return { done: true, value: undefined };\n            };\n            iterator.return = async () => {\n                dispose();\n                return { done: true, value: undefined };\n            };\n            return iterator;\n        },\n        async dispose() {\n            disposed = true;\n            if (connecting) {\n                // if there is a connection, close it\n                const [socket] = await connecting;\n                socket.close(1000, 'Normal Closure');\n            }\n        },\n        terminate() {\n            if (connecting) {\n                // only if there is a connection\n                emitter.emit('closed', new TerminatedCloseEvent());\n            }\n        },\n    };\n}\n/**\n * A synthetic close event `4499: Terminated` is issued to the current to immediately\n * close the connection without waiting for the one coming from `WebSocket.onclose`.\n *\n * Terminating is not considered fatal and a connection retry will occur as expected.\n *\n * Useful in cases where the WebSocket is stuck and not emitting any events;\n * can happen on iOS Safari, see: https://github.com/enisdenjo/graphql-ws/discussions/290.\n */\nclass TerminatedCloseEvent extends Error {\n    constructor() {\n        super(...arguments);\n        this.name = 'TerminatedCloseEvent';\n        this.message = '4499: Terminated';\n        this.code = 4499;\n        this.reason = 'Terminated';\n        this.wasClean = false;\n    }\n}\nfunction isLikeCloseEvent(val) {\n    return (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.isObject)(val) && 'code' in val && 'reason' in val;\n}\nfunction isFatalInternalCloseCode(code) {\n    if ([\n        1000, // Normal Closure is not an erroneous close code\n        1001, // Going Away\n        1006, // Abnormal Closure\n        1005, // No Status Received\n        1012, // Service Restart\n        1013, // Try Again Later\n        1014, // Bad Gateway\n    ].includes(code))\n        return false;\n    // all other internal errors are fatal\n    return code >= 1000 && code <= 1999;\n}\nfunction isWebSocket(val) {\n    return (typeof val === 'function' &&\n        'constructor' in val &&\n        'CLOSED' in val &&\n        'CLOSING' in val &&\n        'CONNECTING' in val &&\n        'OPEN' in val);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2dyYXBocWwtd3MvbGliL2NsaWVudC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBSSxJQUFJLFNBQUksNEJBQTRCO0FBQ3ZELHdCQUF3QixTQUFJLElBQUksU0FBSTtBQUNwQztBQUNBO0FBQ0EsME1BQTBNLGNBQWM7QUFDeE4sOEJBQThCLHNCQUFzQjtBQUNwRCwwQkFBMEIsWUFBWSxzQkFBc0IscUNBQXFDLDJDQUEyQyxNQUFNO0FBQ2xKLDRCQUE0QixNQUFNLGlCQUFpQixZQUFZO0FBQy9ELHVCQUF1QjtBQUN2Qiw4QkFBOEI7QUFDOUIsNkJBQTZCO0FBQzdCLDRCQUE0QjtBQUM1QjtBQUNzSDtBQUM3RDtBQUN6RDtBQUM2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZO0FBQ1osK0JBQStCO0FBQy9CLHdCQUF3QixhQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLLGdFQUFnRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELDRDQUE0QztBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyw4Q0FBOEM7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEYsc0VBQTZCO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0Esd0NBQXdDLDZEQUFnQixHQUFHLE1BQU0sb0RBQVcsT0FBTztBQUNuRjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw2REFBZ0I7QUFDaEQ7QUFDQSxrQ0FBa0Msb0RBQVc7QUFDN0M7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG9EQUFXO0FBQzdDO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxrREFBUztBQUNsRCx5QkFBeUI7QUFDekI7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtEQUFTLHNCQUFzQiw0REFBZ0I7QUFDaEY7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE1BQU07QUFDeEM7QUFDQSxvQ0FBb0MseURBQVk7QUFDaEQ7QUFDQTtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsNkRBQWdCO0FBQ3hEO0FBQ0EsMENBQTBDLG9EQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxvREFBVztBQUNyRDtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMseUNBQXlDLG9EQUFXO0FBQ3BELDJFQUEyRSxhQUFhO0FBQ3hGO0FBQ0E7QUFDQSxrRkFBa0Y7QUFDbEYsc0NBQXNDO0FBQ3RDLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSxpQ0FBaUMsa0RBQVMsY0FBYyw0REFBZ0I7QUFDeEU7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0RBQVM7QUFDN0Isb0JBQW9CLGtEQUFTO0FBQzdCLG9CQUFvQixrREFBUztBQUM3QixvQkFBb0Isa0RBQVM7QUFDN0Isb0JBQW9CLGtEQUFTO0FBQzdCO0FBQ0Esb0JBQW9CLGtEQUFTO0FBQzdCO0FBQ0E7QUFDQSxvQkFBb0Isa0RBQVM7QUFDN0Isb0JBQW9CLGtEQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsb0RBQVc7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsb0RBQVc7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxvREFBVztBQUM1QztBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsZ0NBQWdDLDZEQUFnQjtBQUNoRDtBQUNBLDhCQUE4QixvREFBVztBQUN6QztBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsNkRBQWdCO0FBQ3hEO0FBQ0Esc0NBQXNDLG9EQUFXO0FBQ2pELDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUyxHQUFHO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvREFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvc2hlcmlmZi9EZXNrdG9wL2JpdGNhc2gtYXBwcy9tYXN0ZXJib3RzL25vZGVfbW9kdWxlcy9ncmFwaHFsLXdzL2xpYi9jbGllbnQubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICpcbiAqIGNsaWVudFxuICpcbiAqL1xudmFyIF9fYXdhaXQgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXQpIHx8IGZ1bmN0aW9uICh2KSB7IHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpOyB9XG52YXIgX19hc3luY0dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19hc3luY0dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcbiAgICByZXR1cm4gaSA9IE9iamVjdC5jcmVhdGUoKHR5cGVvZiBBc3luY0l0ZXJhdG9yID09PSBcImZ1bmN0aW9uXCIgPyBBc3luY0l0ZXJhdG9yIDogT2JqZWN0KS5wcm90b3R5cGUpLCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIsIGF3YWl0UmV0dXJuKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xuICAgIGZ1bmN0aW9uIGF3YWl0UmV0dXJuKGYpIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUodikudGhlbihmLCByZWplY3QpOyB9OyB9XG4gICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlmIChnW25dKSB7IGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IGlmIChmKSBpW25dID0gZihpW25dKTsgfSB9XG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxufTtcbmltcG9ydCB7IENsb3NlQ29kZSwgR1JBUEhRTF9UUkFOU1BPUlRfV1NfUFJPVE9DT0wsIE1lc3NhZ2VUeXBlLCBwYXJzZU1lc3NhZ2UsIHN0cmluZ2lmeU1lc3NhZ2UsIH0gZnJvbSAnLi9jb21tb24ubWpzJztcbmltcG9ydCB7IGlzT2JqZWN0LCBsaW1pdENsb3NlUmVhc29uIH0gZnJvbSAnLi91dGlscy5tanMnO1xuLyoqIFRoaXMgZmlsZSBpcyB0aGUgZW50cnkgcG9pbnQgZm9yIGJyb3dzZXJzLCByZS1leHBvcnQgY29tbW9uIGVsZW1lbnRzLiAqL1xuZXhwb3J0ICogZnJvbSAnLi9jb21tb24ubWpzJztcbi8qKlxuICogQ3JlYXRlcyBhIGRpc3Bvc2FibGUgR3JhcGhRTCBvdmVyIFdlYlNvY2tldCBjbGllbnQuXG4gKlxuICogQGNhdGVnb3J5IENsaWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ2xpZW50KG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHVybCwgY29ubmVjdGlvblBhcmFtcywgbGF6eSA9IHRydWUsIG9uTm9uTGF6eUVycm9yID0gY29uc29sZS5lcnJvciwgbGF6eUNsb3NlVGltZW91dDogbGF6eUNsb3NlVGltZW91dE1zID0gMCwga2VlcEFsaXZlID0gMCwgZGlzYWJsZVBvbmcsIGNvbm5lY3Rpb25BY2tXYWl0VGltZW91dCA9IDAsIHJldHJ5QXR0ZW1wdHMgPSA1LCByZXRyeVdhaXQgPSBhc3luYyBmdW5jdGlvbiByYW5kb21pc2VkRXhwb25lbnRpYWxCYWNrb2ZmKHJldHJpZXMpIHtcbiAgICAgICAgbGV0IHJldHJ5RGVsYXkgPSAxMDAwOyAvLyBzdGFydCB3aXRoIDFzIGRlbGF5XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmV0cmllczsgaSsrKSB7XG4gICAgICAgICAgICByZXRyeURlbGF5ICo9IDI7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgcmV0cnlEZWxheSArXG4gICAgICAgICAgICAvLyBhZGQgcmFuZG9tIHRpbWVvdXQgZnJvbSAzMDBtcyB0byAzc1xuICAgICAgICAgICAgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKDMwMDAgLSAzMDApICsgMzAwKSkpO1xuICAgIH0sIHNob3VsZFJldHJ5ID0gaXNMaWtlQ2xvc2VFdmVudCwgaXNGYXRhbENvbm5lY3Rpb25Qcm9ibGVtLCBvbiwgd2ViU29ja2V0SW1wbCwgXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgdjQgVVVJRCB0byBiZSB1c2VkIGFzIHRoZSBJRCB1c2luZyBgTWF0aGBcbiAgICAgKiBhcyB0aGUgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IuIFN1cHBseSB5b3VyIG93biBnZW5lcmF0b3JcbiAgICAgKiBpbiBjYXNlIHlvdSBuZWVkIG1vcmUgdW5pcXVlbmVzcy5cbiAgICAgKlxuICAgICAqIFJlZmVyZW5jZTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vamVkLzk4Mjg4M1xuICAgICAqL1xuICAgIGdlbmVyYXRlSUQgPSBmdW5jdGlvbiBnZW5lcmF0ZVVVSUQoKSB7XG4gICAgICAgIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIChjKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByID0gKE1hdGgucmFuZG9tKCkgKiAxNikgfCAwLCB2ID0gYyA9PSAneCcgPyByIDogKHIgJiAweDMpIHwgMHg4O1xuICAgICAgICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuICAgICAgICB9KTtcbiAgICB9LCBqc29uTWVzc2FnZVJlcGxhY2VyOiByZXBsYWNlciwganNvbk1lc3NhZ2VSZXZpdmVyOiByZXZpdmVyLCB9ID0gb3B0aW9ucztcbiAgICBsZXQgd3M7XG4gICAgaWYgKHdlYlNvY2tldEltcGwpIHtcbiAgICAgICAgaWYgKCFpc1dlYlNvY2tldCh3ZWJTb2NrZXRJbXBsKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFdlYlNvY2tldCBpbXBsZW1lbnRhdGlvbiBwcm92aWRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHdzID0gd2ViU29ja2V0SW1wbDtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIFdlYlNvY2tldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgd3MgPSBXZWJTb2NrZXQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHdzID1cbiAgICAgICAgICAgIGdsb2JhbC5XZWJTb2NrZXQgfHxcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBTdXBwb3J0IG1vcmUgYnJvd3NlcnNcbiAgICAgICAgICAgICAgICBnbG9iYWwuTW96V2ViU29ja2V0O1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB3cyA9XG4gICAgICAgICAgICB3aW5kb3cuV2ViU29ja2V0IHx8XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogU3VwcG9ydCBtb3JlIGJyb3dzZXJzXG4gICAgICAgICAgICAgICAgd2luZG93Lk1veldlYlNvY2tldDtcbiAgICB9XG4gICAgaWYgKCF3cylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2ViU29ja2V0IGltcGxlbWVudGF0aW9uIG1pc3Npbmc7IG9uIE5vZGUgeW91IGNhbiBgaW1wb3J0IFdlYlNvY2tldCBmcm9tICd3cyc7YCBhbmQgcGFzcyBgd2ViU29ja2V0SW1wbDogV2ViU29ja2V0YCB0byBgY3JlYXRlQ2xpZW50YFwiKTtcbiAgICBjb25zdCBXZWJTb2NrZXRJbXBsID0gd3M7XG4gICAgLy8gd2Vic29ja2V0IHN0YXR1cyBlbWl0dGVyLCBzdWJzY3JpcHRpb25zIGFyZSBoYW5kbGVkIGRpZmZlcmVudGx5XG4gICAgY29uc3QgZW1pdHRlciA9ICgoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXJzID0ge307XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG9uKGlkLCBsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnNbaWRdID0gbGlzdGVuZXI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgbGlzdGVuZXJzW2lkXTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVtaXQobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIGlmICgnaWQnIGluIG1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAoX2EgPSBsaXN0ZW5lcnNbbWVzc2FnZS5pZF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGxpc3RlbmVycywgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKCk7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHtcbiAgICAgICAgICAgIGNvbm5lY3Rpbmc6IChvbiA9PT0gbnVsbCB8fCBvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb24uY29ubmVjdGluZykgPyBbb24uY29ubmVjdGluZ10gOiBbXSxcbiAgICAgICAgICAgIG9wZW5lZDogKG9uID09PSBudWxsIHx8IG9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbi5vcGVuZWQpID8gW29uLm9wZW5lZF0gOiBbXSxcbiAgICAgICAgICAgIGNvbm5lY3RlZDogKG9uID09PSBudWxsIHx8IG9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbi5jb25uZWN0ZWQpID8gW29uLmNvbm5lY3RlZF0gOiBbXSxcbiAgICAgICAgICAgIHBpbmc6IChvbiA9PT0gbnVsbCB8fCBvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb24ucGluZykgPyBbb24ucGluZ10gOiBbXSxcbiAgICAgICAgICAgIHBvbmc6IChvbiA9PT0gbnVsbCB8fCBvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb24ucG9uZykgPyBbb24ucG9uZ10gOiBbXSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IChvbiA9PT0gbnVsbCB8fCBvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb24ubWVzc2FnZSkgPyBbbWVzc2FnZS5lbWl0LCBvbi5tZXNzYWdlXSA6IFttZXNzYWdlLmVtaXRdLFxuICAgICAgICAgICAgY2xvc2VkOiAob24gPT09IG51bGwgfHwgb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uLmNsb3NlZCkgPyBbb24uY2xvc2VkXSA6IFtdLFxuICAgICAgICAgICAgZXJyb3I6IChvbiA9PT0gbnVsbCB8fCBvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb24uZXJyb3IpID8gW29uLmVycm9yXSA6IFtdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb25NZXNzYWdlOiBtZXNzYWdlLm9uLFxuICAgICAgICAgICAgb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbCA9IGxpc3RlbmVyc1tldmVudF07XG4gICAgICAgICAgICAgICAgbC5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsLnNwbGljZShsLmluZGV4T2YobGlzdGVuZXIpLCAxKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVtaXQoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBjb3B5IHRoZSBsaXN0ZW5lcnMgc28gdGhhdCB1bmxpc3RlbnMgZG9udCBcInB1bGwgdGhlIHJ1ZyB1bmRlciBvdXIgZmVldFwiXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiBbLi4ubGlzdGVuZXJzW2V2ZW50XV0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogVGhlIGFyZ3Mgc2hvdWxkIGZpdFxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lciguLi5hcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0pKCk7XG4gICAgLy8gaW52b2tlcyB0aGUgY2FsbGJhY2sgZWl0aGVyIHdoZW4gYW4gZXJyb3Igb3IgY2xvc2VkIGV2ZW50IGlzIGVtaXR0ZWQsXG4gICAgLy8gZmlyc3Qgb25lIHRoYXQgZ2V0cyBjYWxsZWQgcHJldmFpbHMsIG90aGVyIGVtaXNzaW9ucyBhcmUgaWdub3JlZFxuICAgIGZ1bmN0aW9uIGVycm9yT3JDbG9zZWQoY2IpIHtcbiAgICAgICAgY29uc3QgbGlzdGVuaW5nID0gW1xuICAgICAgICAgICAgLy8gZXJyb3JzIGFyZSBmYXRhbCBhbmQgbW9yZSBjcml0aWNhbCB0aGFuIGNsb3NlIGV2ZW50cywgdGhyb3cgdGhlbSBmaXJzdFxuICAgICAgICAgICAgZW1pdHRlci5vbignZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgbGlzdGVuaW5nLmZvckVhY2goKHVubGlzdGVuKSA9PiB1bmxpc3RlbigpKTtcbiAgICAgICAgICAgICAgICBjYihlcnIpO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAvLyBjbG9zZXMgY2FuIGJlIGdyYWNlZnVsIGFuZCBub3QgZmF0YWwsIHRocm93IHRoZW0gc2Vjb25kIChpZiBlcnJvciBkaWRudCB0aHJvdylcbiAgICAgICAgICAgIGVtaXR0ZXIub24oJ2Nsb3NlZCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGxpc3RlbmluZy5mb3JFYWNoKCh1bmxpc3RlbikgPT4gdW5saXN0ZW4oKSk7XG4gICAgICAgICAgICAgICAgY2IoZXZlbnQpO1xuICAgICAgICAgICAgfSksXG4gICAgICAgIF07XG4gICAgfVxuICAgIGxldCBjb25uZWN0aW5nLCBsb2NrcyA9IDAsIGxhenlDbG9zZVRpbWVvdXQsIHJldHJ5aW5nID0gZmFsc2UsIHJldHJpZXMgPSAwLCBkaXNwb3NlZCA9IGZhbHNlO1xuICAgIGFzeW5jIGZ1bmN0aW9uIGNvbm5lY3QoKSB7XG4gICAgICAgIC8vIGNsZWFyIHRoZSBsYXp5IGNsb3NlIHRpbWVvdXQgaW1tZWRpYXRlbGx5IHNvIHRoYXQgY2xvc2UgZ2V0cyBkZWJvdW5jZWRcbiAgICAgICAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vZW5pc2RlbmpvL2dyYXBocWwtd3MvaXNzdWVzLzM4OFxuICAgICAgICBjbGVhclRpbWVvdXQobGF6eUNsb3NlVGltZW91dCk7XG4gICAgICAgIGNvbnN0IFtzb2NrZXQsIHRocm93T25DbG9zZV0gPSBhd2FpdCAoY29ubmVjdGluZyAhPT0gbnVsbCAmJiBjb25uZWN0aW5nICE9PSB2b2lkIDAgPyBjb25uZWN0aW5nIDogKGNvbm5lY3RpbmcgPSBuZXcgUHJvbWlzZSgoY29ubmVjdGVkLCBkZW5pZWQpID0+IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAocmV0cnlpbmcpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCByZXRyeVdhaXQocmV0cmllcyk7XG4gICAgICAgICAgICAgICAgLy8gc3Vic2NyaXB0aW9ucyBtaWdodCBjb21wbGV0ZSB3aGlsZSB3YWl0aW5nIGZvciByZXRyeVxuICAgICAgICAgICAgICAgIGlmICghbG9ja3MpIHtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlbmllZCh7IGNvZGU6IDEwMDAsIHJlYXNvbjogJ0FsbCBTdWJzY3JpcHRpb25zIEdvbmUnIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXRyaWVzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ2Nvbm5lY3RpbmcnLCByZXRyeWluZyk7XG4gICAgICAgICAgICBjb25zdCBzb2NrZXQgPSBuZXcgV2ViU29ja2V0SW1wbCh0eXBlb2YgdXJsID09PSAnZnVuY3Rpb24nID8gYXdhaXQgdXJsKCkgOiB1cmwsIEdSQVBIUUxfVFJBTlNQT1JUX1dTX1BST1RPQ09MKTtcbiAgICAgICAgICAgIGxldCBjb25uZWN0aW9uQWNrVGltZW91dCwgcXVldWVkUGluZztcbiAgICAgICAgICAgIGZ1bmN0aW9uIGVucXVldWVQaW5nKCkge1xuICAgICAgICAgICAgICAgIGlmIChpc0Zpbml0ZShrZWVwQWxpdmUpICYmIGtlZXBBbGl2ZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHF1ZXVlZFBpbmcpOyAvLyBpbiBjYXNlIHdoZXJlIGEgcG9uZyB3YXMgcmVjZWl2ZWQgYmVmb3JlIGEgcGluZyAodGhpcyBpcyB2YWxpZCBiZWhhdmlvdXIpXG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlZFBpbmcgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzb2NrZXQucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0SW1wbC5PUEVOKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc29ja2V0LnNlbmQoc3RyaW5naWZ5TWVzc2FnZSh7IHR5cGU6IE1lc3NhZ2VUeXBlLlBpbmcgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgncGluZycsIGZhbHNlLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBrZWVwQWxpdmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVycm9yT3JDbG9zZWQoKGVyck9yRXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW5nID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChjb25uZWN0aW9uQWNrVGltZW91dCk7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHF1ZXVlZFBpbmcpO1xuICAgICAgICAgICAgICAgIGRlbmllZChlcnJPckV2ZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyT3JFdmVudCBpbnN0YW5jZW9mIFRlcm1pbmF0ZWRDbG9zZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5jbG9zZSg0NDk5LCAnVGVybWluYXRlZCcpOyAvLyBjbG9zZSBldmVudCBpcyBhcnRpZmljaWFsIGFuZCBlbWl0dGVkIG1hbnVhbGx5LCBzZWUgYENsaWVudC50ZXJtaW5hdGUoKWAgYmVsb3dcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0Lm9uZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQub25jbG9zZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzb2NrZXQub25lcnJvciA9IChlcnIpID0+IGVtaXR0ZXIuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgc29ja2V0Lm9uY2xvc2UgPSAoZXZlbnQpID0+IGVtaXR0ZXIuZW1pdCgnY2xvc2VkJywgZXZlbnQpO1xuICAgICAgICAgICAgc29ja2V0Lm9ub3BlbiA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ29wZW5lZCcsIHNvY2tldCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB0eXBlb2YgY29ubmVjdGlvblBhcmFtcyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBhd2FpdCBjb25uZWN0aW9uUGFyYW1zKClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogY29ubmVjdGlvblBhcmFtcztcbiAgICAgICAgICAgICAgICAgICAgLy8gY29ubmVjdGlvblBhcmFtcyBtaWdodCB0YWtlIHRvbyBsb25nIGNhdXNpbmcgdGhlIHNlcnZlciB0byBraWNrIG9mZiB0aGUgY2xpZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBuZWNlc3NhcnkgZXJyb3IvY2xvc2UgZXZlbnQgaXMgYWxyZWFkeSByZXBvcnRlZCAtIHNpbXBseSBzdG9wIGV4ZWN1dGlvblxuICAgICAgICAgICAgICAgICAgICBpZiAoc29ja2V0LnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldEltcGwuT1BFTilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LnNlbmQoc3RyaW5naWZ5TWVzc2FnZShwYXlsb2FkXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5Db25uZWN0aW9uSW5pdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuQ29ubmVjdGlvbkluaXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGF5bG9hZCBpcyBjb21wbGV0ZWx5IGFic2VudCBpZiBub3QgcHJvdmlkZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHJlcGxhY2VyKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Zpbml0ZShjb25uZWN0aW9uQWNrV2FpdFRpbWVvdXQpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uQWNrV2FpdFRpbWVvdXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uQWNrVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldC5jbG9zZShDbG9zZUNvZGUuQ29ubmVjdGlvbkFja25vd2xlZGdlbWVudFRpbWVvdXQsICdDb25uZWN0aW9uIGFja25vd2xlZGdlbWVudCB0aW1lb3V0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBjb25uZWN0aW9uQWNrV2FpdFRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVucXVldWVQaW5nKCk7IC8vIGVucXVldWUgcGluZyAobm9vcCBpZiBkaXNhYmxlZClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LmNsb3NlKENsb3NlQ29kZS5JbnRlcm5hbENsaWVudEVycm9yLCBsaW1pdENsb3NlUmVhc29uKGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiBuZXcgRXJyb3IoZXJyKS5tZXNzYWdlLCAnSW50ZXJuYWwgY2xpZW50IGVycm9yJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgYWNrbm93bGVkZ2VkID0gZmFsc2U7XG4gICAgICAgICAgICBzb2NrZXQub25tZXNzYWdlID0gKHsgZGF0YSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IHBhcnNlTWVzc2FnZShkYXRhLCByZXZpdmVyKTtcbiAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLnR5cGUgPT09ICdwaW5nJyB8fCBtZXNzYWdlLnR5cGUgPT09ICdwb25nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KG1lc3NhZ2UudHlwZSwgdHJ1ZSwgbWVzc2FnZS5wYXlsb2FkKTsgLy8gcmVjZWl2ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLnR5cGUgPT09ICdwb25nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVucXVldWVQaW5nKCk7IC8vIGVucXVldWUgbmV4dCBwaW5nIChub29wIGlmIGRpc2FibGVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWRpc2FibGVQb25nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVzcG9uZCB3aXRoIHBvbmcgb24gcGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldC5zZW5kKHN0cmluZ2lmeU1lc3NhZ2UobWVzc2FnZS5wYXlsb2FkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuUG9uZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IG1lc3NhZ2UucGF5bG9hZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLlBvbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwYXlsb2FkIGlzIGNvbXBsZXRlbHkgYWJzZW50IGlmIG5vdCBwcm92aWRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdwb25nJywgZmFsc2UsIG1lc3NhZ2UucGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIHBpbmcgYW5kIHBvbmdzIGNhbiBiZSByZWNlaXZlZCB3aGVuZXZlclxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY2tub3dsZWRnZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIGFscmVhZHkgY29ubmVjdGVkIGFuZCBhY2tub3dsZWRnZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPT0gTWVzc2FnZVR5cGUuQ29ubmVjdGlvbkFjaylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmlyc3QgbWVzc2FnZSBjYW5ub3QgYmUgb2YgdHlwZSAke21lc3NhZ2UudHlwZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGNvbm5lY3Rpb25BY2tUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgYWNrbm93bGVkZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdjb25uZWN0ZWQnLCBzb2NrZXQsIG1lc3NhZ2UucGF5bG9hZCwgcmV0cnlpbmcpOyAvLyBjb25uZWN0ZWQgPSBzb2NrZXQgb3BlbmVkICsgYWNrbm93bGVkZ2VkXG4gICAgICAgICAgICAgICAgICAgIHJldHJ5aW5nID0gZmFsc2U7IC8vIGZ1dHVyZSBsYXp5IGNvbm5lY3RzIGFyZSBub3QgcmV0cmllc1xuICAgICAgICAgICAgICAgICAgICByZXRyaWVzID0gMDsgLy8gcmVzZXQgdGhlIHJldHJpZXMgb24gY29ubmVjdFxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0ZWQoW1xuICAgICAgICAgICAgICAgICAgICAgICAgc29ja2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4gZXJyb3JPckNsb3NlZChyZWplY3QpKSxcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0Lm9ubWVzc2FnZSA9IG51bGw7IC8vIHN0b3AgcmVhZGluZyBtZXNzYWdlcyBhcyBzb29uIGFzIHJlYWRpbmcgYnJlYWtzIG9uY2VcbiAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5jbG9zZShDbG9zZUNvZGUuQmFkUmVzcG9uc2UsIGxpbWl0Q2xvc2VSZWFzb24oZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6IG5ldyBFcnJvcihlcnIpLm1lc3NhZ2UsICdCYWQgcmVzcG9uc2UnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkoKSkpKTtcbiAgICAgICAgLy8gaWYgdGhlIHByb3ZpZGVkIHNvY2tldCBpcyBpbiBhIGNsb3Npbmcgc3RhdGUsIHdhaXQgZm9yIHRoZSB0aHJvdyBvbiBjbG9zZVxuICAgICAgICBpZiAoc29ja2V0LnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldEltcGwuQ0xPU0lORylcbiAgICAgICAgICAgIGF3YWl0IHRocm93T25DbG9zZTtcbiAgICAgICAgbGV0IHJlbGVhc2UgPSAoKSA9PiB7XG4gICAgICAgICAgICAvLyByZWxlYXNlcyB0aGlzIGNvbm5lY3Rpb25cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVsZWFzZWQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gKHJlbGVhc2UgPSByZXNvbHZlKSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBzb2NrZXQsXG4gICAgICAgICAgICByZWxlYXNlLFxuICAgICAgICAgICAgUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgICAgICAgICAvLyB3YWl0IGZvclxuICAgICAgICAgICAgICAgIHJlbGVhc2VkLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWxvY2tzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgaWYgbm8gbW9yZSBsb2NrcyBhcmUgcHJlc2VudCwgY29tcGxldGUgdGhlIGNvbm5lY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4gc29ja2V0LmNsb3NlKDEwMDAsICdOb3JtYWwgQ2xvc3VyZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRmluaXRlKGxhenlDbG9zZVRpbWVvdXRNcykgJiYgbGF6eUNsb3NlVGltZW91dE1zID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBrZWVwYWxpdmUgaXMgc2V0LCBhbGxvdyBmb3IgdGhlIHNwZWNpZmllZCBjYWxtZG93biB0aW1lIGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZW4gY29tcGxldGUgaWYgdGhlIHNvY2tldCBpcyBzdGlsbCBvcGVuLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhenlDbG9zZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvY2tldC5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXRJbXBsLk9QRU4pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGxhenlDbG9zZVRpbWVvdXRNcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgY29tcGxldGUgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgLy8gb3JcbiAgICAgICAgICAgICAgICB0aHJvd09uQ2xvc2UsXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHRoZSBgY29ubmVjdGAgcHJvYmxlbSBhbmQgZXZhbHVhdGVzIGlmIHRoZSBjbGllbnQgc2hvdWxkIHJldHJ5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNob3VsZFJldHJ5Q29ubmVjdE9yVGhyb3coZXJyT3JDbG9zZUV2ZW50KSB7XG4gICAgICAgIC8vIHNvbWUgY2xvc2UgY29kZXMgYXJlIHdvcnRoIHJlcG9ydGluZyBpbW1lZGlhdGVseVxuICAgICAgICBpZiAoaXNMaWtlQ2xvc2VFdmVudChlcnJPckNsb3NlRXZlbnQpICYmXG4gICAgICAgICAgICAoaXNGYXRhbEludGVybmFsQ2xvc2VDb2RlKGVyck9yQ2xvc2VFdmVudC5jb2RlKSB8fFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgQ2xvc2VDb2RlLkludGVybmFsU2VydmVyRXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIENsb3NlQ29kZS5JbnRlcm5hbENsaWVudEVycm9yLFxuICAgICAgICAgICAgICAgICAgICBDbG9zZUNvZGUuQmFkUmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgQ2xvc2VDb2RlLkJhZFJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICBDbG9zZUNvZGUuVW5hdXRob3JpemVkLFxuICAgICAgICAgICAgICAgICAgICAvLyBDbG9zZUNvZGUuRm9yYmlkZGVuLCBtaWdodCBncmFudCBhY2Nlc3Mgb3V0IGFmdGVyIHJldHJ5XG4gICAgICAgICAgICAgICAgICAgIENsb3NlQ29kZS5TdWJwcm90b2NvbE5vdEFjY2VwdGFibGUsXG4gICAgICAgICAgICAgICAgICAgIC8vIENsb3NlQ29kZS5Db25uZWN0aW9uSW5pdGlhbGlzYXRpb25UaW1lb3V0LCBtaWdodCBub3QgdGltZSBvdXQgYWZ0ZXIgcmV0cnlcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2xvc2VDb2RlLkNvbm5lY3Rpb25BY2tub3dsZWRnZW1lbnRUaW1lb3V0LCBtaWdodCBub3QgdGltZSBvdXQgYWZ0ZXIgcmV0cnlcbiAgICAgICAgICAgICAgICAgICAgQ2xvc2VDb2RlLlN1YnNjcmliZXJBbHJlYWR5RXhpc3RzLFxuICAgICAgICAgICAgICAgICAgICBDbG9zZUNvZGUuVG9vTWFueUluaXRpYWxpc2F0aW9uUmVxdWVzdHMsXG4gICAgICAgICAgICAgICAgICAgIC8vIDQ0OTksIC8vIFRlcm1pbmF0ZWQsIHByb2JhYmx5IGJlY2F1c2UgdGhlIHNvY2tldCBmcm96ZSwgd2Ugd2FudCB0byByZXRyeVxuICAgICAgICAgICAgICAgIF0uaW5jbHVkZXMoZXJyT3JDbG9zZUV2ZW50LmNvZGUpKSlcbiAgICAgICAgICAgIHRocm93IGVyck9yQ2xvc2VFdmVudDtcbiAgICAgICAgLy8gY2xpZW50IHdhcyBkaXNwb3NlZCwgbm8gcmV0cmllcyBzaG91bGQgcHJvY2VlZCByZWdhcmRsZXNzXG4gICAgICAgIGlmIChkaXNwb3NlZClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gbm9ybWFsIGNsb3N1cmUgKHBvc3NpYmx5IGFsbCBzdWJzY3JpcHRpb25zIGhhdmUgY29tcGxldGVkKVxuICAgICAgICAvLyBpZiBubyBsb2NrcyB3ZXJlIGFjcXVpcmVkIGluIHRoZSBtZWFudGltZSwgc2hvdWxkbnQgdHJ5IGFnYWluXG4gICAgICAgIGlmIChpc0xpa2VDbG9zZUV2ZW50KGVyck9yQ2xvc2VFdmVudCkgJiYgZXJyT3JDbG9zZUV2ZW50LmNvZGUgPT09IDEwMDApXG4gICAgICAgICAgICByZXR1cm4gbG9ja3MgPiAwO1xuICAgICAgICAvLyByZXRyaWVzIGFyZSBub3QgYWxsb3dlZCBvciB3ZSB0cmllZCB0byBtYW55IHRpbWVzLCByZXBvcnQgZXJyb3JcbiAgICAgICAgaWYgKCFyZXRyeUF0dGVtcHRzIHx8IHJldHJpZXMgPj0gcmV0cnlBdHRlbXB0cylcbiAgICAgICAgICAgIHRocm93IGVyck9yQ2xvc2VFdmVudDtcbiAgICAgICAgLy8gdGhyb3cgbm9uLXJldHJ5YWJsZSBjb25uZWN0aW9uIHByb2JsZW1zXG4gICAgICAgIGlmICghc2hvdWxkUmV0cnkoZXJyT3JDbG9zZUV2ZW50KSlcbiAgICAgICAgICAgIHRocm93IGVyck9yQ2xvc2VFdmVudDtcbiAgICAgICAgLy8gQGRlcHJlY2F0ZWQgdGhyb3cgZmF0YWwgY29ubmVjdGlvbiBwcm9ibGVtcyBpbW1lZGlhdGVseVxuICAgICAgICBpZiAoaXNGYXRhbENvbm5lY3Rpb25Qcm9ibGVtID09PSBudWxsIHx8IGlzRmF0YWxDb25uZWN0aW9uUHJvYmxlbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaXNGYXRhbENvbm5lY3Rpb25Qcm9ibGVtKGVyck9yQ2xvc2VFdmVudCkpXG4gICAgICAgICAgICB0aHJvdyBlcnJPckNsb3NlRXZlbnQ7XG4gICAgICAgIC8vIGxvb2tzIGdvb2QsIHN0YXJ0IHJldHJ5aW5nXG4gICAgICAgIHJldHVybiAocmV0cnlpbmcgPSB0cnVlKTtcbiAgICB9XG4gICAgLy8gaW4gbm9uLWxhenkgKGhvdD8pIG1vZGUgYWx3YXlzIGhvbGQgb25lIGNvbm5lY3Rpb24gbG9jayB0byBwZXJzaXN0IHRoZSBzb2NrZXRcbiAgICBpZiAoIWxhenkpIHtcbiAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGxvY2tzKys7XG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgWywgLCB0aHJvd09uQ2xvc2VdID0gYXdhaXQgY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aHJvd09uQ2xvc2U7IC8vIHdpbGwgYWx3YXlzIHRocm93IGJlY2F1c2UgcmVsZWFzZXIgaXMgbm90IHVzZWRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVyck9yQ2xvc2VFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzaG91bGRSZXRyeUNvbm5lY3RPclRocm93KGVyck9yQ2xvc2VFdmVudCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJPckNsb3NlRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlcG9ydCB0aHJvd24gZXJyb3IsIG5vIGZ1cnRoZXIgcmV0cmllc1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9uTm9uTGF6eUVycm9yID09PSBudWxsIHx8IG9uTm9uTGF6eUVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbk5vbkxhenlFcnJvcihlcnJPckNsb3NlRXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdWJzY3JpYmUocGF5bG9hZCwgc2luaykge1xuICAgICAgICBjb25zdCBpZCA9IGdlbmVyYXRlSUQocGF5bG9hZCk7XG4gICAgICAgIGxldCBkb25lID0gZmFsc2UsIGVycm9yZWQgPSBmYWxzZSwgcmVsZWFzZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICAvLyBmb3IgaGFuZGxpbmcgY29tcGxldGlvbnMgYmVmb3JlIGNvbm5lY3RcbiAgICAgICAgICAgIGxvY2tzLS07XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGxvY2tzKys7XG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW3NvY2tldCwgcmVsZWFzZSwgd2FpdEZvclJlbGVhc2VPclRocm93T25DbG9zZV0gPSBhd2FpdCBjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGRvbmUgd2hpbGUgd2FpdGluZyBmb3IgY29ubmVjdCwgcmVsZWFzZSB0aGUgY29ubmVjdGlvbiBsb2NrIHJpZ2h0IGF3YXlcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVsZWFzZSgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1bmxpc3RlbiA9IGVtaXR0ZXIub25NZXNzYWdlKGlkLCAobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChtZXNzYWdlLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLk5leHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgLS0gcGF5bG9hZCB3aWxsIGZpdCB0eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpbmsubmV4dChtZXNzYWdlLnBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuRXJyb3I6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGVycm9yZWQgPSB0cnVlKSwgKGRvbmUgPSB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2luay5lcnJvcihtZXNzYWdlLnBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxlYXNlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuQ29tcGxldGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbGVhc2VyKCk7IC8vIHJlbGVhc2UgY29tcGxldGVzIHRoZSBzaW5rXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQuc2VuZChzdHJpbmdpZnlNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuU3Vic2NyaWJlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgICAgICAgICAgICAgfSwgcmVwbGFjZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVsZWFzZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRvbmUgJiYgc29ja2V0LnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldEltcGwuT1BFTilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBub3QgY29tcGxldGVkIGFscmVhZHkgYW5kIHNvY2tldCBpcyBvcGVuLCBzZW5kIGNvbXBsZXRlIG1lc3NhZ2UgdG8gc2VydmVyIG9uIHJlbGVhc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQuc2VuZChzdHJpbmdpZnlNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLkNvbXBsZXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHJlcGxhY2VyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2Nrcy0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWxlYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIC8vIGVpdGhlciB0aGUgcmVsZWFzZXIgd2lsbCBiZSBjYWxsZWQsIGNvbm5lY3Rpb24gY29tcGxldGVkIGFuZFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgcHJvbWlzZSByZXNvbHZlZCBvciB0aGUgc29ja2V0IGNsb3NlZCBhbmQgdGhlIHByb21pc2UgcmVqZWN0ZWQuXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoYXRldmVyIGhhcHBlbnMgdGhvdWdoLCB3ZSB3YW50IHRvIHN0b3AgbGlzdGVuaW5nIGZvciBtZXNzYWdlc1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB3YWl0Rm9yUmVsZWFzZU9yVGhyb3dPbkNsb3NlLmZpbmFsbHkodW5saXN0ZW4pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIGNvbXBsZXRlZCwgc2hvdWxkbnQgdHJ5IGFnYWluXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJPckNsb3NlRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzaG91bGRSZXRyeUNvbm5lY3RPclRocm93KGVyck9yQ2xvc2VFdmVudCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAvLyBkZWxpdmVyaW5nIGVpdGhlciBhbiBlcnJvciBvciBhIGNvbXBsZXRlIHRlcm1pbmF0ZXMgdGhlIHNlcXVlbmNlXG4gICAgICAgICAgICBpZiAoIWVycm9yZWQpXG4gICAgICAgICAgICAgICAgc2luay5jb21wbGV0ZSgpO1xuICAgICAgICB9KSAvLyByZXNvbHZlcyBvbiByZWxlYXNlIG9yIG5vcm1hbCBjbG9zdXJlXG4gICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgc2luay5lcnJvcihlcnIpO1xuICAgICAgICB9KTsgLy8gcmVqZWN0cyBvbiBjbG9zZSBldmVudHMgYW5kIGVycm9yc1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgLy8gZGlzcG9zZSBvbmx5IG9mIGFjdGl2ZSBzdWJzY3JpcHRpb25zXG4gICAgICAgICAgICBpZiAoIWRvbmUpXG4gICAgICAgICAgICAgICAgcmVsZWFzZXIoKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgb246IGVtaXR0ZXIub24sXG4gICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgaXRlcmF0ZShyZXF1ZXN0KSB7XG4gICAgICAgICAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgICAgICAgICBjb25zdCBkZWZlcnJlZCA9IHtcbiAgICAgICAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgICByZXNvbHZlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vb3BcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGRpc3Bvc2UgPSBzdWJzY3JpYmUocmVxdWVzdCwge1xuICAgICAgICAgICAgICAgIG5leHQodmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55IC0tIHBheWxvYWQgd2lsbCBmaXQgdHlwZVxuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nLnB1c2godmFsKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXJyb3IoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLmRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5lcnJvciA9IGVycjtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY29tcGxldGUoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLmRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgaXRlcmF0b3IgPSAoZnVuY3Rpb24gaXRlcmF0b3IoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogaXRlcmF0b3JfMSgpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwZW5kaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgd2FpdCBpZiB0aGVyZSBhcmUgbm8gcGVuZGluZyBtZXNzYWdlcyBhdmFpbGFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCBfX2F3YWl0KG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiAoZGVmZXJyZWQucmVzb2x2ZSA9IHJlc29sdmUpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmaXJzdCBmbHVzaFxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHBlbmRpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KHBlbmRpbmcuc2hpZnQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGVuIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVmZXJyZWQuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBkZWZlcnJlZC5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9yIGNvbXBsZXRlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVmZXJyZWQuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCBfX2F3YWl0KHZvaWQgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICBpdGVyYXRvci50aHJvdyA9IGFzeW5jIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWRlZmVycmVkLmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLmVycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpdGVyYXRvci5yZXR1cm4gPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gaXRlcmF0b3I7XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIGRpc3Bvc2UoKSB7XG4gICAgICAgICAgICBkaXNwb3NlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoY29ubmVjdGluZykge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgY29ubmVjdGlvbiwgY2xvc2UgaXRcbiAgICAgICAgICAgICAgICBjb25zdCBbc29ja2V0XSA9IGF3YWl0IGNvbm5lY3Rpbmc7XG4gICAgICAgICAgICAgICAgc29ja2V0LmNsb3NlKDEwMDAsICdOb3JtYWwgQ2xvc3VyZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0ZXJtaW5hdGUoKSB7XG4gICAgICAgICAgICBpZiAoY29ubmVjdGluZykge1xuICAgICAgICAgICAgICAgIC8vIG9ubHkgaWYgdGhlcmUgaXMgYSBjb25uZWN0aW9uXG4gICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdjbG9zZWQnLCBuZXcgVGVybWluYXRlZENsb3NlRXZlbnQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogQSBzeW50aGV0aWMgY2xvc2UgZXZlbnQgYDQ0OTk6IFRlcm1pbmF0ZWRgIGlzIGlzc3VlZCB0byB0aGUgY3VycmVudCB0byBpbW1lZGlhdGVseVxuICogY2xvc2UgdGhlIGNvbm5lY3Rpb24gd2l0aG91dCB3YWl0aW5nIGZvciB0aGUgb25lIGNvbWluZyBmcm9tIGBXZWJTb2NrZXQub25jbG9zZWAuXG4gKlxuICogVGVybWluYXRpbmcgaXMgbm90IGNvbnNpZGVyZWQgZmF0YWwgYW5kIGEgY29ubmVjdGlvbiByZXRyeSB3aWxsIG9jY3VyIGFzIGV4cGVjdGVkLlxuICpcbiAqIFVzZWZ1bCBpbiBjYXNlcyB3aGVyZSB0aGUgV2ViU29ja2V0IGlzIHN0dWNrIGFuZCBub3QgZW1pdHRpbmcgYW55IGV2ZW50cztcbiAqIGNhbiBoYXBwZW4gb24gaU9TIFNhZmFyaSwgc2VlOiBodHRwczovL2dpdGh1Yi5jb20vZW5pc2RlbmpvL2dyYXBocWwtd3MvZGlzY3Vzc2lvbnMvMjkwLlxuICovXG5leHBvcnQgY2xhc3MgVGVybWluYXRlZENsb3NlRXZlbnQgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdUZXJtaW5hdGVkQ2xvc2VFdmVudCc7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9ICc0NDk5OiBUZXJtaW5hdGVkJztcbiAgICAgICAgdGhpcy5jb2RlID0gNDQ5OTtcbiAgICAgICAgdGhpcy5yZWFzb24gPSAnVGVybWluYXRlZCc7XG4gICAgICAgIHRoaXMud2FzQ2xlYW4gPSBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc0xpa2VDbG9zZUV2ZW50KHZhbCkge1xuICAgIHJldHVybiBpc09iamVjdCh2YWwpICYmICdjb2RlJyBpbiB2YWwgJiYgJ3JlYXNvbicgaW4gdmFsO1xufVxuZnVuY3Rpb24gaXNGYXRhbEludGVybmFsQ2xvc2VDb2RlKGNvZGUpIHtcbiAgICBpZiAoW1xuICAgICAgICAxMDAwLCAvLyBOb3JtYWwgQ2xvc3VyZSBpcyBub3QgYW4gZXJyb25lb3VzIGNsb3NlIGNvZGVcbiAgICAgICAgMTAwMSwgLy8gR29pbmcgQXdheVxuICAgICAgICAxMDA2LCAvLyBBYm5vcm1hbCBDbG9zdXJlXG4gICAgICAgIDEwMDUsIC8vIE5vIFN0YXR1cyBSZWNlaXZlZFxuICAgICAgICAxMDEyLCAvLyBTZXJ2aWNlIFJlc3RhcnRcbiAgICAgICAgMTAxMywgLy8gVHJ5IEFnYWluIExhdGVyXG4gICAgICAgIDEwMTQsIC8vIEJhZCBHYXRld2F5XG4gICAgXS5pbmNsdWRlcyhjb2RlKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIC8vIGFsbCBvdGhlciBpbnRlcm5hbCBlcnJvcnMgYXJlIGZhdGFsXG4gICAgcmV0dXJuIGNvZGUgPj0gMTAwMCAmJiBjb2RlIDw9IDE5OTk7XG59XG5mdW5jdGlvbiBpc1dlYlNvY2tldCh2YWwpIHtcbiAgICByZXR1cm4gKHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgJ2NvbnN0cnVjdG9yJyBpbiB2YWwgJiZcbiAgICAgICAgJ0NMT1NFRCcgaW4gdmFsICYmXG4gICAgICAgICdDTE9TSU5HJyBpbiB2YWwgJiZcbiAgICAgICAgJ0NPTk5FQ1RJTkcnIGluIHZhbCAmJlxuICAgICAgICAnT1BFTicgaW4gdmFsKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/graphql-ws/lib/client.mjs\n",
      );

      /***/
    },

  /***/ "(ssr)/../../node_modules/graphql-ws/lib/common.mjs":
    /*!****************************************************!*\
  !*** ../../node_modules/graphql-ws/lib/common.mjs ***!
  \****************************************************/
    /***/ (
      __unused_webpack___webpack_module__,
      __webpack_exports__,
      __webpack_require__,
    ) => {
      eval(
        '__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CloseCode: () => (/* binding */ CloseCode),\n/* harmony export */   DEPRECATED_GRAPHQL_WS_PROTOCOL: () => (/* binding */ DEPRECATED_GRAPHQL_WS_PROTOCOL),\n/* harmony export */   GRAPHQL_TRANSPORT_WS_PROTOCOL: () => (/* binding */ GRAPHQL_TRANSPORT_WS_PROTOCOL),\n/* harmony export */   MessageType: () => (/* binding */ MessageType),\n/* harmony export */   isMessage: () => (/* binding */ isMessage),\n/* harmony export */   parseMessage: () => (/* binding */ parseMessage),\n/* harmony export */   stringifyMessage: () => (/* binding */ stringifyMessage),\n/* harmony export */   validateMessage: () => (/* binding */ validateMessage)\n/* harmony export */ });\n/* harmony import */ var _utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.mjs */ "(ssr)/../../node_modules/graphql-ws/lib/utils.mjs");\n/**\n *\n * common\n *\n */\n\n/**\n * The WebSocket sub-protocol used for the [GraphQL over WebSocket Protocol](https://github.com/graphql/graphql-over-http/blob/main/rfcs/GraphQLOverWebSocket.md).\n *\n * @category Common\n */\nconst GRAPHQL_TRANSPORT_WS_PROTOCOL = \'graphql-transport-ws\';\n/**\n * The deprecated subprotocol used by [subscriptions-transport-ws](https://github.com/apollographql/subscriptions-transport-ws).\n *\n * @private\n */\nconst DEPRECATED_GRAPHQL_WS_PROTOCOL = \'graphql-ws\';\n/**\n * `graphql-ws` expected and standard close codes of the [GraphQL over WebSocket Protocol](https://github.com/graphql/graphql-over-http/blob/main/rfcs/GraphQLOverWebSocket.md).\n *\n * @category Common\n */\nvar CloseCode;\n(function (CloseCode) {\n    CloseCode[CloseCode["InternalServerError"] = 4500] = "InternalServerError";\n    CloseCode[CloseCode["InternalClientError"] = 4005] = "InternalClientError";\n    CloseCode[CloseCode["BadRequest"] = 4400] = "BadRequest";\n    CloseCode[CloseCode["BadResponse"] = 4004] = "BadResponse";\n    /** Tried subscribing before connect ack */\n    CloseCode[CloseCode["Unauthorized"] = 4401] = "Unauthorized";\n    CloseCode[CloseCode["Forbidden"] = 4403] = "Forbidden";\n    CloseCode[CloseCode["SubprotocolNotAcceptable"] = 4406] = "SubprotocolNotAcceptable";\n    CloseCode[CloseCode["ConnectionInitialisationTimeout"] = 4408] = "ConnectionInitialisationTimeout";\n    CloseCode[CloseCode["ConnectionAcknowledgementTimeout"] = 4504] = "ConnectionAcknowledgementTimeout";\n    /** Subscriber distinction is very important */\n    CloseCode[CloseCode["SubscriberAlreadyExists"] = 4409] = "SubscriberAlreadyExists";\n    CloseCode[CloseCode["TooManyInitialisationRequests"] = 4429] = "TooManyInitialisationRequests";\n})(CloseCode || (CloseCode = {}));\n/**\n * Types of messages allowed to be sent by the client/server over the WS protocol.\n *\n * @category Common\n */\nvar MessageType;\n(function (MessageType) {\n    MessageType["ConnectionInit"] = "connection_init";\n    MessageType["ConnectionAck"] = "connection_ack";\n    MessageType["Ping"] = "ping";\n    MessageType["Pong"] = "pong";\n    MessageType["Subscribe"] = "subscribe";\n    MessageType["Next"] = "next";\n    MessageType["Error"] = "error";\n    MessageType["Complete"] = "complete";\n})(MessageType || (MessageType = {}));\n/**\n * Validates the message against the GraphQL over WebSocket Protocol.\n *\n * Invalid messages will throw descriptive errors.\n *\n * @category Common\n */\nfunction validateMessage(val) {\n    if (!(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(val)) {\n        throw new Error(`Message is expected to be an object, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val)}`);\n    }\n    if (!val.type) {\n        throw new Error(`Message is missing the \'type\' property`);\n    }\n    if (typeof val.type !== \'string\') {\n        throw new Error(`Message is expects the \'type\' property to be a string, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.type)}`);\n    }\n    switch (val.type) {\n        case MessageType.ConnectionInit:\n        case MessageType.ConnectionAck:\n        case MessageType.Ping:\n        case MessageType.Pong: {\n            if (val.payload != null && !(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(val.payload)) {\n                throw new Error(`"${val.type}" message expects the \'payload\' property to be an object or nullish or missing, but got "${val.payload}"`);\n            }\n            break;\n        }\n        case MessageType.Subscribe: {\n            if (typeof val.id !== \'string\') {\n                throw new Error(`"${val.type}" message expects the \'id\' property to be a string, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.id)}`);\n            }\n            if (!val.id) {\n                throw new Error(`"${val.type}" message requires a non-empty \'id\' property`);\n            }\n            if (!(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(val.payload)) {\n                throw new Error(`"${val.type}" message expects the \'payload\' property to be an object, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.payload)}`);\n            }\n            if (typeof val.payload.query !== \'string\') {\n                throw new Error(`"${val.type}" message payload expects the \'query\' property to be a string, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.payload.query)}`);\n            }\n            if (val.payload.variables != null && !(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(val.payload.variables)) {\n                throw new Error(`"${val.type}" message payload expects the \'variables\' property to be a an object or nullish or missing, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.payload.variables)}`);\n            }\n            if (val.payload.operationName != null &&\n                (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.payload.operationName) !== \'string\') {\n                throw new Error(`"${val.type}" message payload expects the \'operationName\' property to be a string or nullish or missing, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.payload.operationName)}`);\n            }\n            if (val.payload.extensions != null && !(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(val.payload.extensions)) {\n                throw new Error(`"${val.type}" message payload expects the \'extensions\' property to be a an object or nullish or missing, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.payload.extensions)}`);\n            }\n            break;\n        }\n        case MessageType.Next: {\n            if (typeof val.id !== \'string\') {\n                throw new Error(`"${val.type}" message expects the \'id\' property to be a string, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.id)}`);\n            }\n            if (!val.id) {\n                throw new Error(`"${val.type}" message requires a non-empty \'id\' property`);\n            }\n            if (!(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(val.payload)) {\n                throw new Error(`"${val.type}" message expects the \'payload\' property to be an object, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.payload)}`);\n            }\n            break;\n        }\n        case MessageType.Error: {\n            if (typeof val.id !== \'string\') {\n                throw new Error(`"${val.type}" message expects the \'id\' property to be a string, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.id)}`);\n            }\n            if (!val.id) {\n                throw new Error(`"${val.type}" message requires a non-empty \'id\' property`);\n            }\n            if (!(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.areGraphQLErrors)(val.payload)) {\n                throw new Error(`"${val.type}" message expects the \'payload\' property to be an array of GraphQL errors, but got ${JSON.stringify(val.payload)}`);\n            }\n            break;\n        }\n        case MessageType.Complete: {\n            if (typeof val.id !== \'string\') {\n                throw new Error(`"${val.type}" message expects the \'id\' property to be a string, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.id)}`);\n            }\n            if (!val.id) {\n                throw new Error(`"${val.type}" message requires a non-empty \'id\' property`);\n            }\n            break;\n        }\n        default:\n            throw new Error(`Invalid message \'type\' property "${val.type}"`);\n    }\n    return val;\n}\n/**\n * Checks if the provided value is a valid GraphQL over WebSocket message.\n *\n * @deprecated Use `validateMessage` instead.\n *\n * @category Common\n */\nfunction isMessage(val) {\n    try {\n        validateMessage(val);\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n}\n/**\n * Parses the raw websocket message data to a valid message.\n *\n * @category Common\n */\nfunction parseMessage(data, reviver) {\n    return validateMessage(typeof data === \'string\' ? JSON.parse(data, reviver) : data);\n}\n/**\n * Stringifies a valid message ready to be sent through the socket.\n *\n * @category Common\n */\nfunction stringifyMessage(msg, replacer) {\n    validateMessage(msg);\n    return JSON.stringify(msg, replacer);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2dyYXBocWwtd3MvbGliL2NvbW1vbi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUN5RTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4QkFBOEI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQ0FBa0M7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFNBQVMsb0RBQVE7QUFDakIsd0VBQXdFLDBEQUFjLE1BQU07QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRiwwREFBYyxXQUFXO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxvREFBUTtBQUNoRCxvQ0FBb0MsU0FBUywyRkFBMkYsWUFBWTtBQUNwSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFNBQVMsOERBQThELDBEQUFjLFNBQVM7QUFDbEk7QUFDQTtBQUNBLG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0EsaUJBQWlCLG9EQUFRO0FBQ3pCLG9DQUFvQyxTQUFTLG9FQUFvRSwwREFBYyxjQUFjO0FBQzdJO0FBQ0E7QUFDQSxvQ0FBb0MsU0FBUyx5RUFBeUUsMERBQWMsb0JBQW9CO0FBQ3hKO0FBQ0Esa0RBQWtELG9EQUFRO0FBQzFELG9DQUFvQyxTQUFTLHNHQUFzRywwREFBYyx3QkFBd0I7QUFDekw7QUFDQTtBQUNBLGdCQUFnQiwwREFBYztBQUM5QixvQ0FBb0MsU0FBUyx1R0FBdUcsMERBQWMsNEJBQTRCO0FBQzlMO0FBQ0EsbURBQW1ELG9EQUFRO0FBQzNELG9DQUFvQyxTQUFTLHVHQUF1RywwREFBYyx5QkFBeUI7QUFDM0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxTQUFTLDhEQUE4RCwwREFBYyxTQUFTO0FBQ2xJO0FBQ0E7QUFDQSxvQ0FBb0MsU0FBUztBQUM3QztBQUNBLGlCQUFpQixvREFBUTtBQUN6QixvQ0FBb0MsU0FBUyxvRUFBb0UsMERBQWMsY0FBYztBQUM3STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFNBQVMsOERBQThELDBEQUFjLFNBQVM7QUFDbEk7QUFDQTtBQUNBLG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0EsaUJBQWlCLDREQUFnQjtBQUNqQyxvQ0FBb0MsU0FBUyxxRkFBcUYsNEJBQTRCO0FBQzlKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsU0FBUyw4REFBOEQsMERBQWMsU0FBUztBQUNsSTtBQUNBO0FBQ0Esb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsU0FBUztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zaGVyaWZmL0Rlc2t0b3AvYml0Y2FzaC1hcHBzL21hc3RlcmJvdHMvbm9kZV9tb2R1bGVzL2dyYXBocWwtd3MvbGliL2NvbW1vbi5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKlxuICogY29tbW9uXG4gKlxuICovXG5pbXBvcnQgeyBhcmVHcmFwaFFMRXJyb3JzLCBleHRlbmRlZFR5cGVvZiwgaXNPYmplY3QgfSBmcm9tICcuL3V0aWxzLm1qcyc7XG4vKipcbiAqIFRoZSBXZWJTb2NrZXQgc3ViLXByb3RvY29sIHVzZWQgZm9yIHRoZSBbR3JhcGhRTCBvdmVyIFdlYlNvY2tldCBQcm90b2NvbF0oaHR0cHM6Ly9naXRodWIuY29tL2dyYXBocWwvZ3JhcGhxbC1vdmVyLWh0dHAvYmxvYi9tYWluL3JmY3MvR3JhcGhRTE92ZXJXZWJTb2NrZXQubWQpLlxuICpcbiAqIEBjYXRlZ29yeSBDb21tb25cbiAqL1xuZXhwb3J0IGNvbnN0IEdSQVBIUUxfVFJBTlNQT1JUX1dTX1BST1RPQ09MID0gJ2dyYXBocWwtdHJhbnNwb3J0LXdzJztcbi8qKlxuICogVGhlIGRlcHJlY2F0ZWQgc3VicHJvdG9jb2wgdXNlZCBieSBbc3Vic2NyaXB0aW9ucy10cmFuc3BvcnQtd3NdKGh0dHBzOi8vZ2l0aHViLmNvbS9hcG9sbG9ncmFwaHFsL3N1YnNjcmlwdGlvbnMtdHJhbnNwb3J0LXdzKS5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgREVQUkVDQVRFRF9HUkFQSFFMX1dTX1BST1RPQ09MID0gJ2dyYXBocWwtd3MnO1xuLyoqXG4gKiBgZ3JhcGhxbC13c2AgZXhwZWN0ZWQgYW5kIHN0YW5kYXJkIGNsb3NlIGNvZGVzIG9mIHRoZSBbR3JhcGhRTCBvdmVyIFdlYlNvY2tldCBQcm90b2NvbF0oaHR0cHM6Ly9naXRodWIuY29tL2dyYXBocWwvZ3JhcGhxbC1vdmVyLWh0dHAvYmxvYi9tYWluL3JmY3MvR3JhcGhRTE92ZXJXZWJTb2NrZXQubWQpLlxuICpcbiAqIEBjYXRlZ29yeSBDb21tb25cbiAqL1xuZXhwb3J0IHZhciBDbG9zZUNvZGU7XG4oZnVuY3Rpb24gKENsb3NlQ29kZSkge1xuICAgIENsb3NlQ29kZVtDbG9zZUNvZGVbXCJJbnRlcm5hbFNlcnZlckVycm9yXCJdID0gNDUwMF0gPSBcIkludGVybmFsU2VydmVyRXJyb3JcIjtcbiAgICBDbG9zZUNvZGVbQ2xvc2VDb2RlW1wiSW50ZXJuYWxDbGllbnRFcnJvclwiXSA9IDQwMDVdID0gXCJJbnRlcm5hbENsaWVudEVycm9yXCI7XG4gICAgQ2xvc2VDb2RlW0Nsb3NlQ29kZVtcIkJhZFJlcXVlc3RcIl0gPSA0NDAwXSA9IFwiQmFkUmVxdWVzdFwiO1xuICAgIENsb3NlQ29kZVtDbG9zZUNvZGVbXCJCYWRSZXNwb25zZVwiXSA9IDQwMDRdID0gXCJCYWRSZXNwb25zZVwiO1xuICAgIC8qKiBUcmllZCBzdWJzY3JpYmluZyBiZWZvcmUgY29ubmVjdCBhY2sgKi9cbiAgICBDbG9zZUNvZGVbQ2xvc2VDb2RlW1wiVW5hdXRob3JpemVkXCJdID0gNDQwMV0gPSBcIlVuYXV0aG9yaXplZFwiO1xuICAgIENsb3NlQ29kZVtDbG9zZUNvZGVbXCJGb3JiaWRkZW5cIl0gPSA0NDAzXSA9IFwiRm9yYmlkZGVuXCI7XG4gICAgQ2xvc2VDb2RlW0Nsb3NlQ29kZVtcIlN1YnByb3RvY29sTm90QWNjZXB0YWJsZVwiXSA9IDQ0MDZdID0gXCJTdWJwcm90b2NvbE5vdEFjY2VwdGFibGVcIjtcbiAgICBDbG9zZUNvZGVbQ2xvc2VDb2RlW1wiQ29ubmVjdGlvbkluaXRpYWxpc2F0aW9uVGltZW91dFwiXSA9IDQ0MDhdID0gXCJDb25uZWN0aW9uSW5pdGlhbGlzYXRpb25UaW1lb3V0XCI7XG4gICAgQ2xvc2VDb2RlW0Nsb3NlQ29kZVtcIkNvbm5lY3Rpb25BY2tub3dsZWRnZW1lbnRUaW1lb3V0XCJdID0gNDUwNF0gPSBcIkNvbm5lY3Rpb25BY2tub3dsZWRnZW1lbnRUaW1lb3V0XCI7XG4gICAgLyoqIFN1YnNjcmliZXIgZGlzdGluY3Rpb24gaXMgdmVyeSBpbXBvcnRhbnQgKi9cbiAgICBDbG9zZUNvZGVbQ2xvc2VDb2RlW1wiU3Vic2NyaWJlckFscmVhZHlFeGlzdHNcIl0gPSA0NDA5XSA9IFwiU3Vic2NyaWJlckFscmVhZHlFeGlzdHNcIjtcbiAgICBDbG9zZUNvZGVbQ2xvc2VDb2RlW1wiVG9vTWFueUluaXRpYWxpc2F0aW9uUmVxdWVzdHNcIl0gPSA0NDI5XSA9IFwiVG9vTWFueUluaXRpYWxpc2F0aW9uUmVxdWVzdHNcIjtcbn0pKENsb3NlQ29kZSB8fCAoQ2xvc2VDb2RlID0ge30pKTtcbi8qKlxuICogVHlwZXMgb2YgbWVzc2FnZXMgYWxsb3dlZCB0byBiZSBzZW50IGJ5IHRoZSBjbGllbnQvc2VydmVyIG92ZXIgdGhlIFdTIHByb3RvY29sLlxuICpcbiAqIEBjYXRlZ29yeSBDb21tb25cbiAqL1xuZXhwb3J0IHZhciBNZXNzYWdlVHlwZTtcbihmdW5jdGlvbiAoTWVzc2FnZVR5cGUpIHtcbiAgICBNZXNzYWdlVHlwZVtcIkNvbm5lY3Rpb25Jbml0XCJdID0gXCJjb25uZWN0aW9uX2luaXRcIjtcbiAgICBNZXNzYWdlVHlwZVtcIkNvbm5lY3Rpb25BY2tcIl0gPSBcImNvbm5lY3Rpb25fYWNrXCI7XG4gICAgTWVzc2FnZVR5cGVbXCJQaW5nXCJdID0gXCJwaW5nXCI7XG4gICAgTWVzc2FnZVR5cGVbXCJQb25nXCJdID0gXCJwb25nXCI7XG4gICAgTWVzc2FnZVR5cGVbXCJTdWJzY3JpYmVcIl0gPSBcInN1YnNjcmliZVwiO1xuICAgIE1lc3NhZ2VUeXBlW1wiTmV4dFwiXSA9IFwibmV4dFwiO1xuICAgIE1lc3NhZ2VUeXBlW1wiRXJyb3JcIl0gPSBcImVycm9yXCI7XG4gICAgTWVzc2FnZVR5cGVbXCJDb21wbGV0ZVwiXSA9IFwiY29tcGxldGVcIjtcbn0pKE1lc3NhZ2VUeXBlIHx8IChNZXNzYWdlVHlwZSA9IHt9KSk7XG4vKipcbiAqIFZhbGlkYXRlcyB0aGUgbWVzc2FnZSBhZ2FpbnN0IHRoZSBHcmFwaFFMIG92ZXIgV2ViU29ja2V0IFByb3RvY29sLlxuICpcbiAqIEludmFsaWQgbWVzc2FnZXMgd2lsbCB0aHJvdyBkZXNjcmlwdGl2ZSBlcnJvcnMuXG4gKlxuICogQGNhdGVnb3J5IENvbW1vblxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVNZXNzYWdlKHZhbCkge1xuICAgIGlmICghaXNPYmplY3QodmFsKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1lc3NhZ2UgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gb2JqZWN0LCBidXQgZ290ICR7ZXh0ZW5kZWRUeXBlb2YodmFsKX1gKTtcbiAgICB9XG4gICAgaWYgKCF2YWwudHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1lc3NhZ2UgaXMgbWlzc2luZyB0aGUgJ3R5cGUnIHByb3BlcnR5YCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsLnR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTWVzc2FnZSBpcyBleHBlY3RzIHRoZSAndHlwZScgcHJvcGVydHkgdG8gYmUgYSBzdHJpbmcsIGJ1dCBnb3QgJHtleHRlbmRlZFR5cGVvZih2YWwudHlwZSl9YCk7XG4gICAgfVxuICAgIHN3aXRjaCAodmFsLnR5cGUpIHtcbiAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5Db25uZWN0aW9uSW5pdDpcbiAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5Db25uZWN0aW9uQWNrOlxuICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLlBpbmc6XG4gICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuUG9uZzoge1xuICAgICAgICAgICAgaWYgKHZhbC5wYXlsb2FkICE9IG51bGwgJiYgIWlzT2JqZWN0KHZhbC5wYXlsb2FkKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke3ZhbC50eXBlfVwiIG1lc3NhZ2UgZXhwZWN0cyB0aGUgJ3BheWxvYWQnIHByb3BlcnR5IHRvIGJlIGFuIG9iamVjdCBvciBudWxsaXNoIG9yIG1pc3NpbmcsIGJ1dCBnb3QgXCIke3ZhbC5wYXlsb2FkfVwiYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLlN1YnNjcmliZToge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwuaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSBleHBlY3RzIHRoZSAnaWQnIHByb3BlcnR5IHRvIGJlIGEgc3RyaW5nLCBidXQgZ290ICR7ZXh0ZW5kZWRUeXBlb2YodmFsLmlkKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdmFsLmlkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSByZXF1aXJlcyBhIG5vbi1lbXB0eSAnaWQnIHByb3BlcnR5YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzT2JqZWN0KHZhbC5wYXlsb2FkKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke3ZhbC50eXBlfVwiIG1lc3NhZ2UgZXhwZWN0cyB0aGUgJ3BheWxvYWQnIHByb3BlcnR5IHRvIGJlIGFuIG9iamVjdCwgYnV0IGdvdCAke2V4dGVuZGVkVHlwZW9mKHZhbC5wYXlsb2FkKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsLnBheWxvYWQucXVlcnkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSBwYXlsb2FkIGV4cGVjdHMgdGhlICdxdWVyeScgcHJvcGVydHkgdG8gYmUgYSBzdHJpbmcsIGJ1dCBnb3QgJHtleHRlbmRlZFR5cGVvZih2YWwucGF5bG9hZC5xdWVyeSl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsLnBheWxvYWQudmFyaWFibGVzICE9IG51bGwgJiYgIWlzT2JqZWN0KHZhbC5wYXlsb2FkLnZhcmlhYmxlcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHt2YWwudHlwZX1cIiBtZXNzYWdlIHBheWxvYWQgZXhwZWN0cyB0aGUgJ3ZhcmlhYmxlcycgcHJvcGVydHkgdG8gYmUgYSBhbiBvYmplY3Qgb3IgbnVsbGlzaCBvciBtaXNzaW5nLCBidXQgZ290ICR7ZXh0ZW5kZWRUeXBlb2YodmFsLnBheWxvYWQudmFyaWFibGVzKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWwucGF5bG9hZC5vcGVyYXRpb25OYW1lICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICBleHRlbmRlZFR5cGVvZih2YWwucGF5bG9hZC5vcGVyYXRpb25OYW1lKSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHt2YWwudHlwZX1cIiBtZXNzYWdlIHBheWxvYWQgZXhwZWN0cyB0aGUgJ29wZXJhdGlvbk5hbWUnIHByb3BlcnR5IHRvIGJlIGEgc3RyaW5nIG9yIG51bGxpc2ggb3IgbWlzc2luZywgYnV0IGdvdCAke2V4dGVuZGVkVHlwZW9mKHZhbC5wYXlsb2FkLm9wZXJhdGlvbk5hbWUpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbC5wYXlsb2FkLmV4dGVuc2lvbnMgIT0gbnVsbCAmJiAhaXNPYmplY3QodmFsLnBheWxvYWQuZXh0ZW5zaW9ucykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHt2YWwudHlwZX1cIiBtZXNzYWdlIHBheWxvYWQgZXhwZWN0cyB0aGUgJ2V4dGVuc2lvbnMnIHByb3BlcnR5IHRvIGJlIGEgYW4gb2JqZWN0IG9yIG51bGxpc2ggb3IgbWlzc2luZywgYnV0IGdvdCAke2V4dGVuZGVkVHlwZW9mKHZhbC5wYXlsb2FkLmV4dGVuc2lvbnMpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5OZXh0OiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbC5pZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHt2YWwudHlwZX1cIiBtZXNzYWdlIGV4cGVjdHMgdGhlICdpZCcgcHJvcGVydHkgdG8gYmUgYSBzdHJpbmcsIGJ1dCBnb3QgJHtleHRlbmRlZFR5cGVvZih2YWwuaWQpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF2YWwuaWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHt2YWwudHlwZX1cIiBtZXNzYWdlIHJlcXVpcmVzIGEgbm9uLWVtcHR5ICdpZCcgcHJvcGVydHlgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNPYmplY3QodmFsLnBheWxvYWQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSBleHBlY3RzIHRoZSAncGF5bG9hZCcgcHJvcGVydHkgdG8gYmUgYW4gb2JqZWN0LCBidXQgZ290ICR7ZXh0ZW5kZWRUeXBlb2YodmFsLnBheWxvYWQpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5FcnJvcjoge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwuaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSBleHBlY3RzIHRoZSAnaWQnIHByb3BlcnR5IHRvIGJlIGEgc3RyaW5nLCBidXQgZ290ICR7ZXh0ZW5kZWRUeXBlb2YodmFsLmlkKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdmFsLmlkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSByZXF1aXJlcyBhIG5vbi1lbXB0eSAnaWQnIHByb3BlcnR5YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWFyZUdyYXBoUUxFcnJvcnModmFsLnBheWxvYWQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSBleHBlY3RzIHRoZSAncGF5bG9hZCcgcHJvcGVydHkgdG8gYmUgYW4gYXJyYXkgb2YgR3JhcGhRTCBlcnJvcnMsIGJ1dCBnb3QgJHtKU09OLnN0cmluZ2lmeSh2YWwucGF5bG9hZCl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLkNvbXBsZXRlOiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbC5pZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHt2YWwudHlwZX1cIiBtZXNzYWdlIGV4cGVjdHMgdGhlICdpZCcgcHJvcGVydHkgdG8gYmUgYSBzdHJpbmcsIGJ1dCBnb3QgJHtleHRlbmRlZFR5cGVvZih2YWwuaWQpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF2YWwuaWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHt2YWwudHlwZX1cIiBtZXNzYWdlIHJlcXVpcmVzIGEgbm9uLWVtcHR5ICdpZCcgcHJvcGVydHlgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbWVzc2FnZSAndHlwZScgcHJvcGVydHkgXCIke3ZhbC50eXBlfVwiYCk7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG59XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgcHJvdmlkZWQgdmFsdWUgaXMgYSB2YWxpZCBHcmFwaFFMIG92ZXIgV2ViU29ja2V0IG1lc3NhZ2UuXG4gKlxuICogQGRlcHJlY2F0ZWQgVXNlIGB2YWxpZGF0ZU1lc3NhZ2VgIGluc3RlYWQuXG4gKlxuICogQGNhdGVnb3J5IENvbW1vblxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNNZXNzYWdlKHZhbCkge1xuICAgIHRyeSB7XG4gICAgICAgIHZhbGlkYXRlTWVzc2FnZSh2YWwpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vKipcbiAqIFBhcnNlcyB0aGUgcmF3IHdlYnNvY2tldCBtZXNzYWdlIGRhdGEgdG8gYSB2YWxpZCBtZXNzYWdlLlxuICpcbiAqIEBjYXRlZ29yeSBDb21tb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlTWVzc2FnZShkYXRhLCByZXZpdmVyKSB7XG4gICAgcmV0dXJuIHZhbGlkYXRlTWVzc2FnZSh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgPyBKU09OLnBhcnNlKGRhdGEsIHJldml2ZXIpIDogZGF0YSk7XG59XG4vKipcbiAqIFN0cmluZ2lmaWVzIGEgdmFsaWQgbWVzc2FnZSByZWFkeSB0byBiZSBzZW50IHRocm91Z2ggdGhlIHNvY2tldC5cbiAqXG4gKiBAY2F0ZWdvcnkgQ29tbW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdpZnlNZXNzYWdlKG1zZywgcmVwbGFjZXIpIHtcbiAgICB2YWxpZGF0ZU1lc3NhZ2UobXNnKTtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkobXNnLCByZXBsYWNlcik7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/graphql-ws/lib/common.mjs\n',
      );

      /***/
    },

  /***/ "(ssr)/../../node_modules/graphql-ws/lib/utils.mjs":
    /*!***************************************************!*\
  !*** ../../node_modules/graphql-ws/lib/utils.mjs ***!
  \***************************************************/
    /***/ (
      __unused_webpack___webpack_module__,
      __webpack_exports__,
      __webpack_require__,
    ) => {
      eval(
        "__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   areGraphQLErrors: () => (/* binding */ areGraphQLErrors),\n/* harmony export */   extendedTypeof: () => (/* binding */ extendedTypeof),\n/* harmony export */   isAsyncGenerator: () => (/* binding */ isAsyncGenerator),\n/* harmony export */   isAsyncIterable: () => (/* binding */ isAsyncIterable),\n/* harmony export */   isObject: () => (/* binding */ isObject),\n/* harmony export */   limitCloseReason: () => (/* binding */ limitCloseReason)\n/* harmony export */ });\n/** @private */\nfunction extendedTypeof(val) {\n    if (val === null) {\n        return 'null';\n    }\n    if (Array.isArray(val)) {\n        return 'array';\n    }\n    return typeof val;\n}\n/** @private */\nfunction isObject(val) {\n    return extendedTypeof(val) === 'object';\n}\n/** @private */\nfunction isAsyncIterable(val) {\n    return typeof Object(val)[Symbol.asyncIterator] === 'function';\n}\n/** @private */\nfunction isAsyncGenerator(val) {\n    return (isObject(val) &&\n        typeof Object(val)[Symbol.asyncIterator] === 'function' &&\n        typeof val.return === 'function'\n    // for lazy ones, we only need the return anyway\n    // typeof val.throw === 'function' &&\n    // typeof val.next === 'function'\n    );\n}\n/** @private */\nfunction areGraphQLErrors(obj) {\n    return (Array.isArray(obj) &&\n        // must be at least one error\n        obj.length > 0 &&\n        // error has at least a message\n        obj.every((ob) => 'message' in ob));\n}\n/**\n * Limits the WebSocket close event reason to not exceed a length of one frame.\n * Reference: https://datatracker.ietf.org/doc/html/rfc6455#section-5.2.\n *\n * @private\n */\nfunction limitCloseReason(reason, whenTooLong) {\n    return reason.length < 124 ? reason : whenTooLong;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2dyYXBocWwtd3MvbGliL3V0aWxzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zaGVyaWZmL0Rlc2t0b3AvYml0Y2FzaC1hcHBzL21hc3RlcmJvdHMvbm9kZV9tb2R1bGVzL2dyYXBocWwtd3MvbGliL3V0aWxzLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQHByaXZhdGUgKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmRlZFR5cGVvZih2YWwpIHtcbiAgICBpZiAodmFsID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgfVxuICAgIHJldHVybiB0eXBlb2YgdmFsO1xufVxuLyoqIEBwcml2YXRlICovXG5leHBvcnQgZnVuY3Rpb24gaXNPYmplY3QodmFsKSB7XG4gICAgcmV0dXJuIGV4dGVuZGVkVHlwZW9mKHZhbCkgPT09ICdvYmplY3QnO1xufVxuLyoqIEBwcml2YXRlICovXG5leHBvcnQgZnVuY3Rpb24gaXNBc3luY0l0ZXJhYmxlKHZhbCkge1xuICAgIHJldHVybiB0eXBlb2YgT2JqZWN0KHZhbClbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID09PSAnZnVuY3Rpb24nO1xufVxuLyoqIEBwcml2YXRlICovXG5leHBvcnQgZnVuY3Rpb24gaXNBc3luY0dlbmVyYXRvcih2YWwpIHtcbiAgICByZXR1cm4gKGlzT2JqZWN0KHZhbCkgJiZcbiAgICAgICAgdHlwZW9mIE9iamVjdCh2YWwpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICB0eXBlb2YgdmFsLnJldHVybiA9PT0gJ2Z1bmN0aW9uJ1xuICAgIC8vIGZvciBsYXp5IG9uZXMsIHdlIG9ubHkgbmVlZCB0aGUgcmV0dXJuIGFueXdheVxuICAgIC8vIHR5cGVvZiB2YWwudGhyb3cgPT09ICdmdW5jdGlvbicgJiZcbiAgICAvLyB0eXBlb2YgdmFsLm5leHQgPT09ICdmdW5jdGlvbidcbiAgICApO1xufVxuLyoqIEBwcml2YXRlICovXG5leHBvcnQgZnVuY3Rpb24gYXJlR3JhcGhRTEVycm9ycyhvYmopIHtcbiAgICByZXR1cm4gKEFycmF5LmlzQXJyYXkob2JqKSAmJlxuICAgICAgICAvLyBtdXN0IGJlIGF0IGxlYXN0IG9uZSBlcnJvclxuICAgICAgICBvYmoubGVuZ3RoID4gMCAmJlxuICAgICAgICAvLyBlcnJvciBoYXMgYXQgbGVhc3QgYSBtZXNzYWdlXG4gICAgICAgIG9iai5ldmVyeSgob2IpID0+ICdtZXNzYWdlJyBpbiBvYikpO1xufVxuLyoqXG4gKiBMaW1pdHMgdGhlIFdlYlNvY2tldCBjbG9zZSBldmVudCByZWFzb24gdG8gbm90IGV4Y2VlZCBhIGxlbmd0aCBvZiBvbmUgZnJhbWUuXG4gKiBSZWZlcmVuY2U6IGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNjQ1NSNzZWN0aW9uLTUuMi5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gbGltaXRDbG9zZVJlYXNvbihyZWFzb24sIHdoZW5Ub29Mb25nKSB7XG4gICAgcmV0dXJuIHJlYXNvbi5sZW5ndGggPCAxMjQgPyByZWFzb24gOiB3aGVuVG9vTG9uZztcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/graphql-ws/lib/utils.mjs\n",
      );

      /***/
    },
};
